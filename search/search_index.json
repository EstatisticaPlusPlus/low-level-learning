{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Sobre","text":"<p>O projeto de extens\u00e3o visa criar materiais educacionais sobre as linguagens de programa\u00e7\u00e3o C e Fortran. Inicialmente, os materiais foram feitos em LaTeX, destacando os conceitos b\u00e1sicos de C e explorando o compilador GCC. Mais tarde, optamos por migrar para uma plataforma online usando HTML5 e CSS para oferecer conte\u00fado mais acess\u00edvel e interativo aos usu\u00e1rios interessados. Por fim, estou repassando para o MkDocs para facilitar a adi\u00e7\u00e3o de novos cap\u00edtulos. Essa transi\u00e7\u00e3o permitir\u00e1 uma melhor experi\u00eancia de aprendizado para os estudantes e entusiastas das linguagens.</p>"},{"location":"#estrutura","title":"Estrutura","text":"<p>Em constru\u00e7\u00e3o..</p>"},{"location":"#inspiracao","title":"Inspira\u00e7\u00e3o","text":"<p>Cap\u00edtulos da Linguagem C:</p> <p>\"An Introduction to GCC\" \u00e9 um livro que oferece uma introdu\u00e7\u00e3o pr\u00e1tica e abrangente sobre o compilador GNU Compiler Collection (GCC) e seu uso na programa\u00e7\u00e3o em linguagem C. Os autores explicam desde conceitos b\u00e1sicos at\u00e9 t\u00e9cnicas avan\u00e7adas de compila\u00e7\u00e3o, incluindo o funcionamento interno do GCC. \u00c9 uma leitura \u00fatil para estudantes e desenvolvedores interessados em compreender melhor como usar o GCC para compilar programas em C e aprofundar seus conhecimentos sobre compila\u00e7\u00e3o, otimiza\u00e7\u00e3o e depura\u00e7\u00e3o de c\u00f3digo.</p> <p>Cap\u00edtulos em Fortran:</p> <ul> <li>Fortran 77: Guia de Stanford para F77</li> <li>Fortran 90: Tutorial de Come\u00e7o R\u00e1pido, da p\u00e1gina Fortran lang</li> </ul>"},{"location":"#referencias","title":"Refer\u00eancias","text":"<p>UGH, Brian J.; STALLMAN, Richard M. An Introduction to GCC. Network Theory Ltd., 2004. ISBN 978-0954161798.</p> <p>TANFORD UNIVERSITY. ME 200C - Basics of the Finite Element Method. Dispon\u00edvel em: https://web.stanford.edu/class/me200c/. Acesso em: 10 jul. 2025.</p>"},{"location":"Autotools/capitulo_1/","title":"1. Introdu\u00e7\u00e3o e Instala\u00e7\u00e3o","text":""},{"location":"Autotools/capitulo_1/#11-introducao","title":"1.1. Introdu\u00e7\u00e3o","text":"<p>GNU Autotools \u00e9 um conjunto de ferramentas do GNU que visam a padroniza\u00e7\u00e3o e facilitamento da compila\u00e7\u00e3o de diversas linguagens para diferente arquiteturas e sistemas operacionais.</p> <p>Essa documenta\u00e7\u00e3o est\u00e1 sendo criada a partir de uma m\u00e1quina com Linux Mint 21</p>"},{"location":"Autotools/capitulo_1/#12-instalacao","title":"1.2. Instala\u00e7\u00e3o","text":"<p>O pacote do Autotools possivelmente est\u00e1 presente no seu gerenciador de pacotes padr\u00e3o do seu sistema.</p>"},{"location":"Autotools/capitulo_1/#debian-ubuntu-linux-mint","title":"Debian / Ubuntu / Linux Mint","text":"<pre><code>$ sudo apt update\n$ sudo apt install autoconf automake m4\n</code></pre>"},{"location":"Autotools/capitulo_1/#red-hat-centos-fedora","title":"Red Hat / CentOS / Fedora","text":"<pre><code>$ sudo dnf install autoconf automake m4\n\n# Ou\n$ sudo yum install autoconf automake m4\n</code></pre>"},{"location":"Autotools/capitulo_1/#arch-linux-manjaro","title":"Arch Linux / Manjaro","text":"<pre><code>$ sudo pacman -S autoconf automake m4\n</code></pre>"},{"location":"Autotools/capitulo_1/#opensuse","title":"openSUSE","text":"<pre><code>$ sudo zypper install autoconf automake m4\n</code></pre>"},{"location":"Autotools/capitulo_1/#alpine-linux","title":"Alpine Linux","text":"<pre><code>$ sudo apk add autoconf automake m4\n</code></pre>"},{"location":"Autotools/capitulo_1/#gentoo","title":"Gentoo","text":"<pre><code>$ sudo emerge -av sys-devel/autoconf sys-devel/automake sys-devel/sys-devel/m4\n</code></pre>"},{"location":"Autotools/capitulo_1/#verifique-a-instalacao","title":"Verifique a Instala\u00e7\u00e3o","text":"<pre><code>autoconf --version\nautomake --version\n</code></pre> <p>Estes comandos baixar\u00e3o e instalar\u00e3o todas as ferramentas necess\u00e1rias para acompanhar essa documenta\u00e7\u00e3o</p>"},{"location":"Autotools/capitulo_2/","title":"2. Exemplo M\u00ednimo","text":"<p>Para come\u00e7ar, crie um arquivo com o nome <code>configure.ac</code> e escreva:</p> <pre><code>AC_INIT\n\nAC_OUTPUT\n</code></pre> <ul> <li> <p><code>AC_INIT([projeto], [vers\u00e3o])</code>: Macro para iniciar o Autoconf com dois   argumentos opcionais para o nome do projeto e para a vers\u00e3o do projeto</p> </li> <li> <p><code>AC_OUTPUT</code>: Macro para indicar a sa\u00edda das mensagens do autoconf, nesse   caso ser\u00e1 o <code>stdout</code></p> </li> </ul> <p>Agora, dentro do mesmo diret\u00f3rio onde o arquivo <code>configure.ac</code> reside, digite:</p> <pre><code>$ autoconf\n</code></pre> <p>Caso n\u00e3o haja erros, a n\u00e3o haver\u00e1 nenhuma sa\u00edda e um execut\u00e1vel <code>configure</code> ser\u00e1 criado.</p> <p>Agora, executando esse arquivo a sa\u00edda ser\u00e1:</p> <pre><code>$ ./configure\nconfigure: creating ./config.status\n</code></pre> <p>e tamb\u00e9m ser\u00e3o criados outros arquivos que n\u00e3o s\u00e3o relevantes no momento</p>"},{"location":"Autotools/capitulo_2/#22-checagem-de-bibliotecas-tipos-e-funcoes","title":"2.2 Checagem de Bibliotecas, Tipos e Fun\u00e7\u00f5es","text":"<p>\u00c9 poss\u00edvel tamb\u00e9m fazer checagens de fun\u00e7\u00f5es, bibliotecas e at\u00e9 tipos definidos nativamente com autoconf</p> <p>No arquivo <code>configure.ac</code> criado anteriormente, adicione as seguintes linhas:</p> <pre><code>AC_INIT\n\nAC_PROG_CC\n\nAC_TYPE_SIZE_T\nAC_TYPE_UINT32_T\n\nAC_CHECK_FUNCS([malloc memset strchr])\n\nAC_OUTPUT\n</code></pre> <ul> <li><code>AC_TYPE_SIZE_T</code>: Macro para verificar a exist\u00eancia do tipo <code>size_t</code></li> <li><code>AC_TYPE_UINT32_T</code>: Macro para verificar a exist\u00eancia do tipo <code>uint32_t</code></li> <li><code>AC_CHECK_HEADERS([headers])</code>: Macro para verificar a exist\u00eancia de   bibliotecas no sistema. As bibliotecas devem ser separadas por espa\u00e7os</li> <li><code>AC_CHECK_LIB([lib], [func])</code>: Macro para verificar a exist\u00eancia de uma   fun\u00e7\u00e3o espec\u00edfica dentro de uma biblioteca</li> <li><code>AC_CHECK_FUNCS([funcs])</code>: Macro para verificar a exist\u00eancia de fun\u00e7\u00f5es no   sistema, independente de onde elas venham. As fun\u00e7\u00f5es devem ser separadas por   espa\u00e7os</li> </ul> <p>Ao executar os comandos corretos para a checagem, caso n\u00e3o hajam erros, a sa\u00edda ser\u00e1:</p> <pre><code>$ autoconf\n$ ./configure\nchecking for gcc... gcc\nchecking whether the C compiler works... yes\nchecking for C compiler default output file name... a.out\nchecking for suffix of executables...\nchecking whether we are cross compiling... no\nchecking for suffix of object files... o\nchecking whether the compiler supports GNU C... yes\nchecking whether gcc accepts -g... yes\nchecking for gcc option to enable C11 features... none needed\nchecking for stdio.h... yes\nchecking for stdlib.h... yes\nchecking for string.h... yes\nchecking for inttypes.h... yes\nchecking for stdint.h... yes\nchecking for strings.h... yes\nchecking for sys/stat.h... yes\nchecking for sys/types.h... yes\nchecking for unistd.h... yes\nchecking for size_t... yes\nchecking for uint32_t... yes\nchecking for stdlib.h... yes\nchecking for stdio.h... yes\nchecking for string.h... yes\nchecking for unistd.h... yes\nchecking for pthread_create in -lpthread... yes\nchecking for sqrt in -lm... yes\nchecking for malloc... yes\nchecking for memset... yes\nchecking for strchr... yes\nconfigure: creating ./config.status\n</code></pre> <p>Em um sistema operacional diferente, e em vers\u00f5es diferentes do C, a sa\u00edda ser\u00e1 levemente diferente, por\u00e9m, sem mensagens de errors sendo apresentadas, est\u00e1 tudo correto.</p> <p>Como \u00e9 poss\u00edvel observar, o autoconf automaticamente determina de onde certos tipos vem e checa a exist\u00eancia do header que conteria esse tipo. A verifica\u00e7\u00e3o da biblioteca <code>inttypes.h</code> \u00e9 respons\u00e1vel por aferir a presen\u00e7a dos tipos <code>size_t</code> e <code>uint32_t</code>, os quais foram constatada a exist\u00eancia logo ap\u00f3s.</p> <p>O mesmo se aplica \u00e0s fun\u00e7\u00f5es, <code>malloc</code> e <code>memset</code> est\u00e3o presentes em <code>stdlib.h</code>, que foram checados anteriormente pelo <code>configure</code>, e logo ap\u00f3s averiguados.</p>"},{"location":"Autotools/capitulo_3/","title":"3. Checagem de Compiladores","text":"<p>O Autoconf possui alguns macros padr\u00f5es para checagem de alguns compiladores mais comuns.</p>"},{"location":"Autotools/capitulo_3/#31-programa","title":"3.1. Programa","text":"<p>Crie um arquivo <code>configure.ac</code> e escreva:</p> <pre><code>AC_INIT([epp], 1.0)\n\nAC_PROG_GO # GO compiler\nAC_PROG_OBJC # Objective C compiler\nAC_PROG_CXX # C++ compiler\nAC_PROG_OBJCXX # Objective C++ compiler\nAC_PROG_FC # Check for compilers for Fortran 77, Fortran 90, and Fortran 95\nAC_PROG_F77([fl32 f77]) # Check for specific Fortran 77 compilers\n\nAC_OUTPUT\n</code></pre> <ul> <li><code>AC_PROG_XX([compiladores])</code>: Conjunto de macros para fazer as verifica\u00e7\u00f5es   padr\u00e3o dos compiladores de uma linguagem espec\u00edfica. \u00c9 poss\u00edvel passar um   compilador espec\u00edfico para verificar a sua exist\u00eancia, mas n\u00e3o \u00e9 obrigat\u00f3rio,   nesse caso, as checagens padr\u00f5es ser\u00e3o feitas</li> </ul>"},{"location":"Autotools/capitulo_3/#32-saida-esperada","title":"3.2. Sa\u00edda Esperada","text":"<p>A sa\u00edda depender\u00e1 dos compiladores e as vers\u00f5es presentes no seu sistema, por\u00e9m a estrutura ser\u00e1 similar</p> <pre><code>$ autoconf &amp;&amp; ./configure\nchecking for g++... g++\nchecking whether the C++ compiler works... yes\nchecking for C++ compiler default output file name... a.out\nchecking for suffix of executables...\nchecking whether we are cross compiling... no\nchecking for suffix of object files... o\nchecking whether the compiler supports GNU C++... yes\nchecking whether g++ accepts -g... yes\nchecking for g++ option to enable C++11 features... none needed\nchecking for g++... g++\nchecking whether the compiler supports GNU Objective C++... no\nchecking whether g++ accepts -g... no\nchecking for gfortran... gfortran\nchecking whether the compiler supports GNU Fortran... yes\nchecking whether gfortran accepts -g... yes\nchecking for g77... no\nchecking for xlf... no\nchecking for f77... f77\nchecking whether the compiler supports GNU Fortran 77... yes\nchecking whether f77 accepts -g... yes\nchecking whether the compiler supports GNU Fortran 77... yes\nchecking whether f77 accepts -g... yes\nconfigure: creating ./config.status\n</code></pre>"},{"location":"Autotools/capitulo_4/","title":"4. Verifica\u00e7\u00e3o de Bibliotecas","text":"<p>O Autoconf tamb\u00e9m possui macros definidas para a verifica\u00e7\u00e3o de bibliotecas e headers existentes no sistema.</p>"},{"location":"Autotools/capitulo_4/#41-programa","title":"4.1. Programa","text":"<pre><code># Verificando algumas bibliotecas\nAC_INIT([epp], [1.0])\n\nAC_CHECK_LIB([pthread], [pthread_create])\nAC_CHECK_LIB([m], [sqrt])\n\nAC_CHECK_HEADERS([stdlib.h stdio.h string.h unistd.h])\n\nAC_OUTPUT\n</code></pre>"},{"location":"Autotools/capitulo_4/#43-macros-utilizados","title":"4.3. Macros Utilizados","text":"<ul> <li><code>AC_CHECK_LIB([biblioteca], [fun\u00e7\u00e3o])</code>: Verifica se biblioteca existe e   cont\u00e9m fun\u00e7\u00e3o espec\u00edfica</li> <li><code>AC_CHECK_HEADERS([headers])</code>: Confirma exist\u00eancia de headers no sistema</li> </ul>"},{"location":"Autotools/capitulo_4/#44-saida-esperada","title":"4.4. Sa\u00edda Esperada","text":"<pre><code>checking for gcc... gcc\nchecking whether the C compiler works... yes\nchecking for C compiler default output file name... a.out\nchecking for suffix of executables...\nchecking whether we are cross compiling... no\nchecking for suffix of object files... o\nchecking whether the compiler supports GNU C... yes\nchecking whether gcc accepts -g... yes\nchecking for gcc option to enable C11 features... none needed\nchecking for pthread_create in -lpthread... yes\nchecking for sqrt in -lm... yes\nchecking for stdio.h... yes\nchecking for stdlib.h... yes\nchecking for string.h... yes\nchecking for inttypes.h... yes\nchecking for stdint.h... yes\nchecking for strings.h... yes\nchecking for sys/stat.h... yes\nchecking for sys/types.h... yes\nchecking for unistd.h... yes\nchecking for stdlib.h... yes\nchecking for stdio.h... yes\nchecking for string.h... yes\nchecking for unistd.h... yes\nconfigure: creating ./config.status\n</code></pre>"},{"location":"Autotools/capitulo_5/","title":"5. Verifica\u00e7\u00e3o de Tipos e Fun\u00e7\u00f5es","text":"<p>Al\u00e9m de bibliotecas e compiladores, h\u00e1 a possibilidade de checagem de alguns tipos e fun\u00e7\u00f5es.</p>"},{"location":"Autotools/capitulo_5/#51-programa","title":"5.1. Programa","text":"<pre><code># Verificando alguns tipos e fun\u00e7\u00f5es basicas\nAC_INIT([epp], [1.0])\n\nAC_PROG_CC\n\nAC_TYPE_SIZE_T\nAC_TYPE_UINT32_T\n\nAC_CHECK_FUNCS([malloc memset strchr])\n\nAC_OUTPUT\n</code></pre>"},{"location":"Autotools/capitulo_5/#52-macros-utilizadas","title":"5.2. Macros Utilizadas","text":"<ul> <li><code>AC_TYPE_XX</code>: Verifica a exist\u00eancia de um tipo espec\u00edfico. No programa,   <code>size_t</code>, <code>uint32_t</code></li> <li><code>AC_CHECK_FUNCS</code>: Verifica a exist\u00eancia de fun\u00e7\u00f5es no sistema, independente   de onde estejam. No programa, <code>malloc</code>, <code>memset</code> e <code>strchr</code></li> </ul>"},{"location":"Autotools/capitulo_5/#54-saida-esperada","title":"5.4. Sa\u00edda Esperada","text":"<pre><code>checking for gcc... gcc\nchecking whether the C compiler works... yes\nchecking for C compiler default output file name... a.out\nchecking for suffix of executables...\nchecking whether we are cross compiling... no\nchecking for suffix of object files... o\nchecking whether the compiler supports GNU C... yes\nchecking whether gcc accepts -g... yes\nchecking for gcc option to enable C11 features... none needed\nchecking for stdio.h... yes\nchecking for stdlib.h... yes\nchecking for string.h... yes\nchecking for inttypes.h... yes\nchecking for stdint.h... yes\nchecking for strings.h... yes\nchecking for sys/stat.h... yes\nchecking for sys/types.h... yes\nchecking for unistd.h... yes\nchecking for size_t... yes\nchecking for uint32_t... yes\nchecking for malloc... yes\nchecking for memset... yes\nchecking for strchr... yes\nconfigure: creating ./config.status\n</code></pre>"},{"location":"Autotools/capitulo_6/","title":"6. Verifica\u00e7\u00e3o de Padr\u00f5es de Linguagem","text":"<p>Vamos testar suporte a diferentes padr\u00f5es de C e C++.</p> <p>At\u00e9 o momento, utilizamos macros definidas por padr\u00e3o pelo Autoconf, por\u00e9m, a partir de agora precisaremos definir nossos pr\u00f3prios macros, pois n\u00e3o h\u00e1 uma forma padr\u00e3o de testar padr\u00f5es de linguagem.</p> <p>Por uma quest\u00e3o de boa pr\u00e1tica e organiza\u00e7\u00e3o, vamos separar o arquivo principal <code>configure.ac</code> dos nossos macros definidos futuramente. Crie um diret\u00f3rio chamado <code>m4</code> e crie um arquivo <code>checks.m4</code> dentro desse diret\u00f3rio.</p>"},{"location":"Autotools/capitulo_6/#61-codigo-do-m4checksm4","title":"6.1. C\u00f3digo do m4/checks.m4","text":"<pre><code>AC_DEFUN([CHECK_C_STANDARD], [\n  AC_MSG_CHECKING([for C$1 support])\n  AC_COMPILE_IFELSE(\n    [AC_LANG_SOURCE([\n      #if !defined(__STDC_VERSION__) || __STDC_VERSION__ &lt; $2\n      #error \"C$1 not supported\"\n      #endif\n      int main(void) { return 0; }\n    ])],\n    [AC_MSG_RESULT([yes])],\n    [AC_MSG_RESULT([no])]\n  )\n])\n\nAC_DEFUN([CHECK_CXX_STANDARD], [\n  AC_MSG_CHECKING([for C++$1 support])\n  AC_COMPILE_IFELSE(\n    [AC_LANG_SOURCE([\n      #if !defined(__cplusplus) || __cplusplus &lt; $2\n      #error \"C++$1 not supported\"\n      #endif\n      int main() { return 0; }\n    ])],\n    [AC_MSG_RESULT([yes])],\n    [AC_MSG_RESULT([no])]\n  )\n])\n</code></pre>"},{"location":"Autotools/capitulo_6/#62-macros-utilizados","title":"6.2. Macros Utilizados","text":"<p>Este c\u00f3digo define duas macros para verificar suporte a padr\u00f5es C e C++. Vamos analisar cada parte:</p> <ul> <li><code>CHECK_C_STANDARD</code>: Verifica se o compilador C suporta uma vers\u00e3o espec\u00edfica   do padr\u00e3o C.</li> <li><code>CHECK_CXX_STANDARD</code>: Verifica se o compilador C++ suporta uma vers\u00e3o   espec\u00edfica do padr\u00e3o C++.</li> </ul> <p>Ambos os macros seguem o mesmo padr\u00e3o:</p> <ol> <li><code>AC_MSG_CHECKING(msg)</code>: Exibe uma mensagem de verifica\u00e7\u00e3o    (ex: \"checking for C11 support\"). A palavra \"checking\" \u00e9 automaticamente    posta no inicio da mensagem</li> <li><code>AC_COMPILE_IFELSE([program], [success], [failure])</code>: Tenta compilar um programa    teste, em caso de sucesso, executar\u00e1 o que est\u00e1 em <code>success</code>, em caso de    falha, executar\u00e1 o que est\u00e1 em <code>failure</code></li> <li><code>AC_LANG_SOURCE([program])</code>: Define o c\u00f3digo fonte a ser compilado. Caso n\u00e3o    seja dado um programa, ser\u00e1 utilizado um programa padr\u00e3o simples definido    pelo Autoconf</li> <li><code>AC_MSG_RESULT</code>: Exibe o resultado (yes/no)</li> </ol>"},{"location":"Autotools/capitulo_6/#621-detalhes-da-implementacao-para-c-check_c_standard","title":"6.2.1. Detalhes da Implementa\u00e7\u00e3o para C (<code>CHECK_C_STANDARD</code>)","text":"<ul> <li>Verifica <code>__STDC_VERSION__</code> (macro que indica a vers\u00e3o do padr\u00e3o C)</li> <li>Compara com o valor num\u00e9rico fornecido no segundo argumento (<code>$2</code>)</li> <li>Valores t\u00edpicos:<ul> <li>C99: <code>199901L</code></li> <li>C11: <code>201112L</code></li> <li>C17: <code>201710L</code></li> </ul> </li> </ul>"},{"location":"Autotools/capitulo_6/#622-detalhes-da-implementacao-para-c-check_cxx_standard","title":"6.2.2. Detalhes da Implementa\u00e7\u00e3o para C++ (<code>CHECK_CXX_STANDARD</code>)","text":"<ul> <li>Verifica <code>__cplusplus</code> (macro que indica a vers\u00e3o do padr\u00e3o C++)</li> <li>Compara com o valor num\u00e9rico fornecido no segundo argumento (<code>$2</code>)</li> <li>Valores t\u00edpicos:<ul> <li>C++11: <code>201103L</code></li> <li>C++14: <code>201402L</code></li> <li>C++17: <code>201703L</code></li> <li>C++20: <code>202002L</code></li> </ul> </li> </ul>"},{"location":"Autotools/capitulo_6/#63-fluxo-de-execucao-da-funcao","title":"6.3. Fluxo de execu\u00e7\u00e3o da fun\u00e7\u00e3o","text":"<ol> <li>O Autoconf expande as macros durante a gera\u00e7\u00e3o do script <code>configure</code></li> <li>Os argumentos s\u00e3o passados no estilo bash, o primeiro argumento \u00e9 <code>$1</code>, o    segundo, <code>$2</code>, etc.</li> <li>Quando <code>./configure</code> \u00e9 executado:<ul> <li>Compila o programa teste</li> <li>Se compilar com sucesso: padr\u00e3o suportado (\"yes\")</li> <li>Se falhar (devido ao <code>#error</code>): padr\u00e3o n\u00e3o suportado (\"no\")</li> </ul> </li> </ol>"},{"location":"Autotools/capitulo_6/#64-codigo-do-configureac","title":"6.4. C\u00f3digo do configure.ac","text":"<pre><code>AC_INIT([epp], [1.0])\n\nm4_include([m4/checks.m4])\n\nAC_PROG_CC\nAC_PROG_CXX\n\nAC_LANG_PUSH([C])\nCHECK_C_STANDARD([11], [201112L])  # C11\nCHECK_C_STANDARD([17], [201710L])  # C17\nCHECK_C_STANDARD([23], [202311L])  # C23\nAC_LANG_POP([C])\n\nAC_LANG_PUSH([C++])\nCHECK_CXX_STANDARD([11], [201103L])  # C++11\nCHECK_CXX_STANDARD([14], [201402L])  # C++14\nCHECK_CXX_STANDARD([17], [201703L])  # C++17\nCHECK_CXX_STANDARD([20], [202002L])  # C++20\nCHECK_CXX_STANDARD([23], [202302L])  # C++23\nAC_LANG_POP([C++])\n\nAC_OUTPUT\n</code></pre> <ul> <li><code>AC_LANG_PUSH([lang])</code> e <code>AC_LANG_POP([lang])</code>: indicam qual linguagem o   Autoconf est\u00e1 lidando na hora de compilar o programa passado</li> </ul>"},{"location":"Autotools/capitulo_6/#64-saida-esperada","title":"6.4. Sa\u00edda Esperada","text":"<pre><code>checking for gcc... gcc\nchecking whether the C compiler works... yes\nchecking for C compiler default output file name... a.out\nchecking for suffix of executables...\nchecking whether we are cross compiling... no\nchecking for suffix of object files... o\nchecking whether the compiler supports GNU C... yes\nchecking whether gcc accepts -g... yes\nchecking for gcc option to enable C11 features... none needed\nchecking for g++... g++\nchecking whether the compiler supports GNU C++... yes\nchecking whether g++ accepts -g... yes\nchecking for g++ option to enable C++11 features... none needed\nchecking for C11 support... yes\nchecking for C17 support... yes\nchecking for C23 support... no\nchecking for C++11 support... yes\nchecking for C++14 support... yes\nchecking for C++17 support... yes\nchecking for C++20 support... no\nchecking for C++23 support... no\nconfigure: creating ./config.status\n</code></pre>"},{"location":"C/capitulo_1/","title":"1. Introdu\u00e7\u00e3o","text":"<p>Esse cap\u00edtulo visa estabelecer conceitos importantes que envolvem a linguagem C, compiladores e programa\u00e7\u00e3o no geral.</p>"},{"location":"C/capitulo_1/#11-caracteristicas-da-linguagem-c","title":"1.1. Caracter\u00edsticas da Linguagem C","text":"<p>C \u00e9 uma linguagem de programa\u00e7\u00e3o compilada, isto \u00e9, ao escrevermos o c\u00f3digo fonte na pr\u00f3pria linguagem, no caso em C, um programa chamado compilador reescreve esse c\u00f3digo para a linguagem de m\u00e1quina. Sendo assim, o compilador tem como entrada um arquivo com c\u00f3digo fonte da linguagem e que gera como sa\u00edda um arquivo objeto, com c\u00f3digo objeto, que \u00e9 ligado a outros arquivos objeto para gerar um arquivo execut\u00e1vel. O arquivo execut\u00e1vel \u00e9 um arquivo que pode ser executado no computador alvo. Na pr\u00f3xima se\u00e7\u00e3o, ser\u00e3o dados mais detalhes sobre o processo de compila\u00e7\u00e3o de um arquivo em C. Abaixo seguem algumas caracter\u00edsticas importantes da linguagem C:</p> <ul> <li>Estruturada: A programa\u00e7\u00e3o estruturada (sucedida pela programa\u00e7\u00e3o orientada a objeto) \u00e9 um paradigma formado por tr\u00eas componentes:</li> <li>Sequ\u00eancia: Uma tarefa \u00e9 executada logo ap\u00f3s a outra;</li> <li>Decis\u00e3o: A tarefa \u00e9 executada logo ap\u00f3s um teste l\u00f3gico;</li> <li>Itera\u00e7\u00e3o: A partir de um teste l\u00f3gico, um trecho de c\u00f3digo pode ser repetido finitas vezes.</li> <li>Imperativa: Descreve a\u00e7\u00f5es/instru\u00e7\u00f5es que o programa dever\u00e1 executar. Ou seja, linguagens imperativas s\u00e3o programadas com uma sequ\u00eancia de comandos ordenada pelo programador;</li> <li>Procedural: Permite a constru\u00e7\u00e3o de procedimentos que podem ser compartimentados e reutilizados, tornando partes do c\u00f3digo mais independentes entre si;</li> <li>Padronizada: Garante que um mesmo c\u00f3digo gere sempre o mesmo resultado, seja ele compilado e executado ou interpretado;</li> <li>Fortemente Tipada: Em C, os tipos das vari\u00e1veis e fun\u00e7\u00f5es precisam ser bem definidos durante toda a execu\u00e7\u00e3o do programa. Com ponteiros do tipo <code>void</code>, \u00e9 poss\u00edvel contornar essa restri\u00e7\u00e3o, mas isso n\u00e3o \u00e9 aconselh\u00e1vel.</li> </ul> <p>Abaixo segue uma tabela com os tipos de dados b\u00e1sicos da linguagem, onde a palavra-chave \u00e9 usada para definir as vari\u00e1veis e o formato indica a forma de capturar (por meio de fun\u00e7\u00f5es como <code>scanf</code>) ou de imprimir (por exemplo, com <code>printf</code>):</p> <p>Tabela de dados b\u00e1sicos de C</p> PALAVRA-CHAVE TIPO BYTES INTERVALO FORMATO <code>char / signed char</code> Caracter 1 -128 a 127 <code>%c</code> <code>unsigned char</code> Caracter sem sinal 1 0 a 255 <code>%c</code> <code>short / short int / signed short / signed short int</code> Inteiro curto com sinal 2 -32768 a 32767 <code>%hi ou %hd</code> <code>unsigned short / unsigned short int</code> Inteiro curto sem sinal 2 0 a 65535 <code>%hu</code> <code>signed int / signed</code> Inteiro com sinal 2 -32768 a 32767 <code>%i ou %d</code> <code>unsigned / unsigned int</code> Inteiro sem sinal 2 0 a 65535 <code>%u</code> <code>long / long int / signed long / signed long int</code> Inteiro com sinal 4 -2147483648 a 2147483647 <code>%li ou %ld</code> <code>unsigned long / unsigned long int</code> Inteiro sem sinal 4 0 a 4294967295 <code>%lu</code> <code>long long / signed long long / long long int / signed long long int</code> Inteiro muito lingo com sinal 8 \u22122^+63 a 2^+63 \u22121 <code>%lli ou %lld</code> <code>unsigned long long / unsigned long long int</code> Inteiro muito lingo sem sinal 8 0 a 2^+64 \u22121 <code>%llu</code> <code>float</code> Ponto flutuante simples 4 3.4 X 10^-38 a 3.4 X 10^+38 <code>%f ou %F</code> <code>double</code> Ponto flutuante em precisao dupla 8 1.7 X 10^-308 a 1.7 X 10^+308 <code>%lf ou %lF</code> <code>long double</code> Ponto flutuante em precis\u00e3o estendida 16 3.4 X 10^-4932 a 3.4 X 10^+4932 <code>%Lf ou %LF</code> <p>Vale notar que esses tipos podem variar de m\u00e1quina para m\u00e1quina, sendo interessante imprimir os limites dos tipos presentes no cabe\u00e7alho limits.h. As padroniza\u00e7\u00f5es (como ANSI e ISO) da linguagem tamb\u00e9m podem afetar certos tipos e, consequentemente, o funcionamento do c\u00f3digo. Como C \u00e9 muito popular, diversos compiladores foram constru\u00eddos com caracter\u00edsticas distintas. As pr\u00f3ximas se\u00e7\u00f5es introduzir\u00e3o o processo de compila\u00e7\u00e3o.</p>"},{"location":"C/capitulo_1/#12-o-que-e-um-compilador","title":"1.2. O Que \u00c9 Um Compilador?","text":"<p>O compilador \u00e9 um programa de computador respons\u00e1vel por reescrever o c\u00f3digo fonte em c\u00f3digo de m\u00e1quina que poder\u00e1 ser executado. Assim, ele recebe como entrada um arquivo com o c\u00f3digo fonte e gera um arquivo execut\u00e1vel.</p> <p>Em outras palavras, o compilador traduz o c\u00f3digo fonte de uma linguagem compreens\u00edvel para os seres humanos para outra que o computador possa entender. Atualmente, o compilador possui muitas funcionalidades al\u00e9m da simples tradu\u00e7\u00e3o: ele pode agrupar instru\u00e7\u00f5es de m\u00e1quina em uma \u00fanica linha de c\u00f3digo, otimizar o c\u00f3digo, gerar arquivos intermedi\u00e1rios, tratar erros na programa\u00e7\u00e3o e oferecer ferramentas de depura\u00e7\u00e3o. Os primeiros compiladores eram focados na tradu\u00e7\u00e3o do c\u00f3digo fonte e na jun\u00e7\u00e3o das bibliotecas necess\u00e1rias para a execu\u00e7\u00e3o do c\u00f3digo objeto, num processo chamado de liga\u00e7\u00e3o. Esses compiladores iniciais foram escritos em Assembly e, com o tempo, surgiram diversas ferramentas para a constru\u00e7\u00e3o de compiladores, facilitando a cria\u00e7\u00e3o de novas linguagens.</p> <p>Com a evolu\u00e7\u00e3o das linguagens e a necessidade de novas funcionalidades, os compiladores passaram a ter caracter\u00edsticas variadas e m\u00e9todos de funcionamento diferentes. A seguir, os principais tipos de compiladores:</p> <ul> <li>Compilador Ahead-of-time: Compila o c\u00f3digo fonte antes da execu\u00e7\u00e3o do programa, gerando um arquivo objeto com instru\u00e7\u00f5es de m\u00e1quina nativas.</li> <li>Compilador Just-in-time: Compila o c\u00f3digo durante a execu\u00e7\u00e3o do programa. Na primeira execu\u00e7\u00e3o, cada linha do c\u00f3digo fonte \u00e9 traduzida para instru\u00e7\u00f5es de m\u00e1quina (ou para uma linguagem intermedi\u00e1ria) e executada imediatamente; em execu\u00e7\u00f5es subsequentes, o c\u00f3digo j\u00e1 compilado permite uma execu\u00e7\u00e3o mais r\u00e1pida.</li> <li>Compilador Cruzado: Gera um arquivo execut\u00e1vel a partir do c\u00f3digo fonte que pode ser executado em outras m\u00e1quinas, \u00fatil para sistemas embutidos ou ambientes com m\u00faltiplas arquiteturas.</li> <li>Compilador Source-to-source: Tem como sa\u00edda um c\u00f3digo fonte de alto n\u00edvel, em vez de instru\u00e7\u00f5es de m\u00e1quina. Isso possibilita a cria\u00e7\u00e3o de extens\u00f5es sint\u00e1ticas que s\u00e3o reescritas para o c\u00f3digo alvo. Um exemplo \u00e9 o TypeScript.</li> </ul> <p>Existe tamb\u00e9m o interpretador, que traduz e executa o c\u00f3digo fonte ou bytecode diretamente, sem gerar um arquivo objeto. Esse processo \u00e9 geralmente mais lento, pois cada linha precisa ser interpretada em tempo real. Por fim, programas que convertem c\u00f3digo Assembly para linguagem de m\u00e1quina e vice-versa s\u00e3o chamados de montador (assembler) e desmontador (disassembler), respectivamente. A descompila\u00e7\u00e3o, que converte c\u00f3digo de m\u00e1quina para um c\u00f3digo de alto n\u00edvel, tamb\u00e9m \u00e9 utilizada, especialmente em contextos de seguran\u00e7a.</p>"},{"location":"C/capitulo_1/#13-gnu-compiler-collection","title":"1.3. GNU Compiler Collection","text":"<p>O GNU Compiler Collection (GCC) \u00e9 uma cole\u00e7\u00e3o de compiladores Ahead-of-time do projeto GNU, criada em 1987. Ele oferece compiladores para linguagens como ADA, C++, Fortran, Java, Objective-C e Pascal, e possui compatibilidade com arquiteturas como ARM, x86 e AMD64 (x86-64). O GCC \u00e9 o compilador padr\u00e3o na maioria dos sistemas Linux, o principal compilador para o MAC OS e tamb\u00e9m pode ser utilizado no Windows por meio de ferramentas como MSYS2 e MinGW. Grande parte desses compiladores \u00e9 escrita em C, inclusive o pr\u00f3prio compilador C, num processo chamado de bootstrapping. O foco aqui ser\u00e1 o GNU C Compiler (GCC).</p> <ul> <li>Pr\u00e9-processamento: Realizado pelo pr\u00e9-processador, que trata todas as linhas que come\u00e7am com <code>#</code>. As diretivas principais nessa fase s\u00e3o <code>#include</code> (para inclus\u00e3o de arquivos de cabe\u00e7alho com defini\u00e7\u00f5es e declara\u00e7\u00f5es) e <code>#define</code> (para defini\u00e7\u00e3o de macros e constantes). Outras diretivas, como <code>#if...#else...#endif</code> e <code>#error</code>, tamb\u00e9m s\u00e3o utilizadas para controle condicional e exibi\u00e7\u00e3o de mensagens de erro.</li> <li>Compila\u00e7\u00e3o: Nesta fase, o c\u00f3digo \u00e9 traduzido para assembly em v\u00e1rios n\u00edveis:</li> <li>An\u00e1lise l\u00e9xica: Verifica se os s\u00edmbolos (vari\u00e1veis, fun\u00e7\u00f5es e palavras reservadas) est\u00e3o corretos, removendo espa\u00e7os e coment\u00e1rios. Erros como vari\u00e1veis n\u00e3o definidas ou operadores inexistentes s\u00e3o identificados aqui.</li> <li>An\u00e1lise sint\u00e1tica: Garante que as express\u00f5es seguem a gram\u00e1tica formal do C, verificando a organiza\u00e7\u00e3o correta dos s\u00edmbolos.</li> <li>An\u00e1lise sem\u00e2ntica: Valida o sentido l\u00f3gico das express\u00f5es, checando a consist\u00eancia dos tipos, regras de visibilidade e contexto.</li> <li>Otimiza\u00e7\u00e3o de alto n\u00edvel: Otimiza o c\u00f3digo, eliminando redund\u00e2ncias e trechos desnecess\u00e1rios.</li> <li>Montagem: Converte cada linha de assembly em c\u00f3digo de m\u00e1quina.</li> <li>Liga\u00e7\u00e3o: Na fase de liga\u00e7\u00e3o, as bibliotecas e todo o c\u00f3digo necess\u00e1rio para a execu\u00e7\u00e3o do programa s\u00e3o carregados e incorporados ao c\u00f3digo objeto.</li> </ul> <p>Vale ressaltar que muitas otimiza\u00e7\u00f5es ficam desabilitadas por padr\u00e3o e precisam ser ativadas por meio de flags. Ap\u00f3s esta introdu\u00e7\u00e3o aos conceitos b\u00e1sicos da linguagem C e do GCC, os pr\u00f3ximos cap\u00edtulos discutir\u00e3o as formas de utiliza\u00e7\u00e3o deste compilador e as ferramentas que ele oferece.</p>"},{"location":"C/capitulo_2/","title":"2. Compilando Programas em C","text":""},{"location":"C/capitulo_2/#21-primeiros-passos","title":"2.1. Primeiros Passos","text":"<p>Um dos primeiros programas que muitos programadores aprendem a escrever \u00e9 o famoso <code>\"Hello, World!\"</code>. A seguir, mostraremos como compilar esse programa em C utilizando o compilador GCC:</p>"},{"location":"C/capitulo_2/#helloworldc","title":"helloworld.c","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n  printf(\"Hello, World!\");\n  return 0;\n}\n</code></pre> <p>No entanto, o c\u00f3digo-fonte ainda n\u00e3o pode ser entendido pelo computador, sendo necess\u00e1rio compil\u00e1-lo para gerar um arquivo execut\u00e1vel. Para isso, usamos um compilador de C, como o GCC. No caso deste exemplo, o arquivo com o c\u00f3digo fonte se chama helloworld.c e o execut\u00e1vel, hello. A compila\u00e7\u00e3o \u00e9 feita pelo terminal:</p> <pre><code>$ gcc helloworld.c -o hello\n</code></pre> <p>O par\u00e2metro <code>-o</code> indica que queremos criar um execut\u00e1vel com o nome hello. Al\u00e9m disso, \u00e9 recomend\u00e1vel utilizar a flag <code>-Wall</code> para habilitar avisos de poss\u00edveis problemas:</p> <pre><code>$ gcc -Wall helloworld.c -o hello\n</code></pre> <p>Para executar o programa, digite:</p> <pre><code>$ ./hello\n</code></pre> <p>Se tudo ocorrer bem, a mensagem <code>Hello, World!</code> ser\u00e1 exibida no terminal.</p>"},{"location":"C/capitulo_2/#22-trabalhando-com-multiplos-arquivos","title":"2.2. Trabalhando com M\u00faltiplos Arquivos","text":"<p>Em projetos em C, \u00e9 comum dividir o c\u00f3digo em m\u00faltiplos arquivos para melhorar a organiza\u00e7\u00e3o e reduzir o tempo de compila\u00e7\u00e3o. Por exemplo, para criar um programa que calcula o quadrado de um n\u00famero, podemos usar:</p>"},{"location":"C/capitulo_2/#mainc","title":"main.c","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"quadrado.h\"\n\nint main() {\n  int x;\n  printf(\"Digite um n\u00famero: \");\n  scanf(\"%d\", &amp;x);\n  printf(\"O quadrado de %d \u00e9 %d\\n\", x, calc_quadrado(x));\n  return 0;\n}\n</code></pre>"},{"location":"C/capitulo_2/#quadradoc","title":"quadrado.c","text":"<pre><code>int calc_quadrado(int x) {\n  return x * x;\n}\n</code></pre>"},{"location":"C/capitulo_2/#quadradoh","title":"quadrado.h","text":"<pre><code>int calc_quadrado(int x);\n</code></pre> <p>Se inclu\u00edssemos diretamente quadrado.c em main.c, ter\u00edamos duas defini\u00e7\u00f5es da fun\u00e7\u00e3o <code>int calc_quadrado(int x)</code>, o que causaria um erro. Assim, usamos quadrado.h para declarar a fun\u00e7\u00e3o. Para compilar todos os arquivos de uma vez, execute:</p> <pre><code>$ gcc -Wall main.c quadrado.c -o programa\n</code></pre> <p>E para rodar o programa:</p> <pre><code>$ ./programa\n</code></pre> <p>Para evitar recompilar o programa inteiro ap\u00f3s uma altera\u00e7\u00e3o, compile cada arquivo em um objeto:</p> <pre><code>$ gcc -Wall main.c -c\n$ gcc -Wall quadrado.c -c\n</code></pre> <p>Isso gera os arquivos main.o e quadrado.o. Em seguida, ligue-os para criar o execut\u00e1vel:</p> <pre><code>$ gcc main.o quadrado.o -o programa\n</code></pre> <p>Assim, voc\u00ea pode compilar apenas os arquivos modificados e ligar os objetos pr\u00e9-compilados.</p>"},{"location":"C/capitulo_2/#23-utilizando-makefiles","title":"2.3. Utilizando Makefiles","text":"<p>Em projetos grandes com muitos arquivos, \u00e9 comum que apenas alguns precisem ser recompilados ap\u00f3s altera\u00e7\u00f5es. Para gerenciar essas depend\u00eancias, utiliza-se o <code>make</code> com um Makefile. Esse arquivo especifica como os arquivos-fonte s\u00e3o compilados e ligados para criar o programa final.</p> <p>A estrutura b\u00e1sica de um Makefile \u00e9:</p> <pre><code>alvo: dependencia\n  comando\n\ndependencia:\n  comando\n</code></pre> <p>Por exemplo, um Makefile simples para imprimir uma mensagem:</p> <pre><code>saudacao:\n    echo \"Ola, mundo!\"\n</code></pre> <p>Se o arquivo saudacao n\u00e3o existe, o comando \u00e9 executado. Para for\u00e7ar sua execu\u00e7\u00e3o, chame:</p> <pre><code>$ make saudacao\n</code></pre> <p>Um exemplo mais complexo:</p> <pre><code>hello: hello.o\n  gcc hello.o -o hello\n\nhello.o: hello.c\n  gcc -Wall hello.c -c\n</code></pre> <p>O arquivo hello.c tem o seguinte conte\u00fado:</p>"},{"location":"C/capitulo_2/#helloc","title":"hello.c","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n  printf(\"Hello, World!\\n\");\n  return 0;\n}\n</code></pre> <p>Nesse exemplo, o objetivo \u00e9 criar o execut\u00e1vel hello. Ele depende do objeto hello.o, que depende do arquivo fonte hello.c. Ao chamar <code>make</code>, o sistema:</p> <ol> <li>Verifica se hello precisa ser recompilado.</li> <li>Verifica se hello.o precisa ser recompilado.</li> <li>Executa <code>gcc -Wall hello.c -c</code> se necess\u00e1rio.</li> <li>Executa <code>gcc hello.o -o hello</code> para gerar o execut\u00e1vel.</li> </ol> <p>Usar um Makefile garante que somente os arquivos modificados sejam recompilados, otimizando o tempo de compila\u00e7\u00e3o e a gest\u00e3o das depend\u00eancias.</p>"},{"location":"C/capitulo_3/","title":"3. Bandeiras de Aviso do Compilador","text":"<p>O GCC compila programas usando o dialeto GNU da linguagem C como base, que incorpora o padr\u00e3o ANSI C e v\u00e1rias extens\u00f5es do GNU C. Essas extens\u00f5es incluem recursos como declara\u00e7\u00f5es de vari\u00e1veis no meio de um bloco de c\u00f3digo, express\u00f5es com efeitos colaterais e construtores de atributos, entre outros. No entanto, programas v\u00e1lidos escritos em ANSI C podem conflitar com algumas extens\u00f5es do GNU C.</p> <p>Para lidar com esses conflitos, o GCC oferece v\u00e1rias op\u00e7\u00f5es de linha de comando, conhecidas como bandeiras ou flags, que permitem aos desenvolvedores controlar o comportamento do compilador ao compilar o c\u00f3digo fonte. A flag <code>-ansi</code> \u00e9 usada para desabilitar as extens\u00f5es do GNU C que conflitam com o padr\u00e3o ANSI C. A flag <code>-pedantic</code> desabilita todas as extens\u00f5es do GNU C, n\u00e3o apenas aquelas que conflitam com o padr\u00e3o ANSI.</p> <p>No cap\u00edtulo anterior, usamos a flag <code>-Wall</code> na compila\u00e7\u00e3o do nosso programa. Essa flag \u00e9 uma combina\u00e7\u00e3o de v\u00e1rias flags de aviso especializadas que detectam erros comuns de programa\u00e7\u00e3o. Cada uma das flags contidas em <code>-Wall</code> pode ser usada individualmente. Algumas dessas flags s\u00e3o:</p> <ul> <li><code>-Wcomment</code>: Avisa sobre problemas de formata\u00e7\u00e3o em coment\u00e1rios, como coment\u00e1rios dentro de coment\u00e1rios.</li> <li><code>-Wformat</code>: Avisa sobre o uso incorreto de formata\u00e7\u00e3o em strings em fun\u00e7\u00f5es como <code>printf</code> e <code>scanf</code>.</li> <li><code>-Wunused</code>: Avisa sobre vari\u00e1veis que foram declaradas mas n\u00e3o foram usadas no programa.</li> <li><code>-Wimplicit</code>: Avisa sobre fun\u00e7\u00f5es que foram usadas sem serem declaradas, o que pode acontecer se esquecer de incluir o arquivo de cabe\u00e7alho.</li> <li><code>-Wreturn-type</code>: Avisa sobre fun\u00e7\u00f5es que n\u00e3o retornam nenhum valor mas que n\u00e3o foram declaradas como <code>void</code>.</li> </ul> <p>O GCC tamb\u00e9m inclui outras flags de aviso \u00fateis, como:</p> <ul> <li><code>-W</code>: Uma flag geral, semelhante a <code>-Wall</code>, que avisa sobre diversos erros comuns.</li> <li><code>-Wconversion</code>: Avisa sobre convers\u00f5es impl\u00edcitas de tipo, como entre <code>float</code> e <code>int</code>, que podem causar resultados inesperados.</li> <li><code>-Wshadow</code>: Avisa sobre a declara\u00e7\u00e3o de vari\u00e1veis em um escopo em que elas j\u00e1 foram declaradas.</li> <li><code>-Wtraditional</code>: Avisa sobre partes do c\u00f3digo que seriam interpretadas de forma diferente por um compilador ANSI/ISO e um pr\u00e9-ANSI.</li> </ul> <p>Se voc\u00ea quiser que o programa pare de compilar se houver qualquer aviso das flags que voc\u00ea aplicou, use a flag <code>-Werror</code>. Usar flags ao compilar um programa \u00e9 uma boa pr\u00e1tica, mas a grande quantidade pode tornar a escolha de quais usar dif\u00edcil. Com isso em mente, recomendamos que, em geral, as seguintes flags sejam usadas:</p> <pre><code>$ gcc -ansi -pedantic -Wall -W programa.c -o programa\n</code></pre>"},{"location":"C/capitulo_4/","title":"4. Depura\u00e7\u00e3o","text":""},{"location":"C/capitulo_4/#41-compilando-para-depuracao","title":"4.1. Compilando para Depura\u00e7\u00e3o","text":"<p>Durante o desenvolvimento de software, a depura\u00e7\u00e3o ou debugging desempenha um papel fundamental na identifica\u00e7\u00e3o e corre\u00e7\u00e3o eficiente de erros no c\u00f3digo. Ao compilar programas em C, existe uma pr\u00e1tica recomendada para facilitar a depura\u00e7\u00e3o: a utiliza\u00e7\u00e3o da op\u00e7\u00e3o <code>-g</code> ao chamar o GCC. Essa op\u00e7\u00e3o instrui o compilador a incluir informa\u00e7\u00f5es de depura\u00e7\u00e3o no execut\u00e1vel gerado. Essas informa\u00e7\u00f5es, como s\u00edmbolos de fun\u00e7\u00e3o, vari\u00e1veis locais e localiza\u00e7\u00f5es de linha, permitem uma an\u00e1lise detalhada do c\u00f3digo durante a depura\u00e7\u00e3o. Por exemplo, ao executar o programa em um depurador, \u00e9 poss\u00edvel definir pontos de interrup\u00e7\u00e3o, inspecionar valores de vari\u00e1veis e rastrear a execu\u00e7\u00e3o do c\u00f3digo passo a passo.</p> <p>Abaixo est\u00e1 um exemplo de c\u00f3digo que podemos usar para ilustrar como compilar programas em C para depura\u00e7\u00e3o:</p>"},{"location":"C/capitulo_4/#exemploc","title":"exemplo.c","text":"<pre><code>int foo (int *p);\n\nint main (void)\n{\n  int *p = 0;\n  /* ponteiro nulo */\n  return foo (p);\n}\n\nint foo (int *p)\n{\n  int y = *p;\n  return y;\n}\n</code></pre> <p>Nesse c\u00f3digo, temos duas fun\u00e7\u00f5es: <code>int main()</code> e <code>int foo()</code>. A fun\u00e7\u00e3o <code>main</code> inicializa um ponteiro <code>p</code> com o valor nulo (0) e, em seguida, chama a fun\u00e7\u00e3o <code>foo</code> passando esse ponteiro como argumento. A fun\u00e7\u00e3o <code>foo</code> recebe um ponteiro como par\u00e2metro e tenta acessar o valor apontado por ele. No entanto, como <code>p</code> \u00e9 nulo, essa opera\u00e7\u00e3o resulta em um erro. Para compilar esse c\u00f3digo com a op\u00e7\u00e3o de depura\u00e7\u00e3o, voc\u00ea pode usar o seguinte comando:</p> <pre><code>$ gcc -Wall -g exemplo.c -o exemplo\n</code></pre> <p>Ao execut\u00e1-lo, receberemos uma mensagem de erro, indicando que houve uma viola\u00e7\u00e3o de segmenta\u00e7\u00e3o, <code>segmentation fault</code>. Essa mensagem \u00e9 exibida quando ocorre uma tentativa de acessar uma \u00e1rea da mem\u00f3ria que n\u00e3o \u00e9 permitida, como no caso em que o ponteiro <code>p</code> aponta para o valor nulo.</p> <pre><code>$ ./exemplo\nsegmentation fault (core dumped)\n</code></pre> <p>Vamos falar sobre o arquivo core mencionado na mensagem de erro. Ele \u00e9 um arquivo de despejo de mem\u00f3ria que pode ser gerado quando ocorre uma falha grave em um programa e cont\u00e9m informa\u00e7\u00f5es sobre o estado da mem\u00f3ria no momento da falha, sendo \u00fatil para analisar e depurar o problema. Nem todos os sistemas geram automaticamente o core por padr\u00e3o. Se ele n\u00e3o for gerado, essa funcionalidade pode ser habilitada executando o comando abaixo, que define temporariamente o tamanho m\u00e1ximo do arquivo core como ilimitado, permitindo a gera\u00e7\u00e3o do core em caso de falha no programa:</p> <pre><code>$ ulimit -c unlimited\n</code></pre> <p>\u00c9 poss\u00edvel que, ainda assim, o arquivo core n\u00e3o seja gerado. Caso voc\u00ea utilize o Ubuntu ou algum de seus derivados, \u00e9 poss\u00edvel que ao desativar o Apport, o programa que reporta erros no Ubuntu, resolva o problema. Isso pode ser feito com o seguinte comando:</p> <pre><code>$ sudo service apport stop\n</code></pre> <p>\u00c9 importante ressaltar que, se o core n\u00e3o tiver sido gerado durante a primeira execu\u00e7\u00e3o do programa, o core ter\u00e1 que ser gerado novamente.</p>"},{"location":"C/capitulo_4/#42-depurando-programas","title":"4.2. Depurando Programas","text":"<p>Vamos agora usar o gdb para depurar o nosso execut\u00e1vel exemplo. Para isso, escrevemos o seguinte comando:</p> <pre><code>$ gdb exemplo core\n(...)\nCore was generated by './exemplo'.\nProgram terminated with signal SIGSEGV, Segmentation fault.\n\nwarning: Section '.reg-xstate/17012' in core file too small.\n#0  0x00005636c35b715b in foo (p=0x0) at exemplo.c:12\n11    int y = *p;\n(gdb)\n</code></pre> <p>O GDB aponta a linha do c\u00f3digo onde ocorreu a falha do programa. Nesse caso, o erro ocorreu quando o programa tentou desreferenciar o ponteiro <code>p</code>. Para entender melhor o motivo da falha, podemos examinar o valor de <code>p</code> com o comando <code>print</code>:</p> <pre><code>(gdb) print p\n$1 = (int *) 0x0\n</code></pre> <p>Como visto acima, o ponteiro <code>p</code> \u00e9 nulo, explicando a falha ao tentarmos desreferenci\u00e1-lo. Para investigar a sequ\u00eancia de chamadas de fun\u00e7\u00f5es que conduziu ao estado atual do programa, pode-se exibir um rastreamento de pilha com o comando <code>backtrace</code>:</p> <pre><code>(gdb) backtrace\n#0  0x000055661c11315b in foo (p=0x0) at exemplo.c:12\n#1  0x000055661c113149 in main () at exemplo.c:7\n</code></pre> <p>Outra funcionalidade importante do GDB \u00e9 a capacidade de definir pontos de interrup\u00e7\u00e3o usando o comando <code>break</code>, permitindo a parada da execu\u00e7\u00e3o do programa em pontos espec\u00edficos. Tais pontos podem ser determinados para fun\u00e7\u00f5es espec\u00edficas, linhas ou locais na mem\u00f3ria. Vamos definir um ponto de interrup\u00e7\u00e3o no in\u00edcio da fun\u00e7\u00e3o <code>main</code>:</p> <pre><code>(gdb) break main\nBreakpoint 1 at 0x55661c113135: file exemplo.c, line 5.\n</code></pre> <p>Agora, quando executarmos o programa no GDB, ele ir\u00e1 parar assim que a fun\u00e7\u00e3o <code>main</code> for executada. Poderemos, ent\u00e3o, avan\u00e7ar pela execu\u00e7\u00e3o do programa passo a passo com o comando <code>step</code>, aprimorando a observa\u00e7\u00e3o do comportamento do programa:</p> <pre><code>(gdb) run\nStarting program: exemplo\nBreakpoint 1, main () at exemplo.c:5\n5    int *p = 0;\n(gdb) step\n7    return foo(p);\n(gdb) print p\n$2 = (int *) 0x0    /* ponteiro nulo */\n(gdb)\n</code></pre> <p>As vari\u00e1veis podem ser modificadas durante a depura\u00e7\u00e3o com o comando <code>set var</code>, o que \u00e9 \u00fatil para testar diferentes cen\u00e1rios. Vamos continuar com o nosso exemplo e modificar os valores de <code>p</code> e <code>*p</code>. Por fim, ap\u00f3s modificarmos as vari\u00e1veis, retomaremos a execu\u00e7\u00e3o do programa com o comando <code>continue</code>:</p> <pre><code>(gdb) set variable p = malloc(sizeof(int))\n(gdb) print p\n$3 = (int *) 0x5555555592a0\n(gdb) set variable *p = 255\n(gdb) print *p\n$4 = 255\n(gdb) continue\nContinuing.\n[Inferior 1 (process 17673) exited with code 0377]    /* 0377 base 8 = 255 base 10 */\n(gdb)\n</code></pre> <p>Em resumo, introduzimos o processo de depura\u00e7\u00e3o de programas em C usando o depurador GNU, GDB. Abrangemos os comandos essenciais, incluindo como iniciar o GDB, definir pontos de interrup\u00e7\u00e3o, inspecionar vari\u00e1veis e alterar seus valores, bem como rastrear a sequ\u00eancia de chamadas de fun\u00e7\u00f5es, t\u00e9cnicas vitais para entender e resolver os problemas que ocorrem durante a execu\u00e7\u00e3o do seu c\u00f3digo.</p>"},{"location":"C/capitulo_5/","title":"5. Componentes do Compilador","text":""},{"location":"C/capitulo_5/#51-pre-processador","title":"5.1. Pr\u00e9-processador","text":"<p>Como dito no cap\u00edtulo inicial, o pr\u00e9-processador \u00e9 o componente do GCC respons\u00e1vel por processar e manipular o c\u00f3digo-fonte antes da compila\u00e7\u00e3o come\u00e7ar. Ele l\u00ea o c\u00f3digo-fonte e realiza um conjunto de opera\u00e7\u00f5es, incluindo substitui\u00e7\u00e3o de macros, inclus\u00e3o de arquivos e compila\u00e7\u00e3o condicional. Essas opera\u00e7\u00f5es s\u00e3o definidas por um conjunto de diretivas, que s\u00e3o comandos especiais iniciados pelo s\u00edmbolo <code>#</code>.</p>"},{"location":"C/capitulo_5/#511-inclusao-de-arquivos","title":"5.1.1. Inclus\u00e3o de Arquivos","text":"<p>A diretiva de pr\u00e9-processamento <code>#include</code> \u00e9 utilizada para incluir no c\u00f3digo o conte\u00fado de um arquivo especificado. Existem duas nota\u00e7\u00f5es: - <code>#include&lt;arquivo&gt;</code>: o pr\u00e9-processador buscar\u00e1 o arquivo em algum diret\u00f3rio do sistema (geralmente em <code>/usr/include</code>, em sistemas Unix); - <code>#include\"arquivo\"</code>: o arquivo ser\u00e1 buscado no diret\u00f3rio onde o c\u00f3digo est\u00e1 localizado.</p> <p>Geralmente, os arquivos inclu\u00eddos possuem a extens\u00e3o <code>.h</code> (de header), que s\u00e3o arquivos cabe\u00e7alhos contendo defini\u00e7\u00f5es de macros e declara\u00e7\u00f5es de prot\u00f3tipos de fun\u00e7\u00f5es padr\u00e3o do C. Por\u00e9m, \u00e9 poss\u00edvel criar arquivos de cabe\u00e7alho personalizados e adicionar outros programas em C contendo outros <code>#include</code>, que ser\u00e3o tratados de maneira recursiva pelo pr\u00e9-processador. Veja o exemplo:</p>"},{"location":"C/capitulo_5/#mainc","title":"main.c","text":"<pre><code>#include \"preproc.c\"\n\nint main(){\n  say_hello();\n\n  puts(\"Digite um n\u00famero para obter sua raiz quadrada:\");\n  scanf(\"%lf\", &amp;y);\n  raiz = raiz_quadrada(y);\n  printf(\"O valor da raiz quadrada desse n\u00famero \u00e9: %lf\\n\", raiz);\n  return 0;\n}\n</code></pre>"},{"location":"C/capitulo_5/#preprocc","title":"preproc.c","text":"<pre><code>#pragma once\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n\ndouble y, raiz;\n\nvoid say_hello(){\n  puts(\"Hello!\");\n}\n\ndouble raiz_quadrada(double x){\n  return sqrt(x);\n}\n</code></pre> <p>Ao compilar o programa main.c, o pr\u00e9-processador acoplar\u00e1 o c\u00f3digo de preproc.c. Note que foi necess\u00e1rio utilizar apenas o <code>#include \"preproc.c\"</code> no arquivo principal, pois esse arquivo j\u00e1 cont\u00e9m as diretivas necess\u00e1rias para a execu\u00e7\u00e3o do c\u00f3digo. Caso ocorram m\u00faltiplos <code>#include</code> acidentais, a diretiva <code>#pragma once</code> garante que o respectivo arquivo seja lido apenas uma vez durante o processo de compila\u00e7\u00e3o. Para gerar um arquivo com o c\u00f3digo pr\u00e9-processado, utilize:</p> <pre><code>$ gcc main.c -E -o main_preproc.c\n</code></pre> <p>No final do arquivo gerado, estar\u00e1 o c\u00f3digo dos dois arquivos (preproc.c e main.c).</p>"},{"location":"C/capitulo_5/#512-definicao-de-macros","title":"5.1.2. Defini\u00e7\u00e3o de Macros","text":"<p>Uma macro \u00e9 um peda\u00e7o de c\u00f3digo ao qual se atribui um nome, definida pela diretiva <code>#define</code>. Essa diretiva permite que voc\u00ea atribua um nome a um valor, uma express\u00e3o ou at\u00e9 mesmo a um bloco de c\u00f3digo, facilitando a reutiliza\u00e7\u00e3o sem precisar repetir o c\u00f3digo. Veja o exemplo:</p>"},{"location":"C/capitulo_5/#mainc_1","title":"main.c","text":"<pre><code>#include &lt;stdio.h&gt;\n\n#define SQUARE(x) ((x) * (x))\n#define NUM 10\n\nint main()\n{\n  printf(\"The value of NUM is: %d\\n\", NUM);\n  printf(\"The value of SQUARE(NUM) is: %d\\n\", SQUARE(NUM));\n  return 0;\n}\n</code></pre> <p>O pr\u00e9-processador substitui as ocorr\u00eancias das macros pelo seu conte\u00fado correspondente. Note que, como as macros n\u00e3o possuem escopo ou tipo expl\u00edcito, elas realizam substitui\u00e7\u00f5es simples. No exemplo, a macro <code>NUM</code> \u00e9 interpretada como um inteiro (10) em tempo de compila\u00e7\u00e3o e <code>SQUARE(NUM)</code> executa a multiplica\u00e7\u00e3o. Ao compilar e executar, a sa\u00edda ser\u00e1:</p> <pre><code>The value of NUM is: 10\nThe value of SQUARE(NUM) is: 100\n</code></pre>"},{"location":"C/capitulo_5/#513-compilacao-condicional","title":"5.1.3. Compila\u00e7\u00e3o Condicional","text":"<p>A compila\u00e7\u00e3o condicional permite que se execute uma parte do programa somente se uma certa macro estiver definida. Para isso, utilizamos as diretivas <code>#ifdef</code> e <code>#endif</code>. Por exemplo:</p>"},{"location":"C/capitulo_5/#mainc_2","title":"main.c","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main()\n{\n#ifdef NUM\n  printf(\"The value of NUM is: %d\\n\", NUM);\n#else\n  #error \"A macro NUM n\u00e3o foi definida!\";\n#endif\n  return 0;\n}\n</code></pre> <p>Neste caso, se a macro <code>NUM</code> n\u00e3o estiver definida, a mensagem de erro <code>\"A macro NUM n\u00e3o foi definida!\"</code> ser\u00e1 exibida e a compila\u00e7\u00e3o ser\u00e1 interrompida. Entretanto, podemos definir a macro ao compilar o programa com a op\u00e7\u00e3o <code>-D</code>. Por exemplo:</p> <pre><code>$ gcc -Wall -DNUM=5 main.c -o main\n$ ./main\nThe value of NUM is: 5\n</code></pre> <p>As defini\u00e7\u00f5es de macros passadas na linha de comando possuem maior preced\u00eancia, ou seja, s\u00e3o consideradas antes das defini\u00e7\u00f5es presentes no c\u00f3digo fonte. Um c\u00f3digo similar pode ser feito usando <code>#ifndef</code> e <code>#undef</code>, como no exemplo a seguir:</p>"},{"location":"C/capitulo_5/#mainc_3","title":"main.c","text":"<pre><code>#include &lt;stdio.h&gt;\n#undef NUM\n\nint main(){\n#ifndef NUM\n  #error \"A macro NUM n\u00e3o foi definida!\";\n#else\n  printf(\"The value of NUM is: %d\\n\", NUM);\n#endif\n  return 0;\n}\n</code></pre> <p>Tamb\u00e9m \u00e9 poss\u00edvel utilizar a diretiva <code>#elif</code> em conjunto com <code>#ifdef</code> para simplificar o c\u00f3digo. Por exemplo, se somente a macro <code>Z</code> estiver definida:</p>"},{"location":"C/capitulo_5/#mainc_4","title":"main.c","text":"<pre><code>#include &lt;stdio.h&gt;\n//#define X 'x'\n//#define Y 'y'\n#define Z 'z'\nint main(){\n#ifdef X\n  printf(\"The value of X is: %c\\n\", X);\n#elif defined(Y)\n  printf(\"The value of Y is: %c\\n\", Y);\n#elif defined(Z)\n  printf(\"The value of Z is: %c\\n\", Z);\n#endif\n  return 0;\n}\n</code></pre>"},{"location":"C/capitulo_5/#514-fornecendo-instrucoes","title":"5.1.4. Fornecendo Instru\u00e7\u00f5es","text":"<p>A diretiva <code>#pragma</code> \u00e9 utilizada para fornecer instru\u00e7\u00f5es ao compilador. Essa diretiva n\u00e3o faz parte do padr\u00e3o C e pode variar de acordo com o compilador e a plataforma. Ela \u00e9 utilizada, por exemplo, para for\u00e7ar que uma fun\u00e7\u00e3o seja inline:</p>"},{"location":"C/capitulo_5/#exemplo","title":"Exemplo","text":"<pre><code>#pragma inline\nint add(int a, int b){\n  return a + b;\n}\n</code></pre> <p>Nesse caso, a fun\u00e7\u00e3o <code>add</code> ser\u00e1 substitu\u00edda diretamente em sua chamada, evitando uma chamada de rotina. Tamb\u00e9m \u00e9 poss\u00edvel controlar quais trechos do c\u00f3digo ser\u00e3o otimizados:</p>"},{"location":"C/capitulo_5/#exemplo_1","title":"Exemplo","text":"<pre><code>#pragma optimize(\"\", off) // Desliga a otimiza\u00e7\u00e3o\nint add(int a, int b){\n  return a + b;\n}\n#pragma optimize(\"\", on) // Liga a otimiza\u00e7\u00e3o novamente\n</code></pre> <p>Al\u00e9m disso, <code>#pragma</code> pode ser utilizada para determinar o alinhamento de estruturas de dados em mem\u00f3ria. No exemplo abaixo, for\u00e7amos o alinhamento m\u00ednimo para a estrutura <code>s2</code>:</p>"},{"location":"C/capitulo_5/#mainc_5","title":"main.c","text":"<pre><code>#include &lt;stdio.h&gt;\n\nstruct{\n  char c;  // 1 byte\n  int i;   // 4 bytes\n  double d; // 8 bytes\n}s1;\n#pragma pack(push, 1) // For\u00e7a o alinhamento m\u00ednimo\nstruct{\n  char c;  // 1 byte\n  int i;   // 4 bytes\n  double d; // 8 bytes\n}s2;\n#pragma pack(pop) // Restaura o alinhamento padr\u00e3o\n\nint main(){\n  printf(\"The size of struct 1 is: %ld\\n\", sizeof(s1));\n  printf(\"The size of struct 2 is: %ld\\n\", sizeof(s2));\n  return 0;\n}\n</code></pre> <p>Ao compilar e executar o c\u00f3digo:</p> <pre><code>$ gcc -Wall main.c -o main\n$ ./main\nThe size of struct 1 is: 16\nThe size of struct 2 is: 13\n</code></pre> <p>\u00c9 poss\u00edvel ver que a primeira estrutura consome 3 bytes a mais, pois h\u00e1 preenchimento entre as vari\u00e1veis <code>char</code> e <code>int</code> para garantir o alinhamento adequado (por exemplo, para que o <code>int</code> esteja alinhado a um endere\u00e7o m\u00faltiplo de 4 e o <code>double</code> a um m\u00faltiplo de 8).</p>"},{"location":"C/capitulo_5/#52-compilador","title":"5.2. Compilador","text":"<p>Falar sobre \u00c1rvore de Deriva\u00e7\u00e3o, resumir o processo de compila\u00e7\u00e3o e t\u00e9cnicas, comentar sobre otimiza\u00e7\u00e3o (otimiza\u00e7\u00e3o j\u00e1 foi falada no cap\u00edtulo seguinte, ent\u00e3o \u00e9 s\u00f3 comentar informa\u00e7\u00f5es relevantes)...</p>"},{"location":"C/capitulo_5/#53-montador","title":"5.3. Montador","text":"<p>O montador \u00e9 o componente respons\u00e1vel por traduzir um c\u00f3digo de montagem em c\u00f3digo de m\u00e1quina, conforme mencionado na introdu\u00e7\u00e3o. Al\u00e9m disso, ele lida com s\u00edmbolos, diretivas de montagem e dados, organizando-os de forma execut\u00e1vel. Como o GCC \u00e9 compat\u00edvel com diversas arquiteturas, ele suporta diretivas espec\u00edficas que tratam de alinhamento dos dados, defini\u00e7\u00e3o de constantes e strings, determina\u00e7\u00e3o de se\u00e7\u00f5es de c\u00f3digo, dados e endere\u00e7os de mem\u00f3ria onde as instru\u00e7\u00f5es e/ou os dados ser\u00e3o posicionados, entre outras fun\u00e7\u00f5es. Durante a montagem, o GCC resolve endere\u00e7os, offsets (deslocamentos), alinha dados, manipula macros e gera a tabela de s\u00edmbolos e de realoca\u00e7\u00e3o. Para ilustrar, considere o seguinte exemplo de c\u00f3digo em C:</p>"},{"location":"C/capitulo_5/#mainc_6","title":"main.c","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n  printf(\"Ol\u00e1, mundo!\\n\");\n  return 0;\n}\n</code></pre> <p>Ao compilar esse programa com o GCC, o compilador gera um c\u00f3digo intermedi\u00e1rio que \u00e9 convertido em c\u00f3digo de montagem. Esse arquivo de montagem pode ser gerado explicitamente com:</p> <pre><code>gcc -S hello_world.c\n</code></pre> <p>Isso criar\u00e1 um arquivo chamado hello_world.s. Para compilar esse arquivo de montagem e gerar um objeto, utilize:</p> <pre><code>gcc -c hello_world.s -o hello_world.o\n</code></pre> <p>Continuar...</p>"},{"location":"C/capitulo_5/#54-ligador","title":"5.4. Ligador","text":"<p>O ligador \u00e9 o componente que atua na fase final da compila\u00e7\u00e3o. Ele combina os arquivos-objeto gerados, resolve s\u00edmbolos definidos em outros arquivos-fonte e incorpora bibliotecas ao c\u00f3digo para gerar o arquivo execut\u00e1vel final. Enquanto na fase anterior os endere\u00e7os dos dados e c\u00f3digos s\u00e3o tratados de forma relativa, nesta etapa esses endere\u00e7os s\u00e3o ajustados para refletir suas posi\u00e7\u00f5es reais na mem\u00f3ria.</p> <p>Continuar...</p>"},{"location":"C/capitulo_6/","title":"6. Compilando com Otimiza\u00e7\u00e3o","text":"<p>O GCC \u00e9 um compilador otimizador que pode gerar arquivos execut\u00e1veis mais r\u00e1pidos e/ou menores, levando em considera\u00e7\u00e3o as caracter\u00edsticas do processador alvo e a ordem das instru\u00e7\u00f5es. A otimiza\u00e7\u00e3o \u00e9 um processo complexo que envolve a escolha da melhor combina\u00e7\u00e3o de instru\u00e7\u00f5es de m\u00e1quina para cada comando de alto n\u00edvel no c\u00f3digo-fonte. Diferentes c\u00f3digos devem ser gerados para processadores distintos, devido ao uso de linguagens de montagem e m\u00e1quina incompat\u00edveis. Al\u00e9m disso, cada tipo de processador possui caracter\u00edsticas pr\u00f3prias, como o n\u00famero de registradores dispon\u00edveis, que afetam a forma como o c\u00f3digo \u00e9 gerado. Ao compilar com otimiza\u00e7\u00e3o, o GCC leva em considera\u00e7\u00e3o todos esses fatores.</p>"},{"location":"C/capitulo_6/#61-otimizacao-em-nivel-de-codigo-fonte","title":"6.1. Otimiza\u00e7\u00e3o em N\u00edvel de C\u00f3digo-fonte","text":"<p>A otimiza\u00e7\u00e3o em n\u00edvel de c\u00f3digo-fonte melhora o desempenho de um programa por meio de altera\u00e7\u00f5es no c\u00f3digo-fonte. Duas otimiza\u00e7\u00f5es comuns s\u00e3o a elimina\u00e7\u00e3o de subexpress\u00f5es repetidas e o inline de fun\u00e7\u00f5es.</p>"},{"location":"C/capitulo_6/#611-eliminacao-de-subexpressoes-comuns","title":"6.1.1. Elimina\u00e7\u00e3o de Subexpress\u00f5es Comuns","text":"<p>A elimina\u00e7\u00e3o de subexpress\u00f5es repetidas evita a reavalia\u00e7\u00e3o de uma mesma express\u00e3o v\u00e1rias vezes. Por exemplo, a express\u00e3o</p> <pre><code>x = cos(v).(1+sin(u/2)) + sin(w).(1-sin(u/2))\n</code></pre> <p>pode ser reescrita como</p> <pre><code>t = sin(u/2); x = cos(v).(1+t) + sin(w).(1-t)\n</code></pre> <p>evitando a avalia\u00e7\u00e3o duplicada de <code>sin(u/2)</code>.</p>"},{"location":"C/capitulo_6/#612-inclusao-de-funcao","title":"6.1.2. Inclus\u00e3o de Fun\u00e7\u00e3o","text":"<p>O inline de fun\u00e7\u00f5es substitui uma chamada de fun\u00e7\u00e3o pelo seu pr\u00f3prio corpo, reduzindo a sobrecarga das chamadas de fun\u00e7\u00e3o. Por exemplo, a fun\u00e7\u00e3o <code>sq(x)</code> pode ser inlineada no loop:</p> <pre><code>for (i = 0; i &lt; 1000000; i++)\n  sum += sq(i + 0.5);\n</code></pre> <p>Isso substitui o loop interno pelo corpo da fun\u00e7\u00e3o <code>sq(x)</code>, melhorando o desempenho ao evitar chamadas de fun\u00e7\u00e3o.</p>"},{"location":"C/capitulo_6/#613-trade-offs-de-velocidade-e-espaco","title":"6.1.3. Trade-offs de Velocidade e Espa\u00e7o","text":"<p>Algumas formas de otimiza\u00e7\u00e3o podem aumentar a velocidade e reduzir o tamanho do programa simultaneamente, enquanto outras produzem c\u00f3digo mais r\u00e1pido em troca de um execut\u00e1vel maior. Esse \u00e9 o chamado trade-off de velocidade e espa\u00e7o. Tais otimiza\u00e7\u00f5es podem, inclusive, ser aplicadas de forma inversa, diminuindo o tamanho do execut\u00e1vel em detrimento da velocidade de execu\u00e7\u00e3o.</p>"},{"location":"C/capitulo_6/#614-desenrolamento-de-loops","title":"6.1.4. Desenrolamento de Loops","text":"<p>O desenrolamento de loops \u00e9 uma otimiza\u00e7\u00e3o que aumenta a velocidade dos loops eliminando a condi\u00e7\u00e3o de \"fim do loop\" em cada itera\u00e7\u00e3o. Ele permite atribui\u00e7\u00f5es diretas, sem a necessidade de testes, resultando em uma execu\u00e7\u00e3o mais r\u00e1pida. Contudo, o desenrolamento pode aumentar o tamanho do execut\u00e1vel, exceto em loops muito curtos.</p>"},{"location":"C/capitulo_6/#615-agendamento","title":"6.1.5. Agendamento","text":"<p>O agendamento \u00e9 o n\u00edvel mais baixo de otimiza\u00e7\u00e3o, onde o compilador determina a melhor ordem de execu\u00e7\u00e3o das instru\u00e7\u00f5es individuais. Essa t\u00e9cnica melhora a velocidade do execut\u00e1vel sem aumentar seu tamanho, mas exige mem\u00f3ria adicional e tempo durante o processo de compila\u00e7\u00e3o.</p>"},{"location":"C/capitulo_6/#62-niveis-de-otimizacao-no-gcc","title":"6.2. N\u00edveis de Otimiza\u00e7\u00e3o no GCC","text":"<p>O GCC oferece diferentes n\u00edveis de otimiza\u00e7\u00e3o (0 a 3) para controlar o tempo de compila\u00e7\u00e3o, o uso de mem\u00f3ria do compilador e o trade-off entre velocidade e espa\u00e7o no execut\u00e1vel resultante. Os n\u00edveis de otimiza\u00e7\u00e3o s\u00e3o:</p> <ul> <li><code>-O0</code> (padr\u00e3o): Sem otimiza\u00e7\u00e3o, compilando de forma direta para facilitar a depura\u00e7\u00e3o.</li> <li><code>-O1</code>: Otimiza\u00e7\u00f5es comuns sem trade-offs significativos de velocidade e espa\u00e7o.</li> <li><code>-O2</code>: Otimiza\u00e7\u00f5es adicionais sem aumentar o tamanho do execut\u00e1vel.</li> <li><code>-O3</code>: Otimiza\u00e7\u00f5es mais custosas que podem aumentar o tamanho do execut\u00e1vel.</li> <li><code>-funroll-loops</code>: Desenrolamento de loops, aumentando o tamanho do execut\u00e1vel.</li> <li><code>-Os</code>: Otimiza\u00e7\u00f5es para reduzir o tamanho do execut\u00e1vel.</li> </ul> <p>\u00c9 importante considerar os custos das otimiza\u00e7\u00f5es, como maior complexidade na depura\u00e7\u00e3o e maior tempo/mem\u00f3ria de compila\u00e7\u00e3o. Geralmente, <code>-O0</code> \u00e9 usado para depura\u00e7\u00e3o e <code>-O2</code> para desenvolvimento e implanta\u00e7\u00e3o.</p>"},{"location":"C/capitulo_6/#63-otimizacao-e-depuracao","title":"6.3. Otimiza\u00e7\u00e3o e Depura\u00e7\u00e3o","text":"<p>Com o GCC, \u00e9 poss\u00edvel usar otimiza\u00e7\u00e3o em combina\u00e7\u00e3o com a op\u00e7\u00e3o de depura\u00e7\u00e3o <code>-g</code>. Muitos compiladores n\u00e3o permitem essa combina\u00e7\u00e3o. Ao usar depura\u00e7\u00e3o e otimiza\u00e7\u00e3o juntas, as reorganiza\u00e7\u00f5es internas feitas pelo otimizador podem dificultar a compreens\u00e3o do que est\u00e1 acontecendo ao examinar um programa otimizado no depurador. Por exemplo, vari\u00e1veis tempor\u00e1rias geralmente s\u00e3o eliminadas e a ordem das instru\u00e7\u00f5es pode ser alterada. No entanto, quando um programa trava inesperadamente, qualquer informa\u00e7\u00e3o de depura\u00e7\u00e3o \u00e9 melhor do que nenhuma, portanto, o uso de <code>-g</code> \u00e9 recomendado tanto para desenvolvimento quanto para implanta\u00e7\u00e3o. Nas vers\u00f5es dos pacotes GNU, a op\u00e7\u00e3o de depura\u00e7\u00e3o <code>-g</code> \u00e9 habilitada por padr\u00e3o juntamente com a op\u00e7\u00e3o de otimiza\u00e7\u00e3o <code>-O2</code>.</p>"},{"location":"C/capitulo_6/#64-otimizacao-e-avisos-do-compilador","title":"6.4. Otimiza\u00e7\u00e3o e Avisos do Compilador","text":"<p>Quando a otimiza\u00e7\u00e3o \u00e9 ativada, o GCC pode produzir avisos adicionais que n\u00e3o aparecem ao compilar sem otimiza\u00e7\u00e3o. Durante a otimiza\u00e7\u00e3o, o compilador realiza uma an\u00e1lise de fluxo de dados, examinando o uso de todas as vari\u00e1veis e seus valores iniciais. Essa an\u00e1lise \u00e9 a base para outras estrat\u00e9gias de otimiza\u00e7\u00e3o, como o agendamento de instru\u00e7\u00f5es, e pode detectar o uso de vari\u00e1veis n\u00e3o inicializadas.</p> <p>A op\u00e7\u00e3o <code>-Wuninitialized</code> (inclu\u00edda em <code>-Wall</code>) avisa sobre vari\u00e1veis que s\u00e3o lidas sem serem inicializadas. Ela s\u00f3 funciona quando o programa \u00e9 compilado com otimiza\u00e7\u00e3o, pois \u00e9 necess\u00e1rio que a an\u00e1lise de fluxo de dados esteja ativa. Considere o seguinte exemplo:</p>"},{"location":"C/capitulo_6/#exemplo","title":"Exemplo","text":"<pre><code>int sign(int x)\n{\n  int s;\n  if (x &gt; 0)\n    s = 1;\n  else if (x &lt; 0)\n    s = -1;\n  return s;\n}\n</code></pre> <p>A fun\u00e7\u00e3o funciona corretamente para a maioria dos argumentos, mas tem um bug quando <code>x</code> \u00e9 zero \u2013 nesse caso, o valor de retorno da vari\u00e1vel <code>s</code> ser\u00e1 indefinido. Compilar o programa apenas com a op\u00e7\u00e3o <code>-Wall</code> n\u00e3o produz nenhum aviso, porque a an\u00e1lise de fluxo de dados n\u00e3o \u00e9 realizada sem otimiza\u00e7\u00e3o:</p> <pre><code>$ gcc -Wall -c uninit.c\n</code></pre> <p>Para gerar um aviso, o programa deve ser compilado com <code>-Wall</code> e otimiza\u00e7\u00e3o simultaneamente. Na pr\u00e1tica, o n\u00edvel de otimiza\u00e7\u00e3o <code>-O2</code> \u00e9 recomendado para obter bons avisos:</p> <pre><code>$ gcc -Wall -O2 -c uninit.c\n</code></pre> <p>Isso detecta corretamente a possibilidade de a vari\u00e1vel <code>s</code> ser usada sem ser definida. Embora o GCC geralmente encontre a maioria das vari\u00e1veis n\u00e3o inicializadas, ele utiliza heur\u00edsticas que podem, ocasionalmente, deixar passar casos complicados ou emitir falsos avisos. Nesses casos, pode ser \u00fatil reescrever as partes relevantes do c\u00f3digo para melhorar a legibilidade e eliminar o aviso.</p>"},{"location":"C/gloss%C3%A1rio/","title":"Gloss\u00e1rio","text":"<ul> <li>Arquivo Execut\u00e1vel: \u00c9 um arquivo, interpretado pelo sistema operacional como um programa, que cont\u00e9m instru\u00e7\u00f5es do processador em quest\u00e3o, geralmente representadas em bin\u00e1rio, para a execu\u00e7\u00e3o de tarefas no computador.</li> <li>Arquivo Objeto: Arquivo resultante da compila\u00e7\u00e3o de um c\u00f3digo fonte. Possui v\u00e1rios formatos, como o ELF (Executable and Linking Format) do padr\u00e3o Unix. Al\u00e9m de c\u00f3digo objeto, \u00e9 composto por um cabe\u00e7alho com informa\u00e7\u00f5es de debug, aloca\u00e7\u00e3o de mem\u00f3ria e s\u00edmbolos (nome de vari\u00e1veis e de fun\u00e7\u00f5es). Podem ser ligados a outros arquivos objetos para formar um arquivo execut\u00e1vel ou arquivo de biblioteca.</li> <li>Assembly: Nota\u00e7\u00e3o leg\u00edvel para o ser humano do c\u00f3digo de m\u00e1quina, isto \u00e9, um apelido que representa uma instru\u00e7\u00e3o de m\u00e1quina, mais f\u00e1cil de ser entendido do que uma sequ\u00eancia bin\u00e1ria.</li> <li>Bootstrapping: Processo pelo qual o compilador de uma linguagem \u00e9 escrito na pr\u00f3pria linguagem. Geralmente, o compilador inicial \u00e9 feito em uma linguagem de baixo n\u00edvel e, depois, \u00e9 reescrito na pr\u00f3pria linguagem em alto n\u00edvel.</li> <li>Bytecode: C\u00f3digo intermedi\u00e1rio gerado pelo interpretador e que ser\u00e1 executado diretamente em uma m\u00e1quina virtual.</li> <li>C\u00f3digo Fonte: \u00c9 um arquivo que cont\u00e9m as instru\u00e7\u00f5es escritas pelo programador, interpretado pelo sistema operacional como um programa, e que ser\u00e1 transformado em c\u00f3digo execut\u00e1vel.</li> <li>C\u00f3digo Objeto: C\u00f3digo escrito em linguagem de m\u00e1quina (bin\u00e1ria) ou em uma linguagem intermedi\u00e1ria que pode ser interpretada e executada pelo computador.</li> <li>Linguagem de Programa\u00e7\u00e3o: Estrutura contendo regras sem\u00e2nticas e sint\u00e1ticas expressas atrav\u00e9s de um c\u00f3digo fonte, que pode ser transformado em um programa de computador por meio da compila\u00e7\u00e3o ou ser interpretado para execu\u00e7\u00e3o.</li> </ul>"},{"location":"C%2B%2B/1_introducao/","title":"Introdu\u00e7\u00e3o","text":"<p>Primeiro encontro com o b\u00e1sico de alguns conceitos de programa\u00e7\u00e3o.</p>"},{"location":"C%2B%2B/1_introducao/#programa-de-computador","title":"Programa de computador","text":"<p>Um programa de computador \u00e9 uma sequ\u00eancia de instru\u00e7\u00f5es que descreve tarefas a serem executadas por um computador. Uma receita de bolo est\u00e1 para um confeiteiro como um programa est\u00e1 para um computador.</p>"},{"location":"C%2B%2B/1_introducao/#linguagem-de-programacao","title":"Linguagem de programa\u00e7\u00e3o","text":"<p>Para escrever programas, utiliza-se linguagens especializadas em escrever instru\u00e7\u00f5es para computadores: as linguagens de programa\u00e7\u00e3o. Nos concentraremos na linguagem C++.</p> <p>\u00c0s instru\u00e7\u00f5es escritas em uma linguagem de programa\u00e7\u00e3o damos o nome de c\u00f3digo.</p>"},{"location":"C%2B%2B/1_introducao/#editor-de-texto","title":"Editor de texto","text":"<p>Um programa pode ser escrito em qualquer editor de texto, como Word, bloco de notas, Google Docs e WordPad, por exemplo. Por\u00e9m, existem editores de texto especializados no desenvolvimento de programas, trazendo consigo ferramentas indispens\u00e1veis.</p> <p>Desses, um editor muito comum entre programadores e simples de utilizar \u00e9 o Visual Studio Code. Segue um tutorial de como baixar e instalar o Visual Studio Code no Windows.</p>"},{"location":"C%2B%2B/1_introducao/#compiladores","title":"Compiladores","text":"<p>Apesar de utilizarmos uma linguagem de programa\u00e7\u00e3o, o computador ainda n\u00e3o consegue executar instru\u00e7\u00f5es. Um computador entende apenas instru\u00e7\u00f5es em linguagem de m\u00e1quina, codificadas apenas com sequ\u00eancias de caracteres 0 e 1. Este \u00e9 o \u00fanico formato em que um computador \u00e9 capaz de executar uma instru\u00e7\u00e3o.</p> <p>A compila\u00e7\u00e3o \u00e9 o processo de transformar instru\u00e7\u00f5es em uma linguagem de programa\u00e7\u00e3o em um arquivo execut\u00e1vel com instru\u00e7\u00f5es em linguagem de m\u00e1quina.</p> <p>Um compilador \u00e9 um programa capaz de compilar um programa. O compilador de C++ que usaremos \u00e9 o G++. Segue um tutorial de como baixar e instalar o G++ no Windows.</p>"},{"location":"C%2B%2B/1_introducao/#hello-world","title":"Hello World","text":"<p>Come\u00e7aremos analisando um programa simples que apenas exibe a frase \"Hello World!\" na tela:</p> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main() {\n    cout &lt;&lt; \"Hello World!\" &lt;&lt; endl;\n}\n````\n\nEle estar\u00e1 no arquivo `hello-world.cpp`. Arquivos em C++ t\u00eam a extens\u00e3o `.cpp`.\n\n### Fun\u00e7\u00e3o `main`\n\nPrimeiramente, analisemos:\n\n```cpp\nint main() {\n\n}\n</code></pre> <p>Esta se\u00e7\u00e3o do programa \u00e9 a fun\u00e7\u00e3o <code>main</code>. Todo programa em C++ tem uma <code>main</code>; ela \u00e9 o ponto de partida de sua execu\u00e7\u00e3o. Em outras palavras: ao executar um programa, os comandos entre as chaves da <code>main</code> passam a ser executados sequencialmente, de cima para baixo.</p>"},{"location":"C%2B%2B/1_introducao/#comando-cout","title":"Comando <code>cout</code>","text":"<p>Agora, vejamos o comando</p> <pre><code>cout &lt;&lt; \"Hello World!\" &lt;&lt; endl;\n</code></pre> <p>O comando <code>cout</code>, acr\u00f4nimo para \"character output\" (sa\u00edda de caracteres), exibe caracteres na tela. Os caracteres a serem exibidos s\u00e3o passados para o comando atrav\u00e9s do operador <code>&lt;&lt;</code>. Pode-se pensar que a informa\u00e7\u00e3o segue o fluxo das setas.</p> <p>O texto \"Hello World!\" \u00e9 passado para o comando e, logo ap\u00f3s, \u00e9 passado o <code>endl</code>. O <code>endl</code> pula uma linha no texto sendo exibido. Caso mais caracteres fossem exibidos ap\u00f3s ele, apareceriam na linha abaixo. Para \"Hello\" e \"World\" estarem em linhas diferentes, por exemplo, uma op\u00e7\u00e3o \u00e9:</p> <pre><code>cout &lt;&lt; \"Hello\" &lt;&lt; endl &lt;&lt; \"World!\" &lt;&lt; endl;\n</code></pre> <p>Que pode ser separado em dois comandos com o mesmo efeito:</p> <pre><code>cout &lt;&lt; \"Hello\" &lt;&lt; endl;\ncout &lt;&lt; \"World!\" &lt;&lt; endl;\n</code></pre> <p>Em C++, a grande maioria dos comandos termina em <code>;</code>, assim como acima. Esquecer um <code>;</code> ao fim de um comando \u00e9 um erro comum.</p>"},{"location":"C%2B%2B/1_introducao/#diretivas","title":"Diretivas","text":"<p>Os comandos</p> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n</code></pre> <p>s\u00e3o diretivas. Uma diretiva \u00e9 um comando que \u00e9 executado em tempo de compila\u00e7\u00e3o, alterando o comportamento da compila\u00e7\u00e3o.</p>"},{"location":"C%2B%2B/1_introducao/#diretiva-include","title":"Diretiva <code>#include</code>","text":"<p>A diretiva <code>#include</code> faz com que o compilador inclua, no lugar do comando, um c\u00f3digo em outro lugar do computador, especificado logo ap\u00f3s a diretiva. Este c\u00f3digo pode ser um c\u00f3digo seu ou uma biblioteca: uma cole\u00e7\u00e3o de c\u00f3digo contendo funcionalidades que podem ser utilizadas no programa atual.</p> <p>No programa Hello World inclu\u00edmos a biblioteca <code>&lt;iostream&gt;</code>, que cont\u00e9m o comando <code>cout</code>. Essa biblioteca faz parte da biblioteca padr\u00e3o do C++.</p> <p>Pode-se at\u00e9 incluir a biblioteca padr\u00e3o inteira com o comando</p> <pre><code>#include &lt;bits/stdc++.h&gt;\n</code></pre> <p>Por\u00e9m, por tornar os arquivos muito grandes ao incluir c\u00f3digo demais, isso n\u00e3o \u00e9 uma boa pr\u00e1tica de programa\u00e7\u00e3o.</p>"},{"location":"C%2B%2B/1_introducao/#diretiva-using-namespace","title":"Diretiva <code>using namespace</code>","text":"<p>A diretiva <code>using namespace</code> nos permite n\u00e3o especificar o espa\u00e7o de nomes dos comandos abaixo da diretiva.</p> <p>Um espa\u00e7o de nomes \u00e9 an\u00e1logo ao sobrenome do comando, criado para n\u00e3o haver ambiguidade entre comandos de duas bibliotecas diferentes com mesmo nome. <code>std</code> \u00e9 o espa\u00e7o de nomes da biblioteca padr\u00e3o do C++. Caso a diretiva n\u00e3o fosse utilizada, o espa\u00e7o de nomes do <code>cout</code> deveria ser especificado com <code>::</code>:</p> <pre><code>#include &lt;iostream&gt;\n\nint main() {\n    std::cout &lt;&lt; \"Hello World!\" &lt;&lt; std::endl;\n}\n</code></pre> <p>O compilador n\u00e3o reconhece um comando da <code>std</code> sem seu espa\u00e7o de nomes ser identificado, seja pela diretiva <code>using namespace</code> ou pelo prefixo <code>std::</code>. A compila\u00e7\u00e3o falhar\u00e1 caso um comando n\u00e3o seja reconhecido.</p>"},{"location":"C%2B%2B/1_introducao/#indentacao","title":"Indenta\u00e7\u00e3o","text":"<p>Indenta\u00e7\u00e3o s\u00e3o espa\u00e7os em branco antes de comandos. Geralmente, s\u00e3o usados para facilitar a visualiza\u00e7\u00e3o de que um comando est\u00e1 dentro de um par de chaves, como na <code>main</code>.</p> <p>Em algumas linguagens, a indenta\u00e7\u00e3o \u00e9 obrigat\u00f3ria, fazendo parte das regras de sintaxe da linguagem. N\u00e3o \u00e9 o caso do C++, onde espa\u00e7os em branco adicionais n\u00e3o alteram o comportamento do programa. Os programas abaixo s\u00e3o todos equivalentes:</p> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main() {\n    cout &lt;&lt; \"Hello World!\" &lt;&lt; endl;\n}\n</code></pre> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main() { cout &lt;&lt; \"Hello World!\" &lt;&lt; endl; }\n</code></pre> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std; int main() { cout &lt;&lt; \"Hello World!\" &lt;&lt; endl; }\n</code></pre> <p>Note que a diretiva <code>#include</code> precisa de uma linha exclusiva\u2014ela \u00e9 uma exce\u00e7\u00e3o.</p>"},{"location":"C%2B%2B/1_introducao/#g","title":"g++","text":"<p>O g++ \u00e9 um dos compiladores de C++ mais utilizados. Seu uso b\u00e1sico no terminal ser\u00e1 observado para o arquivo <code>hello-world.cpp</code>.</p> <p>Um programa pode ser compilado atrav\u00e9s do seguinte comando:</p> <pre><code>g++ hello-world.cpp\n</code></pre> <p>Um execut\u00e1vel de nome <code>a.exe</code> (Windows) ou <code>a.out</code> (Linux e macOS) em linguagem de m\u00e1quina ser\u00e1 criado na mesma pasta. Ele pode ser executado com os comandos:</p> <p>Windows:</p> <pre><code>a.exe\n</code></pre> <p>Linux e macOS:</p> <pre><code>./a.out\n</code></pre> <p>Tamb\u00e9m \u00e9 poss\u00edvel especificar um nome personalizado para o execut\u00e1vel, basta utilizar a op\u00e7\u00e3o <code>-o</code> do compilador:</p> <pre><code>g++ hello-world.cpp -o nome-personalizado.exe\n</code></pre> <p>Um execut\u00e1vel com o nome <code>nome-personalizado.exe</code> ser\u00e1 criado.</p>"},{"location":"C%2B%2B/1_introducao/#erros-de-compilacao","title":"Erros de compila\u00e7\u00e3o","text":"<p>Caso haja algum erro na sintaxe do c\u00f3digo, isto \u00e9, se o c\u00f3digo escrito pelo programador n\u00e3o est\u00e1 de acordo com as regras da linguagem, a compila\u00e7\u00e3o falhar\u00e1 e ser\u00e1 exibido um erro de compila\u00e7\u00e3o. Segue um exemplo:</p> <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;  \n\nint main() {\n    cout &lt;&lt; \"Hello World!\" &lt;&lt; endl\n}\n</code></pre> <p>Sa\u00edda de erro:</p> <pre><code>mhjmbs@mhjmbs-ubuntu:~/Codes/examples$ g++ hello-world.cpp \nhello-world.cpp: In function \u2018int main()\u2019:\nhello-world.cpp:6:35: error: expected \u2018;\u2019 before \u2018}\u2019 token\n    6 |     cout &lt;&lt; \"Hello World!\" &lt;&lt; endl\n      |                                   ^\n      |                                   ;\n    7 | }\n      | ~\n</code></pre> <p>O erro demonstra que na linha 6, na posi\u00e7\u00e3o 35, da esquerda para a direita, est\u00e1 faltando um <code>;</code>.</p>"},{"location":"C%2B%2B/1_introducao/#comentarios","title":"Coment\u00e1rios","text":"<p>Coment\u00e1rios s\u00e3o ignorados pelo compilador e podem servir para diferentes prop\u00f3sitos dentro de um c\u00f3digo. Dentre eles, est\u00e3o:</p> <ul> <li>Auxiliar na compreens\u00e3o do c\u00f3digo por um leitor terceiro.</li> <li>Rapidamente remover parte do c\u00f3digo para fins de debugging.</li> </ul> <pre><code>// Isso \u00e9 um coment\u00e1rio de uma linha\n\n/*\nIsso \u00e9\num coment\u00e1rio\nde m\u00faltiplas linhas\n*/\n</code></pre> <p>```</p>"},{"location":"C%2B%2B/2_variaveis_e_tipos_de_dados/","title":"Vari\u00e1veis e Tipos de Dados","text":"<p>Armazenamento de informa\u00e7\u00f5es para uso do programa.</p>"},{"location":"C%2B%2B/2_variaveis_e_tipos_de_dados/#memoria","title":"Mem\u00f3ria","text":"<p>A mem\u00f3ria do computador \u00e9 uma sequ\u00eancia de bilh\u00f5es de espa\u00e7os para guardar informa\u00e7\u00e3o, cada um, necessariamente, preenchido ou com 0 ou com 1. N\u00fameros, palavras e at\u00e9 imagens podem ser armazenados apenas com sequ\u00eancias de 0's e 1's. Um valor bin\u00e1rio (0 ou 1) da mem\u00f3ria \u00e9 chamado de bit e 8 bits formam um byte.</p> Nome S\u00edmbolo Tamanho Bit b 1 bit Byte B 8b KiloByte KB 1024B MegaByte MB 1024KB GigaByte GB 1024MB TeraByte TB 1024GB <p>Uma das capacidades mais fundamentais de um programa \u00e9 reservar um espa\u00e7o da mem\u00f3ria para o programa usar.</p>"},{"location":"C%2B%2B/2_variaveis_e_tipos_de_dados/#variaveis","title":"Vari\u00e1veis","text":"<p>Uma vari\u00e1vel \u00e9 um espa\u00e7o de mem\u00f3ria que seu programa reserva e nomeia para uso.</p> <p>Em algumas linguagens, n\u00e3o \u00e9 preciso especificar o tipo de informa\u00e7\u00e3o que ser\u00e1 armazenada na vari\u00e1vel (n\u00famero, caractere, etc.). Por\u00e9m, o C++ \u00e9 uma linguagem fortemente tipada, isto \u00e9, os tipos das informa\u00e7\u00f5es armazenadas nas vari\u00e1veis devem ser conhecidos em tempo de compila\u00e7\u00e3o.</p> <p>Portanto, uma vari\u00e1vel em C++ sempre tem um tipo, um nome e um valor.</p> <p>Criar uma vari\u00e1vel \u00e9 chamado de declarar uma vari\u00e1vel, e pode ser feito com um comando da forma:</p> <pre><code>&lt;tipo&gt; &lt;nome&gt; = &lt;valor&gt;;\n</code></pre> <p>Para armazenar o n\u00famero de estados brasileiros, por exemplo, pode-se escrever:</p> <pre><code>int estados_brasileiros = 26;\n</code></pre> <p>Acima, declaramos uma vari\u00e1vel do tipo <code>int</code>, que armazena n\u00fameros inteiros, cujo nome \u00e9 <code>estados_brasileiros</code> e atribu\u00edmos um valor inicial de 26 a ela.</p> <p>Note que em momento algum temos de lidar com valores bin\u00e1rios. Os nomes e valores s\u00e3o todos traduzidos para linguagem de m\u00e1quina no momento da compila\u00e7\u00e3o. Essa \u00e9 a raz\u00e3o de exist\u00eancia das linguagens de programa\u00e7\u00e3o.</p> <p>Podemos, tamb\u00e9m, declarar m\u00faltiplas vari\u00e1veis do mesmo tipo. Seus nomes devem ser separados por v\u00edrgula, como abaixo:</p> <pre><code>int num1 = 1, num2 = 34, num3 = -50;\n</code></pre> <p>Ou como comandos separados:</p> <pre><code>int num1 = 1;\nint num2 = 34;\nint num3 = -50;\n</code></pre> <p>Os c\u00f3digos acima t\u00eam o mesmo efeito.</p>"},{"location":"C%2B%2B/2_variaveis_e_tipos_de_dados/#inicializacao","title":"Inicializa\u00e7\u00e3o","text":"<p>A inicializa\u00e7\u00e3o de uma vari\u00e1vel \u00e9 o armazenamento de um valor nela no momento de sua cria\u00e7\u00e3o.</p> <p>\u00c9 poss\u00edvel declarar uma vari\u00e1vel e n\u00e3o inicializ\u00e1-la:</p> <pre><code>int estados_brasileiros;\n</code></pre> <p>Por\u00e9m, uma vari\u00e1vel sempre cont\u00e9m um valor. O valor armazenado na vari\u00e1vel, nesse caso, \u00e9 o valor que estava naquele espa\u00e7o da mem\u00f3ria antes de sua declara\u00e7\u00e3o. Esse valor pode ser diferente a cada execu\u00e7\u00e3o do programa, j\u00e1 que nem sempre o mesmo espa\u00e7o de mem\u00f3ria \u00e9 reservado.</p> <pre><code>int lixo;\ncout &lt;&lt; lixo &lt;&lt; endl;\n// pode imprimir valores diferentes a cada execu\u00e7\u00e3o\n</code></pre> <p>A valores obtidos dessa maneira damos o nome de lixo. Bugs cuja causa s\u00e3o vari\u00e1veis n\u00e3o inicializadas podem ser dif\u00edceis de encontrar; deixar vari\u00e1veis n\u00e3o inicializadas \u00e9 uma m\u00e1 pr\u00e1tica de programa\u00e7\u00e3o.</p>"},{"location":"C%2B%2B/2_variaveis_e_tipos_de_dados/#nomes-de-variaveis","title":"Nomes de Vari\u00e1veis","text":"<p>Existem algumas restri\u00e7\u00f5es quanto \u00e0 nomenclatura de vari\u00e1veis. Nomes de vari\u00e1veis:</p> <ul> <li>devem conter apenas letras, n\u00fameros e <code>_</code>;</li> <li>n\u00e3o podem come\u00e7ar com um n\u00famero;</li> <li>n\u00e3o podem ser palavras reservadas da linguagem, como <code>if</code>, por exemplo.</li> </ul> <p>Duas vari\u00e1veis n\u00e3o podem ter o mesmo nome dentro do mesmo escopo. Por enquanto, o escopo \u00e9 tudo o que est\u00e1 dentro da <code>main</code>. Al\u00e9m disso, letras mai\u00fasculas e min\u00fasculas identificam vari\u00e1veis \u00fanicas, isto \u00e9, a vari\u00e1vel <code>minha_variavel</code> \u00e9 diferente da vari\u00e1vel <code>Minha_variavel</code>.</p> <p>Por conven\u00e7\u00e3o, nomes de vari\u00e1veis com mais de uma palavra s\u00e3o nomeados, por todo o programa, de uma de duas formas:</p> <ul> <li>snake_case: letras min\u00fasculas com palavras separadas por <code>_</code></li> <li>camelCase: letras mai\u00fasculas no in\u00edcio de cada palavra exceto a primeira</li> </ul> <pre><code>int snake_case;\nint camelCase;\n</code></pre>"},{"location":"C%2B%2B/2_variaveis_e_tipos_de_dados/#tipos-de-dados","title":"Tipos de dados","text":"<p>O tipo de uma vari\u00e1vel determina:</p> <ul> <li>quanta mem\u00f3ria \u00e9 reservada para a vari\u00e1vel;</li> <li>quais opera\u00e7\u00f5es podem ser realizadas na vari\u00e1vel (soma, concatena\u00e7\u00e3o, etc.).</li> </ul> <p>Seguem os tipos de dados mais simples do C++, os tipos primitivos.</p>"},{"location":"C%2B%2B/2_variaveis_e_tipos_de_dados/#int","title":"<code>int</code>","text":"<p>O tipo <code>int</code> serve para o armazenamento de n\u00fameros inteiros. Seguem alguns exemplos de declara\u00e7\u00f5es de <code>int</code>:</p> <pre><code>int x = 2;\nint y = 3, z = -10;\nint numero = 1000000;\n</code></pre>"},{"location":"C%2B%2B/2_variaveis_e_tipos_de_dados/#float-e-double","title":"<code>float</code> e <code>double</code>","text":"<p>Os tipos <code>float</code> e <code>double</code> servem para o armazenamento de n\u00fameros decimais. Seguem alguns exemplos de declara\u00e7\u00f5es de <code>float</code> e <code>double</code>:</p> <pre><code>float pi = 3.14;\ndouble altura = 1.7012345;\ndouble planetas = -8;\nfloat distancia = 2e9; // podem ser declarados em nota\u00e7\u00e3o cient\u00edfica\n</code></pre>"},{"location":"C%2B%2B/2_variaveis_e_tipos_de_dados/#char","title":"<code>char</code>","text":"<p>O tipo <code>char</code> serve para o armazenamento de caracteres. Seguem alguns exemplos de declara\u00e7\u00f5es de <code>char</code>:</p> <pre><code>char c = 'a';\nchar caractere = 'c';\nchar quebra_de_linha = '\\n'; // caractere de quebra de linha\n</code></pre> <p>Note que caracteres s\u00e3o escritos entre aspas simples <code>' '</code>.</p> <p>Internamente, o tipo <code>char</code> \u00e9 armazenado similar a um <code>int</code>. Na pr\u00e1tica, um <code>char</code> \u00e9 um <code>int</code> que tem um s\u00edmbolo associado ao ser lido e escrito. Qual inteiro \u00e9 associado a qual caractere \u00e9 determinado pela tabela ASCII.</p> <p>Esse comportamento, dentre outras coisas, permite que se inicialize caracteres de acordo com seus respectivos n\u00fameros:</p> <pre><code>char a = 65; // 'A' na tabela ASCII\n</code></pre>"},{"location":"C%2B%2B/2_variaveis_e_tipos_de_dados/#bool","title":"<code>bool</code>","text":"<p>O tipo <code>bool</code> armazena um estado que pode ser <code>true</code> (verdadeiro) ou <code>false</code> (falso):</p> <pre><code>bool b1 = true;\nbool b2 = false;\n</code></pre>"},{"location":"C%2B%2B/2_variaveis_e_tipos_de_dados/#void","title":"<code>void</code>","text":"<p>O tipo <code>void</code> indica a aus\u00eancia de tipo. Ele ser\u00e1 \u00fatil apenas na se\u00e7\u00e3o de fun\u00e7\u00f5es.</p>"},{"location":"C%2B%2B/2_variaveis_e_tipos_de_dados/#modificadores-de-sinal","title":"Modificadores de sinal","text":"<p>Os modificadores <code>signed</code> e <code>unsigned</code> se aplicam aos tipos <code>int</code> e <code>char</code> e servem para tirar ou manter o sinal dos n\u00fameros.</p> <p>Sua fun\u00e7\u00e3o \u00e9 estender um pouco o intervalo de n\u00fameros que pode ser armazenado por um tipo, ao retirar a necessidade de armazenar um bit de sinal. Por\u00e9m, pode causar resultados inesperados com uso descuidado.</p> <p>Por padr\u00e3o, o modificador <code>signed</code> \u00e9 usado na omiss\u00e3o de modificador de sinal:</p> <pre><code>signed int i = -2;\nunsigned int ui = 10;\nunsigned char c = 'a';\nunsigned char uc = '2';\n\nunsigned int cuidado = -10; // armazena 4294967286\n</code></pre>"},{"location":"C%2B%2B/2_variaveis_e_tipos_de_dados/#modificadores-de-tamanho","title":"Modificadores de tamanho","text":"<p>Como a mem\u00f3ria do computador n\u00e3o \u00e9 infinita, o espa\u00e7o reservado para guardar cada vari\u00e1vel tamb\u00e9m n\u00e3o \u00e9 infinito. Consequentemente, os tipos <code>int</code>, <code>double</code>, <code>char</code> e qualquer outro tipo que represente valores num\u00e9ricos n\u00e3o podem representar n\u00fameros infinitamente grandes, uma vez que n\u00e3o h\u00e1 espa\u00e7o para guardar infinitos d\u00edgitos.</p> <p>A fim de n\u00e3o usar mem\u00f3ria demais, mas tamb\u00e9m n\u00e3o impossibilitar a representa\u00e7\u00e3o de n\u00fameros maiores, foram criados modificadores para os tipos <code>int</code> e <code>char</code>, que modificam a quantidade de mem\u00f3ria reservada. Para n\u00fameros decimais, o tipo <code>double</code> foi criado com o mesmo prop\u00f3sito.</p> <p>Modificadores de tamanho do <code>int</code> podem ser omitidos:</p> <pre><code>short x = 3; // mesmo que short int\nunsigned long long ull = 4; // mesmo que unsigned long long int\n</code></pre> <p>Segue uma tabela com os tipos primitivos e modificadores mais comuns, seus tamanhos e n\u00fameros que podem representar. Uma tabela completa pode ser encontrada aqui.</p> Tipo Tamanho em bits Intervalo (Aproximado) Intervalo (Exato) <code>char</code> 8 -128 a 127 <code>short int</code> 16 \u00b1 3 \u00d7 10\u2074 -32768 a 32767 <code>int</code> 32 \u00b1 2 \u00d7 10\u2079 -2 147 483 648 a 2 147 483 647 <code>long long int</code> 64 \u00b1 9 \u00d7 10\u00b9\u2078 -9 223 372 036 854 775 808 a 9 223 372 036 854 775 807 <code>double</code> 64 \u00b1 1.7 \u00d7 10\u207b\u00b3\u2070\u2078"},{"location":"C%2B%2B/2_variaveis_e_tipos_de_dados/#modificadores-de-mutabilidade","title":"Modificadores de mutabilidade","text":"<p>Toda vari\u00e1vel pode ter o modificador <code>const</code>, que impede que ela seja modificada no futuro. Naturalmente, vari\u00e1veis <code>const</code> necessariamente devem ser inicializadas:</p> <pre><code>const int x = 3;\nconst char y; // erro de compila\u00e7\u00e3o\n</code></pre>"},{"location":"C%2B%2B/2_variaveis_e_tipos_de_dados/#string","title":"<code>string</code>","text":"<p>O tipo <code>string</code> \u00e9 o tipo do C++ dedicado ao tratamento de cadeias de caracteres. Ele j\u00e1 n\u00e3o \u00e9 um tipo primitivo, mas \u00e9 constru\u00eddo em cima do tipo <code>char</code>. Seguem exemplos de declara\u00e7\u00f5es de strings:</p> <pre><code>string nome = \"Marcos\";\nstring vazio = \"\";\nstring louco = \"AA\\nBB\";\n</code></pre> <p>Note que o conte\u00fado de strings sempre est\u00e1 entre aspas duplas <code>\" \"</code>.</p> <p>O tamanho de uma <code>string</code> pode ser obtido com o comando <code>.size()</code>:</p> <pre><code>string nome = \"Marcos\";\ncout &lt;&lt; nome.size() &lt;&lt; '\\n'; // Imprime 6 no terminal\n</code></pre> <p>Os caracteres de uma string s\u00e3o numerados, da esquerda para a direita, de 0 at\u00e9 <code>string.size()-1</code>. Pode-se acessar um caractere espec\u00edfico com colchetes <code>[]</code> indicando a posi\u00e7\u00e3o do caractere desejado:</p> <pre><code>string nome = \"Marcos\";\ncout &lt;&lt; nome[2] &lt;&lt; '\\n'; // imprime 'r' no terminal\n</code></pre>"},{"location":"C%2B%2B/2_variaveis_e_tipos_de_dados/#literais","title":"Literais","text":"<p>Note que em diversos momentos escreve-se valores no c\u00f3digo. Esses valores recebem o nome de literais.</p> <pre><code>short si = 1s;         // literal de short\nint i = 2;             // literal de int\nlong l = 3l;           // literal de long\nlong long ll = 4ll;    // literal de long long\nfloat f = 5f;          // literal de float\ndouble d = 6.0;        // literal de double\nchar c = 'b';          // literal de char\nstring s = \"Bla\";      // literal de string\n</code></pre> <p>Caso uma vari\u00e1vel seja inicializada com o literal de um tipo diferente, o compilador tentar\u00e1 converter de um tipo para outro. Tipos num\u00e9ricos podem ser convertidos entre si:</p> <pre><code>int a = 1ll;\nint b = 1.4;\nint c = 'A';     // 65\nint d = \"1.56\";  // ERRO DE COMPILA\u00c7\u00c3O\n</code></pre>"},{"location":"C%2B%2B/2_variaveis_e_tipos_de_dados/#conversoes-de-tipos","title":"Convers\u00f5es de tipos","text":"<p>Existem dois tipos de convers\u00f5es de tipos, expl\u00edcitas e impl\u00edcitas.</p>"},{"location":"C%2B%2B/2_variaveis_e_tipos_de_dados/#conversoes-implicitas","title":"Convers\u00f5es impl\u00edcitas","text":"<p>Convers\u00f5es impl\u00edcitas ocorrem na presen\u00e7a de um tipo onde deveria haver outro. O compilador converte o tipo para o adequado automaticamente:</p> <pre><code>int x = 6.4;\n</code></pre> <ul> <li> <p>Convers\u00f5es entre os tipos inteiros (<code>char</code>, <code>int</code> e seus modificadores) funcionam bem desde que o valor esteja dentro do limite que o novo tipo consegue armazenar.</p> </li> <li> <p>Convers\u00f5es de tipos inteiros para tipos decimais (<code>float</code> e <code>double</code>) sempre funcionam.</p> </li> <li> <p>Convers\u00f5es de tipos decimais para tipos inteiros podem perder informa\u00e7\u00e3o:</p> </li> </ul> <pre><code>int x = 6.4;\ncout &lt;&lt; x &lt;&lt; '\\n'; // Escreve 6 no terminal\n</code></pre> <p>Os d\u00edgitos ap\u00f3s a v\u00edrgula s\u00e3o truncados.</p> <ul> <li>Convers\u00f5es de outros tipos para <code>bool</code> s\u00e3o <code>false</code> apenas se o valor for o valor nulo daquele tipo:</li> </ul> <pre><code>bool int_to_bool    = 0;   // false\nbool char_to_bool   = '\\0';// false\nbool double_to_bool = 0.0; // false\n</code></pre>"},{"location":"C%2B%2B/2_variaveis_e_tipos_de_dados/#conversoes-explicitas","title":"Convers\u00f5es expl\u00edcitas","text":"<p>Convers\u00f5es expl\u00edcitas s\u00e3o convers\u00f5es solicitadas pelo programa:</p> <pre><code>int x = char(6.4);\ncout &lt;&lt; x &lt;&lt; '\\n'; // Escreve 6 no terminal\n</code></pre> <p>Para converter entre tipos primitivos, basta o comando:</p> <pre><code>&lt;novo_tipo&gt;(valor)\n</code></pre> <p>Para converter tipos primitivos para strings, a fun\u00e7\u00e3o <code>to_string()</code> \u00e9 utilizada:</p> <pre><code>double pi = 3.14;\nstring s_pi = to_string(3.14);\ncout &lt;&lt; s_pi[2] &lt;&lt; '\\n'; // imprime 4 no terminal\n</code></pre> <p>Para converter de <code>string</code> a tipos primitivos, uma vez que a string \u00e9 compat\u00edvel com o tipo a ser convertido, utiliza-se:</p> <pre><code>int i           = stoi(\"4\");                // string -&gt; int\nlong l          = stol(\"5\");                // string -&gt; long\nlong long ll    = stoll(\"1000000000000\");   // string -&gt; long long\nfloat f         = stof(\"3.14\");             // string -&gt; float\ndouble d        = stod(\"4.6565323\");        // string -&gt; double\n</code></pre> <p>Outras fun\u00e7\u00f5es de convers\u00e3o num\u00e9rica de string menos comuns podem ser encontradas na documenta\u00e7\u00e3o de strings do C++.</p> <p>A convers\u00e3o de caracteres para <code>int</code> e vice-versa \u00e9 feita de acordo com o caractere na tabela ASCII. Mas isso pode n\u00e3o ser o desejado:</p> <pre><code>char c = '3';\nint x  = c; // 51, o valor de '3' na tabela ASCII, mas pode-se desejar x = 3\n</code></pre> <p>Para obter o valor desejado, pode-se operar com os valores da tabela ASCII:</p> <pre><code>char c = '3';\nint x  = c - '0'; // 51 - 48 = 3\n\nint i      = 1;\nchar l     = 'a' + i; // 'b', a segunda letra do alfabeto\n\nint k      = 8;\nchar d     = '0' + k; // '8', o caractere do d\u00edgito k\n</code></pre>"},{"location":"C%2B%2B/3_entrada_e_saida/","title":"Entrada e Sa\u00edda","text":"<p>Troca de informa\u00e7\u00f5es entre programa e usu\u00e1rio.</p>"},{"location":"C%2B%2B/3_entrada_e_saida/#troca-de-dados","title":"Troca de dados","text":"<p>Programas podem permitir que usu\u00e1rios insiram informa\u00e7\u00f5es, como nome de usu\u00e1rio, senha e cliques. Al\u00e9m disso, programas podem exibir informa\u00e7\u00f5es, como sons, imagens e v\u00eddeos.</p> <p>S\u00e3o chamadas de</p> <ul> <li>Entrada: informa\u00e7\u00f5es que o usu\u00e1rio fornece ao programa.</li> <li>Sa\u00edda: informa\u00e7\u00f5es que o programa fornece ao usu\u00e1rio.</li> </ul>"},{"location":"C%2B%2B/3_entrada_e_saida/#entrada-e-saida-padrao","title":"Entrada e sa\u00edda padr\u00e3o","text":"<p>A entrada e sa\u00edda padr\u00e3o de um programa em C++ s\u00e3o, respectivamente, o arquivo de onde o programa obt\u00e9m entradas e o arquivo onde o programa escreve suas sa\u00eddas por padr\u00e3o. S\u00e3o eles o stdin e o stdout.</p> <p>Ambos est\u00e3o, por padr\u00e3o, associados ao terminal onde o programa for executado, isto \u00e9: o que for escrito no terminal \u00e9 escrito na entrada padr\u00e3o, e o que for escrito na sa\u00edda padr\u00e3o pode ser escrito no terminal e exibido ao usu\u00e1rio.</p>"},{"location":"C%2B%2B/3_entrada_e_saida/#entrada","title":"Entrada","text":"<p>O comando <code>cin</code> solicita uma escrita na entrada padr\u00e3o e o direciona para uma vari\u00e1vel atrav\u00e9s do operador <code>&gt;&gt;</code>.</p> <pre><code>int numero;\ncin &gt;&gt; numero; // o que for lido da entrada padr\u00e3o \u00e9 armazenado em numero\n````\n\nO `cin` interpreta que espa\u00e7os em branco, isto \u00e9, quebras de linha e espa\u00e7os, separam duas entradas diferentes. Portanto, entradas lidas com o `cin` n\u00e3o devem conter espa\u00e7os, pois ser\u00e3o interpretadas como duas entradas diferentes.\n\nPara cada vari\u00e1vel lida pelo `cin`:\n\n1. ser\u00e1 checado se h\u00e1 conte\u00fado em `stdin`.\n\n   1. se n\u00e3o houver, realiza uma leitura no terminal e escreve em `stdin`.\n2. remove a primeira entrada de stdin e a armazena na vari\u00e1vel.\n\nPode-se encadear `&gt;&gt;`'s para a obten\u00e7\u00e3o de diversas entradas. Os dois c\u00f3digos a seguir funcionam de maneira id\u00eantica.\n\n```cpp\nint num1, num2, num3;\ncin &gt;&gt; num1 &gt;&gt; num2 &gt;&gt; num3;\n</code></pre> <pre><code>int num1, num2, num3;\ncin &gt;&gt; num1;\ncin &gt;&gt; num2;\ncin &gt;&gt; num3;\n</code></pre> <p>Caso o <code>cin</code> tente armazenar um valor em uma vari\u00e1vel de tipo incompat\u00edvel, ele entra em um estado de erro e quaisquer leituras dali em diante ser\u00e3o ignoradas.</p>"},{"location":"C%2B%2B/3_entrada_e_saida/#saida","title":"Sa\u00edda","text":"<p>O comando <code>cout</code> escreve na sa\u00edda padr\u00e3o e recebe valores atrav\u00e9s do operador <code>&lt;&lt;</code>:</p> <pre><code>cout &lt;&lt; \"Hello World!\";\n</code></pre> <p>Tamb\u00e9m \u00e9 poss\u00edvel escrever o valor de vari\u00e1veis.</p> <pre><code>int x = 5;\ncout &lt;&lt; x; // escreve 5 em stdout\n</code></pre> <p>Pode-se encadear <code>&lt;&lt;</code>'s para escrever diversas sa\u00eddas. Os comandos a seguir funcionam de maneira id\u00eantica.</p> <pre><code>int x = 45;\ncout &lt;&lt; \"Hello \" &lt;&lt; x &lt;&lt; \" World!\";\n</code></pre> <pre><code>int x = 45;\ncout &lt;&lt; \"Hello \";\ncout &lt;&lt; x;\ncout &lt;&lt; \" World!\";\n</code></pre>"},{"location":"C%2B%2B/3_entrada_e_saida/#quebras-de-linha","title":"Quebras de linha","text":"<p>Quebras de linha podem ser atingidas de duas maneiras: o caractere <code>\\n</code> e o manipulador <code>endl</code>. Os comandos abaixo escrevem o mesmo conte\u00fado \u00e0 sa\u00edda padr\u00e3o:</p> <pre><code>cout &lt;&lt; \"Hello World!\\n\";\ncout &lt;&lt; \"Hello World!\" &lt;&lt; endl;\n</code></pre> <p>A diferen\u00e7a entre os dois m\u00e9todos est\u00e1 em um processo que chamamos de flush.</p> <p>O <code>cout</code> escreve as informa\u00e7\u00f5es na sa\u00edda padr\u00e3o, isto \u00e9, no arquivo <code>stdout</code>. A escrita das informa\u00e7\u00f5es que est\u00e3o em <code>stdout</code> para o terminal \u00e9 o que chamamos de flush.</p> <p>O caractere <code>\\n</code> apenas escreve uma quebra de linha em <code>stdout</code>. J\u00e1 o <code>endl</code>, al\u00e9m de escrever a quebra de linha, realiza um flush.</p> <p>O processo de flush \u00e9 bem lento e deve ser realizado apenas quando necess\u00e1rio. Ele \u00e9 realizado quando:</p> <ul> <li>um <code>endl</code> \u00e9 passado ao <code>cout</code>.</li> <li>o programa finaliza.</li> <li>um <code>cin</code> est\u00e1 prestes a realizar uma leitura.</li> <li>outras maneiras de invocar um flush explicitamente s\u00e3o utilizadas.</li> </ul>"},{"location":"C%2B%2B/3_entrada_e_saida/#precisao-de-numeros-decimais","title":"Precis\u00e3o de n\u00fameros decimais","text":"<p>Pode-se decidir o n\u00famero de casas decimais de um n\u00famero a ser impresso com os seguintes manipuladores:</p> <pre><code>cout &lt;&lt; fixed &lt;&lt; setprecision(5) &lt;&lt; 3.14 &lt;&lt; '\\n'; // imprime 3.14000 no terminal\n</code></pre>"},{"location":"C%2B%2B/4_operadores/","title":"Operadores","text":"<p>Introdu\u00e7\u00e3o ao uso de operadores e operadores aritm\u00e9ticos.</p>"},{"location":"C%2B%2B/4_operadores/#operacoes","title":"Opera\u00e7\u00f5es","text":"<p>Uma vez que se sabe guardar informa\u00e7\u00f5es para o programa, tornam-se relevantes as opera\u00e7\u00f5es que podem ser realizadas sobre elas.</p> <p>Um s\u00edmbolo que representa uma opera\u00e7\u00e3o em um c\u00f3digo recebe o nome de operador.</p>"},{"location":"C%2B%2B/4_operadores/#operadores-aritmeticos","title":"Operadores Aritm\u00e9ticos","text":"<p>Operadores aritm\u00e9ticos realizam opera\u00e7\u00f5es entre tipos num\u00e9ricos:</p> Operador Descri\u00e7\u00e3o Exemplo <code>+</code> Adi\u00e7\u00e3o <code>a + b</code> <code>-</code> Subtra\u00e7\u00e3o <code>a - b</code> <code>*</code> Multiplica\u00e7\u00e3o <code>a * b</code> <code>/</code> Divis\u00e3o <code>a / b</code> <code>%</code> M\u00f3dulo (resto) <code>a % b</code> <code>++</code> Incremento <code>a++</code> ou <code>++a</code> <code>--</code> Decremento <code>a--</code> ou <code>--a</code>"},{"location":"C%2B%2B/4_operadores/#exemplos","title":"Exemplos","text":"<pre><code>cout &lt;&lt; 5 + 4 &lt;&lt; '\\n'; // imprime 9 no terminal\n````\n\n```cpp\nint x = 5 % 2, y = 10;\ncout &lt;&lt; x + 4 * y &lt;&lt; '\\n'; // imprime 41 no terminal\n</code></pre> <pre><code>cout &lt;&lt; 9 / 2 &lt;&lt; '\\n';   // imprime 4 no terminal\ncout &lt;&lt; 9.0 / 2 &lt;&lt; '\\n'; // imprime 4.5 no terminal\n</code></pre> <pre><code>int x = 5, y = 5;\ncout &lt;&lt; x++ &lt;&lt; ' ' &lt;&lt; ++y &lt;&lt; '\\n'; // imprime 5 e 6 no terminal\ncout &lt;&lt; x   &lt;&lt; ' ' &lt;&lt; y   &lt;&lt; '\\n'; // imprime 6 e 6 no terminal\n</code></pre> <p>A divis\u00e3o entre inteiros sempre d\u00e1 um resultado inteiro, desconsiderando o resto. O operador m\u00f3dulo retorna o resto da divis\u00e3o. Os operadores de incremento e decremento modificam o valor da vari\u00e1vel em 1 e podem vir antes ou depois da vari\u00e1vel:</p> <ul> <li>P\u00f3s-fixado (<code>a++</code>): primeiro usa o valor, depois incrementa.</li> <li>Pr\u00e9-fixado (<code>++a</code>): primeiro incrementa, depois usa o valor.</li> </ul>"},{"location":"C%2B%2B/4_operadores/#operacoes-em-tipos-diferentes","title":"Opera\u00e7\u00f5es em Tipos Diferentes","text":"<p>Quando a opera\u00e7\u00e3o envolve dois tipos primitivos diferentes, o compilador converte o tipo \"mais simples\" para o tipo \"mais complexo\":</p> <pre><code>4.5 / 3     // converte 3 para 3.0 e divide\n'A' + 4     // converte 'A' (65) e soma\n</code></pre> <p>Ordem de complexidade: <code>bool</code> \u2192 <code>char</code> \u2192 <code>int</code> \u2192 <code>double</code>.</p>"},{"location":"C%2B%2B/4_operadores/#operadores-de-atribuicao","title":"Operadores de Atribui\u00e7\u00e3o","text":"<p>O operador de atribui\u00e7\u00e3o <code>=</code> altera o valor de uma vari\u00e1vel:</p> <pre><code>int x = 10;\nx = 18;\nx = 9;\ncout &lt;&lt; x &lt;&lt; '\\n'; // imprime 9 no terminal\n</code></pre> <p>Tamb\u00e9m \u00e9 poss\u00edvel combinar com operadores aritm\u00e9ticos:</p> <pre><code>int x = 5;\nx += 1;  // x vira 6\nx -= 2;  // x vira 4\nx *= 2;  // x vira 8\nx /= 2;  // x vira 4\nx %= 2;  // x vira 0\n</code></pre> <p>Equivalente a:</p> <pre><code>int x = 5;\nx = x + 1;\nx = x - 2;\nx = x * 2;\nx = x / 2;\nx = x % 2;\n</code></pre>"},{"location":"C%2B%2B/4_operadores/#precedencia-e-associatividade","title":"Preced\u00eancia e Associatividade","text":"<p>Quando m\u00faltiplos operadores aparecem em uma express\u00e3o, a ordem de avalia\u00e7\u00e3o pode alterar o resultado:</p> <ul> <li>Preced\u00eancia: n\u00edvel de prioridade dos operadores (por exemplo, <code>*</code>, <code>/</code>, <code>%</code> antes de <code>+</code>, <code>-</code>).</li> <li>Associatividade: ordem de avalia\u00e7\u00e3o entre operadores de mesma preced\u00eancia (esquerda \u2192 direita ou direita \u2192 esquerda).</li> </ul> <p>Para ver a tabela completa de preced\u00eancia, consulte a refer\u00eancia do C++: https://en.cppreference.com/w/cpp/language/operator_precedence</p>"},{"location":"C%2B%2B/4_operadores/#exemplo-de-parenteses","title":"Exemplo de par\u00eanteses","text":"<pre><code>cout &lt;&lt; 2 * 5 + 11 / 4       &lt;&lt; '\\n'; // 12\ncout &lt;&lt; 2 * ((5 + 11) / 4)   &lt;&lt; '\\n'; // 8\n</code></pre>"},{"location":"C%2B%2B/5_operadores_relacionais/","title":"Operadores Relacionais","text":"<p>Operadores para a compara\u00e7\u00e3o de informa\u00e7\u00f5es.</p>"},{"location":"C%2B%2B/5_operadores_relacionais/#comparacoes","title":"Compara\u00e7\u00f5es","text":"<p>Por vezes \u00e9 \u00fatil a compara\u00e7\u00e3o entre duas informa\u00e7\u00f5es armazenadas em um programa, seja para saber se um n\u00famero \u00e9 maior do que outro ou se um caractere vem antes no alfabeto que outro.</p> <p>Os operadores que realizam compara\u00e7\u00f5es embutidos no C++ s\u00e3o chamados de operadores relacionais.</p>"},{"location":"C%2B%2B/5_operadores_relacionais/#operadores-relacionais_1","title":"Operadores Relacionais","text":"<p>Operadores relacionais realizam opera\u00e7\u00f5es de compara\u00e7\u00e3o. S\u00e3o eles:</p> Operador Descri\u00e7\u00e3o Exemplo <code>==</code> Igualdade <code>a == b</code> <code>!=</code> Diferen\u00e7a <code>a != b</code> <code>&gt;</code> Maior que <code>a &gt; b</code> <code>&lt;</code> Menor que <code>a &lt; b</code> <code>&gt;=</code> Maior ou igual que <code>a &gt;= b</code> <code>&lt;=</code> Menor ou igual que <code>a &lt;= b</code> <p>Todos retornam um <code>bool</code> com o resultado da compara\u00e7\u00e3o. Seguem alguns exemplos de uso:</p> <pre><code>cout &lt;&lt; (1 == 1) &lt;&lt; '\\n'; // 1\ncout &lt;&lt; (1 == 2) &lt;&lt; '\\n'; // 0\ncout &lt;&lt; (1 != 1) &lt;&lt; '\\n'; // 0\ncout &lt;&lt; (1 != 2) &lt;&lt; '\\n'; // 1\n````\n\nA preced\u00eancia dos operadores relacionais \u00e9 inferior \u00e0 preced\u00eancia do `&lt;&lt;`. Por isso, as compara\u00e7\u00f5es devem estar entre par\u00eanteses para impress\u00e3o:\n\n```cpp\ncout &lt;&lt; (1 &lt; 2) &lt;&lt; '\\n'; // 1\ncout &lt;&lt; (1 &gt; 2) &lt;&lt; '\\n'; // 0\ncout &lt;&lt; (1 &lt; 1) &lt;&lt; '\\n'; // 0\ncout &lt;&lt; (1 &lt;= 2) &lt;&lt; '\\n'; // 1\ncout &lt;&lt; (1 &gt;= 2) &lt;&lt; '\\n'; // 0\ncout &lt;&lt; (1 &gt;= 1) &lt;&lt; '\\n'; // 1\ncout &lt;&lt; (1 &lt;= 1) &lt;&lt; '\\n'; // 1\n</code></pre> <p>Funcionam com todos os tipos num\u00e9ricos:</p> <pre><code>cout &lt;&lt; (1.0 &lt; 2.0) &lt;&lt; '\\n'; // 1\ncout &lt;&lt; (3.14 &gt; 3.15) &lt;&lt; '\\n'; // 0\n</code></pre> <pre><code>cout &lt;&lt; ('a' &lt; 'z') &lt;&lt; '\\n'; // 1\ncout &lt;&lt; ('b' &lt; 'a') &lt;&lt; '\\n'; // 0\ncout &lt;&lt; ('@' &lt; 'g') &lt;&lt; '\\n'; // 1\n</code></pre> <p><code>char</code> tamb\u00e9m \u00e9 um tipo num\u00e9rico: a compara\u00e7\u00e3o utiliza os valores na tabela ASCII.</p> <pre><code>cout &lt;&lt; (1 + 2 &lt; 1 + 1) &lt;&lt; '\\n';   // 0\ncout &lt;&lt; (1.5 + 4.2 &gt; 4.3) &lt;&lt; '\\n'; // 1\n</code></pre> <p>Operadores aritm\u00e9ticos t\u00eam maior preced\u00eancia que operadores relacionais.</p> <pre><code>cout &lt;&lt; (1 &lt; 4 &lt; 2) &lt;&lt; '\\n'; \n// Avalia\u00e7\u00e3o:\n// 1 &lt; 4 \u2192 true (1)\n// 1 &lt; 2 \u2192 true (1)\n</code></pre> <p>Os operadores <code>&lt;</code> e <code>&gt;</code> n\u00e3o funcionam em cadeia como na matem\u00e1tica. Para compara\u00e7\u00f5es em intervalo, combine com operadores l\u00f3gicos:</p> <pre><code>if (1 &lt; x &amp;&amp; x &lt; 2) { /* ... */ }\n</code></pre>"},{"location":"C%2B%2B/5_operadores_relacionais/#comparacao-entre-floats-e-doubles","title":"Compara\u00e7\u00e3o entre <code>floats</code> e <code>doubles</code>","text":"<p>Devido ao modo como n\u00fameros decimais s\u00e3o armazenados, resultados frequentemente perdem precis\u00e3o:</p> <pre><code>cout &lt;&lt; fixed &lt;&lt; setprecision(17) &lt;&lt; 0.3       &lt;&lt; '\\n'; // 0.29999999999999999\ncout &lt;&lt; fixed &lt;&lt; setprecision(17) &lt;&lt; 0.1 + 0.2 &lt;&lt; '\\n'; // 0.30000000000000004\n</code></pre> <p>Compara\u00e7\u00f5es diretas podem ser inseguras:</p> <pre><code>double a = 0.1 + 0.2;\ndouble b = 0.3;\n\ncout &lt;&lt; fixed &lt;&lt; setprecision(17) &lt;&lt; a &lt;&lt; '\\n'; // 0.29999999999999999\ncout &lt;&lt; fixed &lt;&lt; setprecision(17) &lt;&lt; b &lt;&lt; '\\n'; // 0.30000000000000004\n\ncout &lt;&lt; (a == b) &lt;&lt; '\\n'; // 0\ncout &lt;&lt; (a != b) &lt;&lt; '\\n'; // 1\ncout &lt;&lt; (a &lt; b)  &lt;&lt; '\\n'; // 0\ncout &lt;&lt; (a &gt; b)  &lt;&lt; '\\n'; // 1\n</code></pre>"},{"location":"C%2B%2B/5_operadores_relacionais/#intervalo-de-confianca","title":"Intervalo de confian\u00e7a","text":"<p>Para comparar decimais com seguran\u00e7a, use um pequeno <code>eps</code>:</p> <pre><code>double a   = 0.1 + 0.2;\ndouble b   = 0.3;\ndouble eps = 1e-9;\n\ncout &lt;&lt; (abs(a - b) &lt; eps) &lt;&lt; '\\n'; // 1\ncout &lt;&lt; (abs(a - b) &gt; eps) &lt;&lt; '\\n'; // 0\ncout &lt;&lt; (b - a &gt; eps)      &lt;&lt; '\\n'; // 0\ncout &lt;&lt; (a - b &gt; eps)      &lt;&lt; '\\n'; // 0\n</code></pre> <p>Aqui, <code>abs(x)</code> retorna o valor absoluto de <code>x</code>.</p>"},{"location":"C%2B%2B/5_operadores_relacionais/#operadores-relacionais-e-strings","title":"Operadores relacionais e <code>strings</code>","text":"<p>Os operadores <code>==</code> e <code>!=</code> comparam strings caractere a caractere:</p> <pre><code>cout &lt;&lt; (\"abc\" == \"abc\") &lt;&lt; '\\n'; // 1\ncout &lt;&lt; (\"bca\" == \"abc\") &lt;&lt; '\\n'; // 0\ncout &lt;&lt; (\"abc \" != \"abc\") &lt;&lt; '\\n'; // 1\n</code></pre> <p>Os operadores <code>&lt;</code> e <code>&gt;</code> comparam em ordem lexicogr\u00e1fica:</p> <pre><code>string a = \"aaa\", b = \"aab\";\ncout &lt;&lt; (a &lt; b) &lt;&lt; '\\n'; // 1\n\nstring c = \"baa\", d = \"acc\";\ncout &lt;&lt; (c &lt; d) &lt;&lt; '\\n'; // 0\n\nstring e = \"abc\", f = \"abcd\";\ncout &lt;&lt; (e &lt; f) &lt;&lt; '\\n'; // 1\n\nstring g = \"abc \", h = \"abc\";\ncout &lt;&lt; (g &lt; h) &lt;&lt; '\\n'; // 0\n</code></pre>"},{"location":"C%2B%2B/5_operadores_relacionais/#comparacao-entre-literais-de-string","title":"Compara\u00e7\u00e3o entre literais de string","text":"<p>Comparar literais (<code>\"aaa\" &lt; \"bbb\"</code>) \u00e9 undefined behavior (tipo <code>const char*</code>). Em vez disso, converta para <code>string</code> ou compare objetos <code>string</code>:</p> <pre><code>cout &lt;&lt; (string(\"aaa\") &lt; string(\"bbb\")) &lt;&lt; '\\n'; // 1\ncout &lt;&lt; (string(\"aaa\") &lt; \"bbb\")           &lt;&lt; '\\n'; // 1\n</code></pre>"},{"location":"C%2B%2B/6_operadores_logicos/","title":"Operadores L\u00f3gicos","text":"<p>Operadores para operar sobre <code>bool</code>'s.</p>"},{"location":"C%2B%2B/6_operadores_logicos/#proposicoes","title":"Proposi\u00e7\u00f5es","text":"<p>Uma proposi\u00e7\u00e3o \u00e9 uma afirma\u00e7\u00e3o que pode ter valor verdadeiro ou falso. Por exemplo:</p> <p> </p> <p>Acima, claramente, $A$ \u00e9 verdadeiro e $B$ \u00e9 falso.</p> <p>\u00c9 poss\u00edvel operar com as proposi\u00e7\u00f5es com as opera\u00e7\u00f5es E, OU e N\u00c3O, gerando novas proposi\u00e7\u00f5es:</p> <p> </p> <p>Em C++, naturalmente, guardamos o resultado de proposi\u00e7\u00f5es em <code>bool</code>'s. Os operadores que utilizamos para operar sobre <code>bool</code>'s como operamos em proposi\u00e7\u00f5es s\u00e3o os operadores l\u00f3gicos.</p>"},{"location":"C%2B%2B/6_operadores_logicos/#operadores-logicos_1","title":"Operadores L\u00f3gicos","text":"<p>Operadores l\u00f3gicos operam sobre bools. S\u00e3o eles:</p> <ul> <li><code>&amp;&amp;</code> (E)  </li> <li><code>||</code> (OU)  </li> <li><code>!</code>  (N\u00c3O)  </li> </ul> a b a &amp;&amp; b a || b !a <code>true</code> <code>true</code> <code>true</code> <code>true</code> <code>false</code> <code>true</code> <code>false</code> <code>false</code> <code>true</code> <code>false</code> <code>true</code> <code>false</code> <code>true</code> <code>true</code> <code>false</code> <code>false</code> <code>false</code> <code>false</code> <ul> <li><code>&amp;&amp;</code> e <code>||</code> s\u00e3o bin\u00e1rios, <code>!</code> \u00e9 un\u00e1rio.  </li> <li><code>||</code> \u00e9 OU inclusivo: basta um operando verdadeiro para o resultado ser verdadeiro.  </li> </ul> <p>De preced\u00eancia (maior para menor): <code>!</code> \u2192 <code>&amp;&amp;</code> \u2192 <code>||</code>.</p> <p>Quando usados em outros tipos, esses operadores convertem implicitamente seus operandos para <code>bool</code>.</p>"},{"location":"C%2B%2B/6_operadores_logicos/#exemplos-de-uso","title":"Exemplos de uso","text":"<pre><code>cout &lt;&lt; (true &amp;&amp; true)   &lt;&lt; '\\n'; // 1\ncout &lt;&lt; (true &amp;&amp; false)  &lt;&lt; '\\n'; // 0\ncout &lt;&lt; (false &amp;&amp; true)  &lt;&lt; '\\n'; // 0\ncout &lt;&lt; (false &amp;&amp; false) &lt;&lt; '\\n'; // 0\n\ncout &lt;&lt; (true || true)   &lt;&lt; '\\n'; // 1\ncout &lt;&lt; (true || false)  &lt;&lt; '\\n'; // 1\ncout &lt;&lt; (false || true)  &lt;&lt; '\\n'; // 1\ncout &lt;&lt; (false || false) &lt;&lt; '\\n'; // 0\n\ncout &lt;&lt; (!true)  &lt;&lt; '\\n'; // 0\ncout &lt;&lt; (!false) &lt;&lt; '\\n'; // 1\n````\n\n```cpp\ncout &lt;&lt; (1 &amp;&amp; 2)     &lt;&lt; '\\n'; // 1\ncout &lt;&lt; (1 &amp;&amp; 0)     &lt;&lt; '\\n'; // 0\ncout &lt;&lt; (1.5 &amp;&amp; 'c') &lt;&lt; '\\n'; // 1\n</code></pre> <pre><code>bool a, b;\ncout &lt;&lt; (a &amp;&amp; !b || b &amp;&amp; !a) &lt;&lt; '\\n'; // OU exclusivo\n</code></pre> <pre><code>cout &lt;&lt; (1 &lt; 4 &lt; 2)           &lt;&lt; '\\n'; // ERRADO: cadeia n\u00e3o funciona\ncout &lt;&lt; (1 &lt; 4 &amp;&amp; 4 &lt; 2)      &lt;&lt; '\\n'; // 0\n</code></pre>"},{"location":"C%2B%2B/6_operadores_logicos/#curto-circuito","title":"Curto-circuito","text":"<p>Algumas express\u00f5es n\u00e3o avaliam todos os operandos:</p> <ul> <li>Para <code>&amp;&amp;</code>: se o primeiro for <code>false</code>, n\u00e3o avalia o segundo.</li> <li>Para <code>||</code>: se o primeiro for <code>true</code>, n\u00e3o avalia o segundo.</li> </ul> <p>\u00datil quando:</p> <ol> <li>Um operando \u00e9 custoso e s\u00f3 deve ser avaliado se necess\u00e1rio.</li> <li>O segundo operando depende do primeiro.</li> </ol> <pre><code>int x;\ncin &gt;&gt; x;\nbool b1 = x &lt; 100 || x/2 == 100; // evita divis\u00e3o se x &lt; 100\n\nstring s;\ncin &gt;&gt; s;\nbool b2 = s.size() &gt;= 3 &amp;&amp; s[2] == 'z'; // s\u00f3 acessa s[2] se size() &gt;= 3\n</code></pre>"},{"location":"C%2B%2B/7_fluxo_de_controle_1_condicionais/","title":"Fluxo de Controle 1 - Condicionais","text":"<p>Introdu\u00e7\u00e3o ao fluxo de controle e condicionais.</p>"},{"location":"C%2B%2B/7_fluxo_de_controle_1_condicionais/#fluxo-de-controle","title":"Fluxo de Controle","text":"<p>Fluxo de controle \u00e9 a ordem em que comandos s\u00e3o executados em um programa. Com as ferramentas apresentadas at\u00e9 o momento, um programa sempre executa, linha a linha, todos os seus comandos de cima para baixo. Por\u00e9m, existem ferramentas em linguagens de programa\u00e7\u00e3o para modificar o fluxo de controle.</p> <p>As duas categorias de comandos de fluxo de controle mais comuns nas linguagens de programa\u00e7\u00e3o s\u00e3o condicionais e loops.</p>"},{"location":"C%2B%2B/7_fluxo_de_controle_1_condicionais/#condicionais","title":"Condicionais","text":"<p>Condicionais permitem que comandos sejam executados se, e somente se, determinada condi\u00e7\u00e3o for verdadeira. S\u00e3o exemplos de uso da execu\u00e7\u00e3o condicional de comandos: - Logar um usu\u00e1rio somente se a senha inserida estiver correta. - Desligar o computador somente se n\u00e3o houver programas abertos. - Atualizar o computador somente se estiver carregando.</p> <p>Os condicionais mais comuns no C++ s\u00e3o o <code>if</code>, o <code>else</code> e o <code>else if</code>.</p>"},{"location":"C%2B%2B/7_fluxo_de_controle_1_condicionais/#if","title":"<code>if</code>","text":"<p>O <code>if</code> permite a execu\u00e7\u00e3o de um comando se, e somente se, uma condi\u00e7\u00e3o for verdadeira. Ele sempre tem a forma:</p> <pre><code>if(condi\u00e7\u00e3o) comando\n````\n\nA condi\u00e7\u00e3o \u00e9 uma express\u00e3o que deve retornar um `bool`, cujo valor ditar\u00e1 a execu\u00e7\u00e3o do comando. Seguem exemplos de uso:\n\n```cpp\nif (1 &lt; 5) cout &lt;&lt; 1 &lt;&lt; '\\n';            // 1\nif (1 &gt; 5) cout &lt;&lt; 1 &lt;&lt; '\\n';            // n\u00e3o executa\nif (1 &lt; 5 &amp;&amp; 2 &lt; 3) cout &lt;&lt; \"aqui\\n\";    // aqui\nif (true) cout &lt;&lt; \"bla\\n\";               // bla\nif (false) cout &lt;&lt; \"ble\\n\";              // n\u00e3o executa\n</code></pre> <pre><code>string senha = \"12345\";\nstring input;\ncin &gt;&gt; input;\nif (input == senha)\n    cout &lt;&lt; \"Logado!\\n\";\n</code></pre> <p>\u00c9 boa pr\u00e1tica indentar os comandos para explicitar sua associa\u00e7\u00e3o ao <code>if</code>.</p> <p>Tamb\u00e9m \u00e9 poss\u00edvel agrupar m\u00faltiplos comandos com <code>{}</code>:</p> <pre><code>string senha = \"12345\";\nstring input;\ncin &gt;&gt; input;\nif (input == senha) {\n    cout &lt;&lt; \"Logado!\\n\";\n    int x, y;\n    cin &gt;&gt; x &gt;&gt; y;\n    cout &lt;&lt; x + y &lt;&lt; '\\n';\n}\n</code></pre> <pre><code>int x, y;\nchar op;\ncin &gt;&gt; x &gt;&gt; y &gt;&gt; op;\n\nif (op == '+') {\n    cout &lt;&lt; x + y &lt;&lt; '\\n';\n}\nif (op == '-') {\n    cout &lt;&lt; x - y &lt;&lt; '\\n';\n}\nif (op == '*') {\n    cout &lt;&lt; x * y &lt;&lt; '\\n';\n}\nif (op == '/') {\n    cout &lt;&lt; x / y &lt;&lt; '\\n';\n}\n</code></pre>"},{"location":"C%2B%2B/7_fluxo_de_controle_1_condicionais/#else","title":"<code>else</code>","text":"<p>Um <code>else</code> acompanha um <code>if</code> para ser executado caso sua condi\u00e7\u00e3o seja falsa:</p> <pre><code>string nome;\ncin &gt;&gt; nome;\nif (nome.size() &lt;= 10) {\n    cout &lt;&lt; \"OK!\\n\";\n} else {\n    cout &lt;&lt; \"Grande demais!\\n\";\n}\n</code></pre> <pre><code>if (true) {\n    cout &lt;&lt; \"Sempre executa!\\n\";\n} else {\n    cout &lt;&lt; \"Nunca executa!\\n\";\n}\n</code></pre>"},{"location":"C%2B%2B/7_fluxo_de_controle_1_condicionais/#else-if","title":"<code>else if</code>","text":"<p>Um <code>else if</code> \u00e9 avaliado apenas se a condi\u00e7\u00e3o do <code>if</code> anterior for falsa:</p> <pre><code>string usuario;\ncin &gt;&gt; usuario;\n\nif (usuario == \"wylson789\") {\n    cout &lt;&lt; \"Bem Vindo!\\n\";\n} else if (usuario == \"mhjmbs\") {\n    cout &lt;&lt; \"Ew...\\n\";\n}\n</code></pre> <pre><code>int idade;\nstring olhos;\ncin &gt;&gt; idade &gt;&gt; olhos;\n\nif (40 &lt;= idade &amp;&amp; idade &lt;= 55) {\n    cout &lt;&lt; \"Voc\u00ea est\u00e1 na meia-idade\\n\";\n} else if (olhos == \"verdes\") {\n    cout &lt;&lt; \"Voc\u00ea tem olhos verdes\\n\";\n}\n</code></pre> <p>Note que se a pessoa est\u00e1 na meia-idade e tem olhos verdes, o programa apenas dir\u00e1 que ela est\u00e1 na meia-idade!</p> <p>M\u00faltiplos <code>else if</code> podem ser encadeados, e voc\u00ea pode adicionar um <code>else</code> final para capturar qualquer outro caso:</p> <pre><code>double altura;\ncin &gt;&gt; altura;\n\nif (altura &lt; 1.90) {\n    cout &lt;&lt; \"Voc\u00ea \u00e9 normal\\n\";\n} else if (altura &lt; 2.00) {\n    cout &lt;&lt; \"Voc\u00ea \u00e9 muito alto\\n\";\n} else if (altura &lt; 2.10) {\n    cout &lt;&lt; \"Voc\u00ea \u00e9 alto demais\\n\";\n} else {\n    cout &lt;&lt; \"?????\\n\";\n}\n</code></pre> <p>Ao avaliar <code>altura &lt; 2.00</code>, j\u00e1 sabemos que <code>altura</code> \u00e9 ao menos <code>1.90</code>, pois, caso contr\u00e1rio, o bloco do primeiro <code>if</code> teria sido executado e o restante pulado.</p>"},{"location":"C%2B%2B/8_fluxo_de_controle_2_loops/","title":"Fluxo de Controle 2 - Loops","text":"<p>Uso de estruturas de repeti\u00e7\u00e3o</p>"},{"location":"C%2B%2B/8_fluxo_de_controle_2_loops/#loops","title":"Loops","text":"<p>Uma loop ou uma estrutura de repeti\u00e7\u00e3o \u00e9 um comando de uma linguagem de programa\u00e7\u00e3o que permite a execu\u00e7\u00e3o das mesmas linhas de c\u00f3digo repetidas vezes.</p> <p>As estruturas de repeti\u00e7\u00e3o mais comuns em linguagens de programa\u00e7\u00e3o s\u00e3o o <code>while</code> e o <code>for</code>.</p>"},{"location":"C%2B%2B/8_fluxo_de_controle_2_loops/#while","title":"<code>while</code>","text":"<p>O <code>while</code> executa o mesmo comando enquanto sua condi\u00e7\u00e3o for verdadeira. Ele sempre tem a forma:</p> <pre><code>while(condi\u00e7\u00e3o) comando\n````\n\nAssim como o `if`, o comando pode ser substitu\u00eddo por uma sequ\u00eancia de comandos com o uso de `{}`. Seguem alguns exemplos de uso do `while`:\n\n```cpp\nint x = 0;\nwhile(x &lt; 5) {\n    cout &lt;&lt; x &lt;&lt; ' ';\n    x++;\n}\ncout &lt;&lt; '\\n';\n// 0 1 2 3 4\n</code></pre> <pre><code>int x = 8;\nwhile(x != 1) {\n    cout &lt;&lt; x &lt;&lt; ' ';\n    x /= 2;\n}\ncout &lt;&lt; '\\n';\n// 8 4 2\n</code></pre> <pre><code>int x = 2;\nwhile(x &lt; 1000) {\n    cout &lt;&lt; x &lt;&lt; ' ';\n    x *= x;\n}\ncout &lt;&lt; '\\n';\n// 2 4 16 256\n</code></pre> <pre><code>while(true) {\n    cout &lt;&lt; a;\n}\n// aaaa...\n</code></pre> <p>Loops podem executar infinitamente, caso a condi\u00e7\u00e3o permita.</p> <pre><code>while(false) {\n    cout &lt;&lt; a;\n}\n// (nunca executa)\n</code></pre> <pre><code>int x = 5;\nwhile(x) {\n    cout &lt;&lt; x &lt;&lt; ' ';\n    x--;\n}\ncout &lt;&lt; '\\n';\n// 5 4 3 2 1\n</code></pre>"},{"location":"C%2B%2B/8_fluxo_de_controle_2_loops/#for","title":"<code>for</code>","text":"<p>O <code>for</code> faz o mesmo que o <code>while</code>, mas sua estrutura permite a declara\u00e7\u00e3o de uma ou mais vari\u00e1veis do mesmo tipo e um comando para a altera\u00e7\u00e3o de valores a cada itera\u00e7\u00e3o. Ele sempre tem a forma:</p> <pre><code>for(declara\u00e7\u00e3o; condi\u00e7\u00e3o; altera\u00e7\u00e3o) comando\n</code></pre> <p>Quando o programa chega ao <code>for</code>, s\u00e3o executadas a declara\u00e7\u00e3o e a condi\u00e7\u00e3o. Caso a condi\u00e7\u00e3o seja verdadeira, o comando \u00e9 executado. Ap\u00f3s o comando, o comando de altera\u00e7\u00e3o \u00e9 executado e a condi\u00e7\u00e3o \u00e9 verificada novamente. Quando a condi\u00e7\u00e3o for falsa, o programa continua ap\u00f3s o <code>for</code>. Seguem exemplos de uso:</p> <pre><code>for(int i = 0; i &lt; 5; i++) {\n    cout &lt;&lt; i &lt;&lt; ' ';\n}\ncout &lt;&lt; '\\n';\n// 0 1 2 3 4\n</code></pre> <pre><code>for(int i = 0, j = 10; i != j; i++, j--) {\n    cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; j &lt;&lt; '\\n';\n}\n// 0 10\n// 1 9\n// 2 8\n// 3 7\n// 4 6\n</code></pre>"},{"location":"C%2B%2B/8_fluxo_de_controle_2_loops/#loops-aninhados","title":"Loops Aninhados","text":"<p>\u00c9 poss\u00edvel aninhar loops dentro de outros loops:</p> <pre><code>for(int i = 0; i &lt; 5; i++) {\n    cout &lt;&lt; i &lt;&lt; '\\n';\n    for(int j = 0; j &lt; 3; j++) {\n        cout &lt;&lt; \"    \" &lt;&lt; j &lt;&lt; '\\n';\n    }\n}\n// 0\n//     0\n//     1\n//     2\n// 1\n//     0\n//     1\n//     2\n// 2\n//     0\n//     1\n//     2\n// 3\n//     0\n//     1\n//     2\n// 4\n//     0\n//     1\n//     2\n</code></pre>"},{"location":"C%2B%2B/8_fluxo_de_controle_2_loops/#break","title":"<code>break</code>","text":"<p>O comando <code>break</code> pode finalizar a execu\u00e7\u00e3o de um loop:</p> <pre><code>for(int i = 0; i &lt; 5; i++) {\n    if(i == 3) break;\n    cout &lt;&lt; i &lt;&lt; ' ';\n}\ncout &lt;&lt; '\\n';\n// 0 1 2\n</code></pre> <pre><code>while(true) {\n    string entrada;\n    cin &gt;&gt; entrada;\n    if(entrada == \"PARE!\") break;\n}\n</code></pre>"},{"location":"C%2B%2B/8_fluxo_de_controle_2_loops/#continue","title":"<code>continue</code>","text":"<p>O comando <code>continue</code> pode pular para a pr\u00f3xima itera\u00e7\u00e3o de um loop:</p> <pre><code>for(int i = 0; i &lt; 5; i++) {\n    if(i == 3) continue;\n    cout &lt;&lt; i &lt;&lt; ' ';\n}\ncout &lt;&lt; '\\n';\n// 0 1 2 4\n</code></pre>"},{"location":"Fortran/Fortran_77/","title":"Fortran 77","text":""},{"location":"Fortran/Fortran_77/#sumario","title":"Sum\u00e1rio","text":"<ul> <li>Introdu\u00e7\u00e3o</li> <li>B\u00e1sico</li> <li>Vari\u00e1veis, Tipos e Declara\u00e7\u00f5es</li> <li>Express\u00f5es e Atribui\u00e7\u00f5es</li> <li>Operadores L\u00f3gicos e Condicionais</li> <li>Loops</li> <li>Subprogramas</li> <li>Arrays</li> <li>Common Blocks</li> <li>Data e Block Statements</li> <li>File I.O.</li> <li>Format</li> <li>Bibliotecas</li> <li>Exerc\u00edcios Pr\u00e1ticos</li> <li>Recursos Adicionais</li> </ul>"},{"location":"Fortran/Fortran_77/#introducao","title":"Introdu\u00e7\u00e3o","text":"<p>Aqui vamos abordar v\u00e1rias particularidades da vers\u00e3o 77. Sua leitura fica a crit\u00e9rio da curiosidade ou da necessidade do leitor.</p>"},{"location":"Fortran/Fortran_77/#pre-requisitos","title":"Pr\u00e9-requisitos","text":"<ul> <li>Conhecimento b\u00e1sico de programa\u00e7\u00e3o</li> <li>Editor de texto simples</li> <li>Compilador Fortran (gfortran recomendado)</li> </ul>"},{"location":"Fortran/Fortran_77/#limitacoes-do-fortran-77","title":"Limita\u00e7\u00f5es do Fortran 77","text":"<ul> <li>Formata\u00e7\u00e3o r\u00edgida baseada em colunas</li> <li>Nomes de vari\u00e1veis limitados a 6 caracteres</li> <li>Sem recurs\u00e3o</li> <li>Sem aloca\u00e7\u00e3o din\u00e2mica de mem\u00f3ria</li> <li>Sem ponteiros</li> </ul> <p>Este material foi fortemente inspirado no guia de Stanford para F77, dispon\u00edvel em Stanford ME200C Tutorial.</p>"},{"location":"Fortran/Fortran_77/#basico","title":"B\u00e1sico","text":""},{"location":"Fortran/Fortran_77/#estrutura-do-programa","title":"Estrutura do Programa","text":"<p>A estrutura principal do c\u00f3digo F77 \u00e9 da forma:</p> <pre><code>c234567 \n      program *nome*\n\n      *declara\u00e7\u00f5es de vari\u00e1veis*\n\n      *comandos*\n\n      stop\n      end\n</code></pre>"},{"location":"Fortran/Fortran_77/#formatacao-de-colunas","title":"Formata\u00e7\u00e3o de Colunas","text":"<p>A formata\u00e7\u00e3o da vers\u00e3o 77 \u00e9 r\u00edgida, seguindo um padr\u00e3o ditado pelo n\u00famero referente \u00e0 coluna no editor de texto, da seguinte forma:</p> Coluna Uso Descri\u00e7\u00e3o 1 Vazia ou \"c\" ou \"*\" Coment\u00e1rio (opcional) 1-5 N\u00famero de label Categoria da declara\u00e7\u00e3o da linha 6 Qualquer caractere Continua\u00e7\u00e3o da linha pr\u00e9via (opcional) 7-72 C\u00f3digo Comando principal 73-80 N\u00famero N\u00famero de sequ\u00eancia (uso incomum) <p>Exemplo Visual da Formata\u00e7\u00e3o: <pre><code>c2345678901234567890123456789012345678901234567890123456789012345678901234567890\n      program hello\n      implicit none\n      integer i\n      i = 1\n      write(*,*) 'Hello World'\n      stop\n      end\n</code></pre></p> <p>\u26a0\ufe0f Importante: N\u00e3o podemos ter uma vari\u00e1vel com o mesmo nome que o programa.</p>"},{"location":"Fortran/Fortran_77/#primeiro-programa","title":"Primeiro Programa","text":"<p><pre><code>c234567\n      PROGRAM HELLO\n      IMPLICIT NONE\n      WRITE(UNIT=*, FMT=*) 'Hello World'\n      STOP\n      END\n</code></pre> exemplo 1: Hello World. Note que os comandos come\u00e7am a partir da coluna 7</p> <p>\ud83d\udca1 Dica: O comando <code>write(UNIT=*, FMT=*)</code> tamb\u00e9m pode ser escrito como <code>write(*,*)</code>, o que \u00e9 uma simplifica\u00e7\u00e3o usual na atribui\u00e7\u00e3o desses argumentos compuls\u00f3rios.</p>"},{"location":"Fortran/Fortran_77/#variaveis-tipos-e-declaracoes","title":"Vari\u00e1veis, Tipos e Declara\u00e7\u00f5es","text":""},{"location":"Fortran/Fortran_77/#regras-de-nomenclatura","title":"Regras de Nomenclatura","text":"<p>Vari\u00e1veis em Fortran consistem em no m\u00e1ximo 6 caracteres alfanum\u00e9ricos, iniciando com uma letra, sem diferenciar mai\u00fasculas e min\u00fasculas. </p> <p>Regras importantes: - M\u00e1ximo de 6 caracteres - Deve come\u00e7ar com uma letra (A-Z) - Pode conter letras e n\u00fameros - N\u00e3o diferencia mai\u00fasculas/min\u00fasculas (<code>VAR</code>, <code>var</code>, <code>Var</code> s\u00e3o iguais) - Palavras reservadas n\u00e3o podem ser usadas como nomes</p> <p>Palavras reservadas: <code>program</code>, <code>real</code>, <code>stop</code>, <code>end</code>, <code>integer</code>, <code>character</code>, <code>logical</code>, <code>complex</code>, <code>double</code>, <code>precision</code>, <code>parameter</code>, <code>data</code>, <code>common</code>, <code>dimension</code>, <code>external</code>, <code>intrinsic</code>, <code>save</code>, <code>goto</code>, <code>if</code>, <code>then</code>, <code>else</code>, <code>endif</code>, <code>do</code>, <code>continue</code>, <code>call</code>, <code>return</code>, <code>function</code>, <code>subroutine</code>, <code>write</code>, <code>read</code>, <code>print</code>, <code>format</code>, <code>open</code>, <code>close</code>, <code>backspace</code>, <code>rewind</code>, <code>endfile</code></p>"},{"location":"Fortran/Fortran_77/#tipos-de-dados","title":"Tipos de Dados","text":"<p>Toda vari\u00e1vel deve ser definida em uma declara\u00e7\u00e3o que estabelece seu tipo. Aqui est\u00e1 uma tabela comparativa:</p> Tipo Descri\u00e7\u00e3o Tamanho Faixa/Exemplo Uso <code>integer</code> N\u00fameros inteiros 32 bits \u00b12\u00d710\u2079 Contadores, \u00edndices <code>real</code> N\u00fameros reais (precis\u00e3o simples) 4 bytes ~7 d\u00edgitos C\u00e1lculos cient\u00edficos <code>double precision</code> N\u00fameros reais (precis\u00e3o dupla) 8 bytes ~15 d\u00edgitos C\u00e1lculos de alta precis\u00e3o <code>complex</code> N\u00fameros complexos 8 bytes (a, b) onde a,b s\u00e3o reais Matem\u00e1tica complexa <code>logical</code> Valores l\u00f3gicos 4 bytes <code>.TRUE.</code> ou <code>.FALSE.</code> Condi\u00e7\u00f5es <code>character</code> Caracteres/texto Vari\u00e1vel <code>'texto'</code> Strings"},{"location":"Fortran/Fortran_77/#declaracoes-de-variaveis","title":"Declara\u00e7\u00f5es de Vari\u00e1veis","text":"<pre><code>c234567\n      integer i, j, k\n      real x, y, z\n      double precision pi\n      complex c1, c2\n      logical flag\n      character*10 nome\n      character*1 letra\n</code></pre>"},{"location":"Fortran/Fortran_77/#boas-praticas","title":"Boas Pr\u00e1ticas","text":"<p>Embora o Fortran utilize regras impl\u00edcitas se a vari\u00e1vel n\u00e3o for declarada, \u00e9 boa pr\u00e1tica usar <code>implicit none</code> para evitar ambiguidades e for\u00e7ar a declara\u00e7\u00e3o de todas as vari\u00e1veis.</p> <p>Regras impl\u00edcitas (evitar usar): - Vari\u00e1veis come\u00e7ando com I-N s\u00e3o <code>integer</code> - Outras vari\u00e1veis s\u00e3o <code>real</code></p>"},{"location":"Fortran/Fortran_77/#constantes-parameter","title":"Constantes (PARAMETER)","text":"<p>Para definir constantes, declara-se um par\u00e2metro na sintaxe:</p> <pre><code>      parameter (name = constant, ..., name = constant)\n</code></pre> <p>O par\u00e2metro deve ser definido antes da primeira execu\u00e7\u00e3o do c\u00f3digo.</p> <p><pre><code>c234567\n      PROGRAM TYPES\n      IMPLICIT NONE\n\n      ! Determina a declara\u00e7\u00e3o do tipo de vari\u00e1veis\n      INTEGER alfa, beta, delta\n\n      PARAMETER (alfa = 5, beta = 10)\n\n      delta = alfa + beta\n      write (*,*) 'Resulta em', delta\n\n      STOP\n      END\n</code></pre> exemplo 2: tipagem</p>"},{"location":"Fortran/Fortran_77/#expressoes-e-atribuicoes","title":"Express\u00f5es e Atribui\u00e7\u00f5es","text":""},{"location":"Fortran/Fortran_77/#expressoes","title":"Express\u00f5es","text":"<p>Uma express\u00e3o \u00e9 uma combina\u00e7\u00e3o de operandos e operadores, como em <code>x + y</code> (onde <code>x</code> e <code>y</code> s\u00e3o operandos e <code>+</code> \u00e9 o operador). O resultado de uma express\u00e3o torna-se um novo operando, permitindo nesting (express\u00f5es aninhadas).</p> <p>Existem constantes de seis tipos: integer, real, double precision, complex, logical e character. - O uso de <code>E</code> em um valor, como <code>2.0E6</code>, implica que o valor anterior \u00e0 <code>E</code> deve ser multiplicado por 10 elevado ao n\u00famero \u00e0 direita de <code>E</code> (ou seja, <code>2.0E6 = 2 * 10^6</code>). - Valores complexos s\u00e3o expressos como um par de constantes (por exemplo, <code>(2, -3)</code> ou <code>(1., 9.9E-1)</code>), onde o primeiro \u00e9 a parte real e o segundo a parte imagin\u00e1ria. - Constantes l\u00f3gicas s\u00e3o expressas como <code>.True.</code> ou <code>.False.</code> (os pontos s\u00e3o obrigat\u00f3rios). - Constantes de caractere, ou strings, s\u00e3o delimitadas por aspas simples (ex.: <code>'ABC'</code>, <code>'potato potato'</code>) e s\u00e3o sens\u00edveis a mai\u00fasculas e min\u00fasculas.</p>"},{"location":"Fortran/Fortran_77/#atribuicoes","title":"Atribui\u00e7\u00f5es","text":"<p>A sintaxe para atribui\u00e7\u00f5es \u00e9:</p> <pre><code>nome_da_variavel = express\u00e3o\n</code></pre> <p>O valor da express\u00e3o \u00e0 direita \u00e9 avaliado e atribu\u00eddo \u00e0 vari\u00e1vel \u00e0 esquerda.</p>"},{"location":"Fortran/Fortran_77/#conversao-de-tipos","title":"Convers\u00e3o de Tipos","text":"<p>Quando diferentes tipos de dados s\u00e3o usados em uma express\u00e3o, pode ocorrer convers\u00e3o impl\u00edcita ou \u00e9 necess\u00e1rio for\u00e7ar a convers\u00e3o usando fun\u00e7\u00f5es como: - <code>int</code> (para converter para integer) - <code>real</code> (para converter para real) - <code>dble</code> (para converter para double precision) - <code>ichar</code> (converte caractere em inteiro) - <code>char</code> (converte inteiro em caractere)</p> <p>Note que <code>w = dble(x) * dble(y)</code> difere de <code>w = dble(x*y)</code> para vari\u00e1veis reais <code>x</code> e <code>y</code>.</p>"},{"location":"Fortran/Fortran_77/#operadores-logicos-e-condicionais","title":"Operadores L\u00f3gicos e Condicionais","text":""},{"location":"Fortran/Fortran_77/#operadores-logicos","title":"Operadores L\u00f3gicos","text":"<p>Para comparar express\u00f5es, utilizamos operadores relacionais que avaliam como <code>.True.</code> ou <code>.False.</code>:</p> <ul> <li><code>.LT.</code> : \"menor que\" (equivalente a <code>&lt;</code>)</li> <li><code>.GT.</code> : \"maior que\" (equivalente a <code>&gt;</code>)</li> <li><code>.LE.</code> : \"menor ou igual\" (equivalente a <code>&lt;=</code>)</li> <li><code>.GE.</code> : \"maior ou igual\" (equivalente a <code>&gt;=</code>)</li> <li><code>.EQ.</code> : \"igual\" (equivalente a <code>=</code>)</li> <li><code>.NQ.</code> : \"diferente\" (equivalente a <code>!=</code>)</li> </ul> <p>Outros termos \u00fateis s\u00e3o: - <code>.AND.</code> - <code>.OR.</code> - <code>.NOT.</code></p>"},{"location":"Fortran/Fortran_77/#condicionais","title":"Condicionais","text":"<p>Condi\u00e7\u00f5es s\u00e3o estruturadas de tr\u00eas maneiras:</p> <ol> <li> <p>Condi\u00e7\u00e3o em linha \u00fanica:    Se a condi\u00e7\u00e3o l\u00f3gica for verdadeira, execute o comando.    <pre><code>      if (x .LT. 0) x = -x\n</code></pre></p> </li> <li> <p>Condi\u00e7\u00e3o com m\u00faltiplos comandos: <pre><code>      if (condi\u00e7\u00e3o l\u00f3gica) then\n          comandos\n      endif\n</code></pre></p> </li> <li> <p>Condi\u00e7\u00e3o com alternativas: <pre><code>      if (condi\u00e7\u00e3o l\u00f3gica) then\n          comandos\n      elseif (outra condi\u00e7\u00e3o l\u00f3gica) then\n          comandos\n      else\n          comandos\n      endif\n</code></pre></p> </li> </ol>"},{"location":"Fortran/Fortran_77/#exemplo-cadastro-de-numeros-telefonicos-com-ddd","title":"Exemplo: Cadastro de N\u00fameros Telef\u00f4nicos com DDD","text":"<p><pre><code>c234567\n      PROGRAM CONDITIONALS\n      IMPLICIT NONE\n      CHARACTER*11 NUMBER\n      CHARACTER*9 REST\n      INTEGER LEN\n\n      write (*,*) 'Input Number:'\n      read (*,*) NUMBER\n\n      LEN = LEN_TRIM(NUMBER)\n\n      IF (LEN .GT. 3) THEN\n          REST = NUMBER(3:LEN)\n      ELSE\n          REST = ''\n      END IF\n\n      IF (LEN .LT. 8 .OR. LEN .GT. 11) then\n          write(*,*) 'Invalid Number'\n      ELSE IF (LEN .EQ. 8 .OR. LEN .EQ. 9) then\n          write(*,*) NUMBER\n      ELSE IF (LEN .EQ. 10 .OR. LEN .EQ. 11) then         \n          write(*,*) 'DDD and number are ', NUMBER(1:2) // ' ' // REST\n      END IF\n\n      STOP\n      END\n</code></pre> exemplo 3: cadastro de telefone</p> <p>Funcionamento do Programa: - Solicita ao usu\u00e1rio um n\u00famero de telefone (string). - Calcula o comprimento real da string com <code>LEN_TRIM</code>. - Se o comprimento for menor que 8 ou maior que 11, imprime \"Invalid Number\". - Se for 8 ou 9, imprime o n\u00famero diretamente. - Se for entre 10 e 11, imprime o DDD (dois primeiros caracteres), um espa\u00e7o e o restante do n\u00famero.</p>"},{"location":"Fortran/Fortran_77/#loops","title":"Loops","text":""},{"location":"Fortran/Fortran_77/#tipos-de-loops-em-fortran-77","title":"Tipos de Loops em Fortran 77","text":"<p>Fortran 77 oferece tr\u00eas tipos principais de loops, cada um com suas caracter\u00edsticas espec\u00edficas:</p> Tipo Sintaxe Quando Usar Vantagens Desvantagens DO Loop <code>DO label var = start, end, step</code> N\u00famero conhecido de itera\u00e7\u00f5es Simples, eficiente Limitado a incrementos fixos While Loop <code>label IF (cond) THEN ... GOTO label</code> Condi\u00e7\u00e3o de continua\u00e7\u00e3o Flex\u00edvel Usa GOTO (considerado m\u00e1 pr\u00e1tica) Until Loop <code>label ... IF (cond) GOTO label</code> Condi\u00e7\u00e3o de parada Flex\u00edvel Usa GOTO (considerado m\u00e1 pr\u00e1tica)"},{"location":"Fortran/Fortran_77/#do-loops","title":"DO Loops","text":"<p>A sintaxe geral \u00e9:</p> <pre><code>c234567\n      do label var = expr1, expr2, expr3\n          statements\n      label continue\n</code></pre> <p>Par\u00e2metros: - var: vari\u00e1vel do loop (deve ser inteiro) - expr1: valor inicial - expr2: valor limitante - expr3: incremento (opcional, padr\u00e3o \u00e9 1)</p> <p>Caracter\u00edsticas: - A vari\u00e1vel \u00e9 incrementada automaticamente - O loop termina quando var &gt; expr2 (se expr3 &gt; 0) ou var &lt; expr2 (se expr3 &lt; 0) - A vari\u00e1vel pode ser modificada dentro do loop (n\u00e3o recomendado)</p> <p><pre><code>c234567\n      PROGRAM SHOW\n      IMPLICIT NONE\n\n      INTEGER a(10), I\n\n      DATA a /1, 2, 3, 4, 5, 6, 7, 8, 9, 10/\n\n      DO 10 I = 1, 10\n          PRINT *, 'Elemento', I, ':', a(I)\n10    CONTINUE\n\n      END\n</code></pre> exemplo 4.1: loop simples</p> <p>Varia\u00e7\u00f5es do DO Loop: <pre><code>c234567\n      ! Loop com incremento diferente de 1\n      DO 20 I = 1, 10, 2\n          PRINT *, I\n20    CONTINUE\n\n      ! Loop decrescente\n      DO 30 I = 10, 1, -1\n          PRINT *, I\n30    CONTINUE\n</code></pre></p>"},{"location":"Fortran/Fortran_77/#while-loops-condicao-de-progresso","title":"While Loops (Condi\u00e7\u00e3o de Progresso)","text":"<p>O programador atual est\u00e1 acostumado com o formato:</p> <pre><code>c234567\n      while (logical expr) do\n        statements\n      enddo\n</code></pre> <p>Mas ele n\u00e3o \u00e9 ANSI Fortran 77. O adequado \u00e9:</p> <pre><code>c234567\n      label if (logical expr) then\n          statements\n          goto label\n      end if\n</code></pre> <p>Quando usar: Quando voc\u00ea n\u00e3o sabe quantas itera\u00e7\u00f5es ser\u00e3o necess\u00e1rias, mas sabe a condi\u00e7\u00e3o de continua\u00e7\u00e3o.</p> <p><pre><code>c234567\n      PROGRAM WOW\n      IMPLICIT NONE\n\n      INTEGER a(10), I\n\n      DATA a /1, 2, 3, 4, 5, 6, 7, 8, 9, 10/\n\n      I = 1\n\n10    IF (a(I) /= 5) THEN\n          PRINT *, 'Elemento', I, ':', a(I)\n          I = I + 1\n          GOTO 10\n      END IF\n\n      END\n</code></pre> exemplo 4.2: While do</p>"},{"location":"Fortran/Fortran_77/#until-loops-condicao-de-parada","title":"Until Loops (Condi\u00e7\u00e3o de Parada)","text":"<p>Um exemplo de loop \"until\" usando <code>goto</code>:</p> <p><pre><code>c234567\n10    CONTINUE\n      PRINT *, 'Elemento', I, ':', a(I)\n      I = I + 1\n      IF (a(I) /= 9) THEN       \n          GOTO 10\n      END IF\n      END\n</code></pre> exemplo 4.3: Until do</p> <p>Quando usar: Quando voc\u00ea quer executar o corpo do loop pelo menos uma vez e depois verificar a condi\u00e7\u00e3o de parada.</p>"},{"location":"Fortran/Fortran_77/#comparacao-pratica","title":"Compara\u00e7\u00e3o Pr\u00e1tica","text":"Cen\u00e1rio Loop Recomendado Exemplo Iterar sobre array conhecido DO Loop <code>DO 10 I = 1, N</code> Ler at\u00e9 encontrar sentinela While Loop <code>WHILE (valor /= -1)</code> Processar at\u00e9 condi\u00e7\u00e3o Until Loop <code>UNTIL (convergiu)</code> Contagem regressiva DO Loop <code>DO 20 I = N, 1, -1</code>"},{"location":"Fortran/Fortran_77/#consideracoes-sobre-goto","title":"\u26a0\ufe0f Considera\u00e7\u00f5es sobre GOTO","text":"<p>O uso de <code>GOTO</code> \u00e9 considerado m\u00e1 pr\u00e1tica em programa\u00e7\u00e3o moderna, mas em Fortran 77 \u00e9 frequentemente necess\u00e1rio para implementar loops while e until. Em vers\u00f5es mais modernas do Fortran, use <code>DO WHILE</code> e <code>DO UNTIL</code>.</p>"},{"location":"Fortran/Fortran_77/#subprogramas","title":"Subprogramas","text":"<p>Subprogramas s\u00e3o blocos de c\u00f3digo que resolvem tarefas espec\u00edficas, podendo ser fun\u00e7\u00f5es ou subrotinas.</p>"},{"location":"Fortran/Fortran_77/#funcoes","title":"Fun\u00e7\u00f5es","text":"<p>Fun\u00e7\u00f5es recebem um ou mais argumentos e retornam um valor. A maioria das fun\u00e7\u00f5es inatas (como <code>abs</code>, <code>min</code>, <code>max</code>, <code>sqrt</code>) s\u00e3o gen\u00e9ricas, mas fun\u00e7\u00f5es definidas pelo usu\u00e1rio geralmente precisam especificar o tipo de retorno. O valor de retorno \u00e9 atribu\u00eddo \u00e0 vari\u00e1vel com o mesmo nome da fun\u00e7\u00e3o e o bloco termina com <code>RETURN</code>.</p> <p><pre><code>c234567\n      PROGRAM CHOOSE\n      IMPLICIT NONE\n\n      INTEGER P, R, QUADRADO\n\n      WRITE(*,*) 'CHOOSE A NUMBER 1 TO 10'\n      READ (*,*) P\n\n      R = QUADRADO(P)\n\n      WRITE(*,*) 'O RESULTADO \u00c9', R\n\n      END\n\n      INTEGER FUNCTION QUADRADO(X)\n      IMPLICIT NONE\n      INTEGER X\n\n      QUADRADO = X * X\n\n      RETURN\n      END\n</code></pre> exemplo 5.1: Quadrado</p>"},{"location":"Fortran/Fortran_77/#subrotinas","title":"Subrotinas","text":"<p>Subrotinas podem retornar mais de um valor e s\u00e3o invocadas com <code>CALL</code>. Elas n\u00e3o possuem tipo.</p> <p><pre><code>c234567\n      PROGRAM CHAMA_SUBROTINA\n      IMPLICIT NONE\n\n      INTEGER N, QUADRADO, CUBO\n\n      PRINT *, 'Digite um n\u00famero:'\n      READ *, N\n\n      CALL CALCULA_QUADRADO_E_CUBO(N, QUADRADO, CUBO)\n\n      PRINT *, 'O quadrado de', N, '\u00e9', QUADRADO\n      PRINT *, 'O cubo de', N, '\u00e9', CUBO\n\n      END\n\n      SUBROUTINE CALCULA_QUADRADO_E_CUBO(X, QUAD, CUB)\n      IMPLICIT NONE\n      INTEGER X, QUAD, CUB\n\n      QUAD = X * X\n      CUB = X * X * X\n\n      RETURN\n      END\n</code></pre> exemplo 5.2: Quadrado e Cubo</p>"},{"location":"Fortran/Fortran_77/#arrays","title":"Arrays","text":""},{"location":"Fortran/Fortran_77/#declaracao-de-arrays","title":"Declara\u00e7\u00e3o de Arrays","text":"<p>Para declarar vetores e matrizes:</p> <pre><code>c234567\n      real a(20)\n      ! Declara um vetor com 20 componentes reais, indexados de 1 a 20\n\n      real A(3,5)\n      ! Declara uma matriz 3x5\n\n      logical B(20,5,39,29152)\n      ! Declara um array 20x5x39x2\n</code></pre> <p>Fortran 77 permite arrays de at\u00e9 7 dimens\u00f5es.</p>"},{"location":"Fortran/Fortran_77/#manipulacao-de-arrays","title":"Manipula\u00e7\u00e3o de Arrays","text":""},{"location":"Fortran/Fortran_77/#inicializacao-em-loop","title":"Inicializa\u00e7\u00e3o em Loop","text":"<p><pre><code>c234567\n      PROGRAM EXEMPLO_ARRAY\n      IMPLICIT NONE\n\n      INTEGER N, A(5), I\n      PARAMETER (N = 5)\n\n      DO I = 1, N\n          A(I) = I * 2   \n      END DO\n\n      PRINT *, 'Elementos do array A:'\n      DO I = 1, N\n          PRINT *, 'A(', I, ') = ', A(I)\n      END DO\n\n      END\n</code></pre> exemplo 6.1: Array b\u00e1sico</p>"},{"location":"Fortran/Fortran_77/#soma-de-elementos","title":"Soma de Elementos","text":"<p><pre><code>c234567\n      PROGRAM SOMA_ARRAY\n      IMPLICIT NONE\n\n      INTEGER N, A(5), SUM, I\n      PARAMETER (N = 5)\n\n      ! Inicializa\u00e7\u00e3o usando DATA statement\n      DATA A /1, 2, 3, 4, 5/\n\n      SUM = 0\n\n      DO I = 1, N\n          SUM = SUM + A(I)\n      END DO\n\n      PRINT *, 'Soma dos elementos de A:', SUM\n\n      END\n</code></pre> exemplo 6.2: Array Soma</p>"},{"location":"Fortran/Fortran_77/#produto-de-elementos","title":"Produto de Elementos","text":"<p><pre><code>c234567\n      PROGRAM MULTIPLICACAO_ARRAY\n      IMPLICIT NONE\n\n      INTEGER N, A(5), PRODUTO, I\n      PARAMETER (N = 5)\n\n      ! Inicializa\u00e7\u00e3o usando DATA statement\n      DATA A /1, 2, 3, 4, 5/\n\n      PRODUTO = 1\n\n      DO I = 1, N\n          PRODUTO = PRODUTO * A(I)\n      END DO\n\n      PRINT *, 'Produto dos elementos de A:', PRODUTO\n\n      END\n</code></pre> exemplo 6.3: Array Produto</p>"},{"location":"Fortran/Fortran_77/#operacoes-comuns-com-arrays","title":"Opera\u00e7\u00f5es Comuns com Arrays","text":""},{"location":"Fortran/Fortran_77/#busca-linear","title":"Busca Linear","text":"<pre><code>c234567\n      PROGRAM BUSCA_LINEAR\n      IMPLICIT NONE\n\n      INTEGER A(10), VALOR, I, POSICAO\n      LOGICAL ENCONTRADO\n\n      DATA A /5, 2, 8, 1, 9, 3, 7, 4, 6, 0/\n\n      PRINT *, 'Digite o valor a procurar:'\n      READ *, VALOR\n\n      ENCONTRADO = .FALSE.\n      POSICAO = 0\n\n      DO I = 1, 10\n          IF (A(I) .EQ. VALOR) THEN\n              ENCONTRADO = .TRUE.\n              POSICAO = I\n              GOTO 100\n          END IF\n      END DO\n\n100   IF (ENCONTRADO) THEN\n          PRINT *, 'Valor encontrado na posi\u00e7\u00e3o:', POSICAO\n      ELSE\n          PRINT *, 'Valor n\u00e3o encontrado'\n      END IF\n\n      END\n</code></pre>"},{"location":"Fortran/Fortran_77/#ordenacao-basica-bubble-sort","title":"Ordena\u00e7\u00e3o B\u00e1sica (Bubble Sort)","text":"<pre><code>c234567\n      PROGRAM ORDENACAO\n      IMPLICIT NONE\n\n      INTEGER A(5), I, J, TEMP\n\n      DATA A /5, 2, 8, 1, 9/\n\n      PRINT *, 'Array original:'\n      DO I = 1, 5\n          PRINT *, A(I)\n      END DO\n\n      ! Bubble sort\n      DO I = 1, 4\n          DO J = 1, 4\n              IF (A(J) .GT. A(J+1)) THEN\n                  TEMP = A(J)\n                  A(J) = A(J+1)\n                  A(J+1) = TEMP\n              END IF\n          END DO\n      END DO\n\n      PRINT *, 'Array ordenado:'\n      DO I = 1, 5\n          PRINT *, A(I)\n      END DO\n\n      END\n</code></pre>"},{"location":"Fortran/Fortran_77/#dicas-importantes","title":"Dicas Importantes","text":"<ul> <li>Indexa\u00e7\u00e3o: Arrays em Fortran come\u00e7am no \u00edndice 1, n\u00e3o 0</li> <li>Limites: Sempre verifique os limites dos arrays para evitar erros</li> <li>Inicializa\u00e7\u00e3o: Use <code>DATA</code> statement para inicializar arrays</li> <li>Performance: Acesse arrays em ordem de mem\u00f3ria (primeira dimens\u00e3o varia mais rapidamente)</li> </ul>"},{"location":"Fortran/Fortran_77/#common-blocks","title":"Common Blocks","text":"<p>Common blocks permitem compartilhar vari\u00e1veis entre subprogramas. O bloco comum deve ser declarado antes das execu\u00e7\u00f5es.</p> <pre><code>      program main\n      ! Declara\u00e7\u00f5es\n      real alpha, beta\n      common /coeff/ alpha, beta\n\n      ! Statements\n      stop\n      end\n\n      subroutine sub1(...)\n      real alpha, beta\n      common /coeff/ alpha, beta\n\n      ! Statements\n      return\n      end\n\n      subroutine sub2(...)\n      real alpha, beta\n      common /coeff/ alpha, beta\n\n      ! Statements\n      return\n      end\n</code></pre> <p>Regras importantes: - O bloco comum deve ser declarado antes da execu\u00e7\u00e3o do c\u00f3digo. - Blocos comuns distintos devem ter nomes distintos. - Uma vari\u00e1vel n\u00e3o pode aparecer em dois blocos comuns diferentes. - Vari\u00e1veis devem ser listadas na mesma ordem, com o mesmo tipo e tamanho em todas as rotinas que utilizam o mesmo bloco comum. - Arrays com dimens\u00f5es vari\u00e1veis n\u00e3o devem constar em blocos comuns.</p>"},{"location":"Fortran/Fortran_77/#data-e-block-statements","title":"Data e Block Statements","text":"<p>O <code>data</code> statement \u00e9 usado para inicializar vari\u00e1veis antes da execu\u00e7\u00e3o do programa.</p> <p><pre><code>c234567\n      program main\n      data m/10/, n/20/, x/2.5/, y/2.5/\n      real m, n, x, y\n\n      write (*,*) m\n      write (*,*) n \n      write (*,*) x\n      write (*,*) y\n      STOP\n      END\n</code></pre> exemplo 7.1: inicializa\u00e7\u00e3o</p> <p>Outra forma:</p> <p><pre><code>c234567\n      program main\n      data m,n/10,20/, x,y/2*2.5/\n      real m, n, x, y\n\n      write (*,*) m\n      write (*,*) n\n      write (*,*) x\n      write (*,*) y\n      STOP\n      END\n</code></pre> exemplo 7.2: inicializa\u00e7\u00e3o alt Com matrizes:</p> <p><pre><code>c234567\n      program main\n      real A(10,20)\n      data A/ 200 * 0.0/\n      ...\n</code></pre> exemplo 7.3: inicializa\u00e7\u00e3o matricial</p> <p>O exemplo acima inicializa uma matriz 10x20 com todos os 200 valores iguais a zero.</p>"},{"location":"Fortran/Fortran_77/#file-io","title":"File I.O.","text":"<p>O comando principal para acessar um arquivo \u00e9:</p> <pre><code>      open ([UNIT=]u [, IOSTAT=ios, ERR=err, STATUS=sta])\n</code></pre> <p>Especificadores comuns: - unidade (\"u\"): valor inteiro \u00fanico de 1 a 99 que identifica o arquivo. - status (\"ios\"): vari\u00e1vel inteira que retorna zero se a opera\u00e7\u00e3o for bem-sucedida. - error (\"err\"): determina para qual comando o programa deve saltar em caso de erro. - nome (\"fname\"): nome do arquivo a ser acessado (string). - status (\"sta\"): deve ser NEW, OLD ou SCRATCH; define se o arquivo j\u00e1 existe ou se deve ser criado e se ser\u00e1 deletado ap\u00f3s o fechamento. - final (\"end\"): determina para qual comando o programa deve saltar ao chegar ao fim do arquivo (usado em <code>read</code> ou <code>write</code>).</p> <p>Para fechar o arquivo, usa-se:</p> <pre><code>      close ([UNIT=]u [, IOSTAT=ios, ERR=err, STATUS=sta])\n</code></pre> <p>Os comandos <code>read</code> e <code>write</code> s\u00e3o usados com o especificador de unidade obrigat\u00f3rio.</p> <p><pre><code>c234567\n      program inpdat\n      ! Este programa l\u00ea n pontos de um arquivo e os armazena em 3 arrays: x, y, z.\n\n      integer nmax, u\n      parameter (nmax=1000, u=20)\n      real x(nmax), y(nmax), z(nmax)\n\n      ! Abre o arquivo de dados\n      open (u, FILE='points.dat', STATUS='OLD')\n\n      ! L\u00ea o n\u00famero de pontos\n      read(u,*) n\n      if (n.GT.nmax) then\n          write(*,*) 'Error: n = ', n, 'is larger than nmax =', nmax\n          goto 9999\n      endif\n\n      ! Loop sobre os pontos\n      do 10 i= 1, n\n          read(u,100) x(i), y(i), z(i)\n10    enddo\n100   format (3(F10.4))\n\n      ! Fecha o arquivo\n      close (u)\n\n      ! (Parte faltante para processar os dados)\n\n9999  stop\n      end\n</code></pre> exemplo 8: Leitura e escrita (IO)</p>"},{"location":"Fortran/Fortran_77/#format","title":"Format","text":"<p>A formata\u00e7\u00e3o \u00e9 definida com o comando <code>write</code> seguido de um label que especifica o formato.</p> <pre><code>c234567\n      program main\n      data m/10/, n/20/, x/2.5/, y/2.5/\n      real m, n, x, y\n\n      write (*,*) m\n      write (*,*) n\n      write (*,*) x\n      write (*,*) y\n      STOP\n      END\n</code></pre> <p>A sa\u00edda deste c\u00f3digo seria algo como:</p> <pre><code>10.0000000\n20.0000000\n2.50000000\n2.50000000\n</code></pre> <p>A formata\u00e7\u00e3o pode ser alterada seguindo o padr\u00e3o:</p> <pre><code>c234567      \n      write(*,label) lista_de_variaveis\n      label format-code \n</code></pre> <p>C\u00f3digos comuns de formata\u00e7\u00e3o: - A: string de texto - D: n\u00fameros em double precision, nota\u00e7\u00e3o exponencial - E: n\u00fameros reais, nota\u00e7\u00e3o exponencial - F: n\u00fameros reais, formato fixo - I: inteiro - X: espa\u00e7o horizontal - /: salto de linha</p> <p>Exemplo:</p> <p><pre><code>c234567\n      program main\n      data m/10/, n/20/, x/2.5/, y/2.5/\n\n      ! Escreve m com formato I2\n      write (*,100) m\n100   format (I2)\n\n      ! Escreve n com formato inline\n      write (*,'(I2)') n  \n\n      ! Escreve x com formato F4.1\n      write (*,300) x\n300   format (F4.1)\n\n      ! Escreve y com formato E8.2\n      write (*,400) y\n400   format (E8.2)\n\n      STOP\n      END\n</code></pre> exemplo 9: format Sa\u00edda esperada:</p> <pre><code>10\n20\n2.5\n0.25E+01\n</code></pre>"},{"location":"Fortran/Fortran_77/#bibliotecas","title":"Bibliotecas","text":"<p>Como em qualquer outra linguagem, \u00e9 poss\u00edvel utilizar pacotes j\u00e1 criados (muitos gratuitos) para resolver problemas comuns. Para problemas num\u00e9ricos, por exemplo, a plataforma Netlib disponibiliza softwares e databases de interesse cient\u00edfico, como os pacotes BLAS e LAPACK.</p>"},{"location":"Fortran/Fortran_77/#blas","title":"BLAS","text":"<ul> <li>Acr\u00f4nimo de Basic Linear Algebra Subroutines.</li> <li>Cont\u00e9m subprogramas para opera\u00e7\u00f5es com vetores e matrizes.</li> <li>Suas rotinas s\u00e3o organizadas em tr\u00eas n\u00edveis:</li> <li>N\u00edvel 1: Opera\u00e7\u00f5es vetor x vetor.</li> <li>N\u00edvel 2: Opera\u00e7\u00f5es matriz x vetor.</li> <li>N\u00edvel 3: Opera\u00e7\u00f5es matriz x matriz.</li> <li>A primeira letra dos nomes dos subprogramas indica a precis\u00e3o:</li> <li>S: Real precis\u00e3o \u00fanica.</li> <li>D: Real precis\u00e3o dupla.</li> <li>C: Complexo precis\u00e3o \u00fanica.</li> <li>Z: Complexo precis\u00e3o dupla.</li> </ul>"},{"location":"Fortran/Fortran_77/#lapack","title":"LAPACK","text":"<ul> <li>Constru\u00eddo sobre BLAS, \u00e9 uma cole\u00e7\u00e3o para problemas avan\u00e7ados de \u00e1lgebra linear.</li> <li>Documenta\u00e7\u00e3o dispon\u00edvel em:</li> <li>LAPACK Home</li> <li>LAPACK User's Guide</li> <li>Ao instalar, coloque os arquivos <code>.lib</code> (no Windows) ou <code>.a</code> (no Linux) em um diret\u00f3rio apropriado. Certifique-se de ajustar os caminhos de compila\u00e7\u00e3o conforme necess\u00e1rio. O BLAS deve ser especificado por \u00faltimo no comando de compila\u00e7\u00e3o.</li> </ul> <p><pre><code>c234567\n      PROGRAM SolveLinearSystem\n      IMPLICIT NONE\n\n      INTEGER :: n, nrhs, lda, ldb, info\n      PARAMETER (n = 3, nrhs = 1, lda = n, ldb = n)\n\n      REAL :: A(lda, n), B(ldb, nrhs)\n      INTEGER :: ipiv(n)\n\n      EXTERNAL SGESV\n\n      DATA A / 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 10.0 /\n      DATA B / 6.0, 15.0, 25.0 /\n\n      PRINT *, 'Starting the linear system solver...'\n\n      CALL SGESV(n, nrhs, A, lda, ipiv, B, ldb, info)\n\n      PRINT *, 'SGESV call completed.'\n\n      IF (info .EQ. 0) THEN\n          PRINT *, 'The solution is:'\n          PRINT *, B\n      ELSE\n          PRINT *, 'An error occurred: info =', info\n      END IF\n\n      PRINT *, 'Program finished.'\n\n      STOP      \n      END\n</code></pre> Exemplo 10: Solu\u00e7\u00e3o de Sistema Linear</p> <p>Para compilar:</p> <p><pre><code>$ gfortran 10.solucao_linear.f -o 10.solucao_linear -LC:/msys64/mingw64/lib -llapack -lblas\n</code></pre> ou para openblas <pre><code>$ gfortran 10.solucao_linear.f -o 10.solucao_linear -LC:/msys64/mingw64/lib -lopenblas\n</code></pre></p> <p>Observa\u00e7\u00e3o: O diret\u00f3rio especificado ap\u00f3s <code>-LC:</code> deve conter as bibliotecas necess\u00e1rias. Lembre-se que se voc\u00ea for usar LAPACK, ele depende do BLAS, o qual deve ser listado por \u00faltimo no comando. No meu caso, optei por usar o Open_Blas porque as instala\u00e7\u00f5es dessas bibliotecas podem conflitar entre o uso no Microsoft Visual Studio e no MSYS2 caso esteja no Windows, esteja atento \u00e0 extens\u00e3o instalada na sua m\u00e1quina - Microsoft Studio usa .lib enquanto MinGW/gfortran usam .a / .dll.a.</p> <p>A maior complica\u00e7\u00e3o pode estar na depura\u00e7\u00e3o de erros relacionados a vers\u00f5es de DLLs e compatibilidade com a arquitetura da CPU. Em edi\u00e7\u00f5es futuras, abordaremos a constru\u00e7\u00e3o de pacotes e a compila\u00e7\u00e3o de vers\u00f5es espec\u00edficas da BLAS ou LAPACK para sua m\u00e1quina.</p>"},{"location":"Fortran/Fortran_77/#boas-praticas-e-problemas-comuns","title":"Boas Pr\u00e1ticas e Problemas Comuns","text":""},{"location":"Fortran/Fortran_77/#boas-praticas_1","title":"Boas Pr\u00e1ticas","text":""},{"location":"Fortran/Fortran_77/#1-estrutura-do-programa","title":"1. Estrutura do Programa","text":"<pre><code>c234567\n      PROGRAM NOME_PROGRAMA\n      IMPLICIT NONE\n\n      ! Declara\u00e7\u00f5es de vari\u00e1veis\n      INTEGER I, J, K\n      REAL X, Y, Z\n\n      ! Declara\u00e7\u00f5es de par\u00e2metros\n      PARAMETER (PI = 3.14159)\n\n      ! Inicializa\u00e7\u00f5es\n      DATA X /0.0/, Y /0.0/\n\n      ! Corpo principal do programa\n      ...\n\n      STOP\n      END\n</code></pre>"},{"location":"Fortran/Fortran_77/#2-nomenclatura","title":"2. Nomenclatura","text":"<ul> <li>Use nomes descritivos (dentro do limite de 6 caracteres)</li> <li>Use mai\u00fasculas para constantes: <code>PI</code>, <code>MAXSIZ</code></li> <li>Use min\u00fasculas para vari\u00e1veis: <code>i</code>, <code>j</code>, <code>x</code>, <code>y</code></li> <li>Evite nomes muito similares: <code>i</code>, <code>l</code>, <code>1</code> podem ser confusos</li> </ul>"},{"location":"Fortran/Fortran_77/#3-comentarios","title":"3. Coment\u00e1rios","text":"<pre><code>c234567\n      ! Este \u00e9 um coment\u00e1rio moderno (Fortran 90+)\nc     Este \u00e9 um coment\u00e1rio Fortran 77\n*     Este tamb\u00e9m \u00e9 um coment\u00e1rio Fortran 77\n</code></pre>"},{"location":"Fortran/Fortran_77/#4-formatacao","title":"4. Formata\u00e7\u00e3o","text":"<ul> <li>Sempre use <code>IMPLICIT NONE</code></li> <li>Mantenha c\u00f3digo nas colunas 7-72</li> <li>Use indenta\u00e7\u00e3o consistente</li> <li>Agrupe declara\u00e7\u00f5es relacionadas</li> </ul>"},{"location":"Fortran/Fortran_77/#problemas-comuns-e-solucoes","title":"Problemas Comuns e Solu\u00e7\u00f5es","text":""},{"location":"Fortran/Fortran_77/#1-erros-de-compilacao","title":"1. Erros de Compila\u00e7\u00e3o","text":"<p>Problema: <code>Error: Unexpected end of file</code> <pre><code>      PROGRAM TESTE\n      IMPLICIT NONE\n      INTEGER I\n      I = 1\n      ! Falta STOP e END\n</code></pre> Solu\u00e7\u00e3o: Sempre inclua <code>STOP</code> e <code>END</code> no final do programa.</p> <p>Problema: <code>Error: Variable 'X' is used but not declared</code> <pre><code>      PROGRAM TESTE\n      IMPLICIT NONE\n      REAL Y\n      X = 1.0  ! X n\u00e3o foi declarado\n</code></pre> Solu\u00e7\u00e3o: Declare todas as vari\u00e1veis ou remova <code>IMPLICIT NONE</code>.</p>"},{"location":"Fortran/Fortran_77/#2-erros-de-execucao","title":"2. Erros de Execu\u00e7\u00e3o","text":"<p>Problema: <code>Floating point exception</code> <pre><code>      REAL X, Y\n      X = 1.0\n      Y = 0.0\n      X = X / Y  ! Divis\u00e3o por zero\n</code></pre> Solu\u00e7\u00e3o: Sempre verifique divisores antes da divis\u00e3o.</p> <p>Problema: <code>Array bounds exceeded</code> <pre><code>      INTEGER A(5)\n      DO I = 1, 10  ! I vai de 1 a 10, mas A s\u00f3 tem 5 elementos\n          A(I) = I\n      END DO\n</code></pre> Solu\u00e7\u00e3o: Verifique sempre os limites dos arrays.</p>"},{"location":"Fortran/Fortran_77/#3-problemas-de-logica","title":"3. Problemas de L\u00f3gica","text":"<p>Problema: Compara\u00e7\u00e3o de n\u00fameros reais <pre><code>      REAL X, Y\n      X = 0.1\n      Y = 0.1\n      IF (X .EQ. Y) THEN  ! Pode falhar devido \u00e0 precis\u00e3o\n</code></pre> Solu\u00e7\u00e3o: Use toler\u00e2ncia para compara\u00e7\u00f5es de n\u00fameros reais. <pre><code>      REAL X, Y, TOL\n      PARAMETER (TOL = 1.0E-6)\n      IF (ABS(X - Y) .LT. TOL) THEN\n</code></pre></p> <p>Problema: Loop infinito <pre><code>      I = 1\n10    IF (I .LT. 10) THEN\n          PRINT *, I\n          ! Falta incrementar I\n          GOTO 10\n      END IF\n</code></pre> Solu\u00e7\u00e3o: Sempre incremente a vari\u00e1vel de controle do loop.</p>"},{"location":"Fortran/Fortran_77/#dicas-de-debugging","title":"Dicas de Debugging","text":""},{"location":"Fortran/Fortran_77/#1-usando-print-para-debug","title":"1. Usando PRINT para Debug","text":"<pre><code>      ! Adicione prints estrat\u00e9gicos\n      PRINT *, 'Valor de X antes do loop:', X\n      DO I = 1, N\n          X = X + I\n          IF (MOD(I, 100) .EQ. 0) THEN\n              PRINT *, 'Itera\u00e7\u00e3o', I, 'X =', X\n          END IF\n      END DO\n      PRINT *, 'Valor de X ap\u00f3s o loop:', X\n</code></pre>"},{"location":"Fortran/Fortran_77/#2-verificacao-de-bounds","title":"2. Verifica\u00e7\u00e3o de Bounds","text":"<pre><code>      ! Sempre verifique limites antes de usar arrays\n      IF (I .LT. 1 .OR. I .GT. N) THEN\n          PRINT *, 'Erro: \u00cdndice', I, 'fora dos limites 1-', N\n          STOP\n      END IF\n      A(I) = VALOR\n</code></pre>"},{"location":"Fortran/Fortran_77/#3-validacao-de-entrada","title":"3. Valida\u00e7\u00e3o de Entrada","text":"<pre><code>      ! Valide sempre a entrada do usu\u00e1rio\n      READ *, N\n      IF (N .LE. 0 .OR. N .GT. MAXSIZ) THEN\n          PRINT *, 'Erro: N deve estar entre 1 e', MAXSIZ\n          STOP\n      END IF\n</code></pre>"},{"location":"Fortran/Fortran_77/#performance-e-otimizacao","title":"Performance e Otimiza\u00e7\u00e3o","text":""},{"location":"Fortran/Fortran_77/#1-acesso-a-arrays","title":"1. Acesso a Arrays","text":"<pre><code>      ! \u274c Ruim: Acessa em ordem incorreta\n      DO I = 1, N\n          DO J = 1, M\n              A(J, I) = A(J, I) + 1  ! Segunda dimens\u00e3o varia primeiro\n          END DO\n      END DO\n\n      ! \u2705 Bom: Acessa em ordem de mem\u00f3ria\n      DO J = 1, M\n          DO I = 1, N\n              A(J, I) = A(J, I) + 1  ! Primeira dimens\u00e3o varia primeiro\n          END DO\n      END DO\n</code></pre>"},{"location":"Fortran/Fortran_77/#2-evite-operacoes-desnecessarias","title":"2. Evite Opera\u00e7\u00f5es Desnecess\u00e1rias","text":"<pre><code>      ! \u274c Ruim: Calcula pot\u00eancia repetidamente\n      DO I = 1, N\n          Y = X**2  ! Calcula X^2 N vezes\n      END DO\n\n      ! \u2705 Bom: Calcula uma vez\n      X2 = X**2\n      DO I = 1, N\n          Y = X2\n      END DO\n</code></pre>"},{"location":"Fortran/Fortran_77/#checklist-de-qualidade","title":"Checklist de Qualidade","text":"<p>Antes de considerar seu programa finalizado, verifique:</p> <ul> <li>[ ] Todas as vari\u00e1veis est\u00e3o declaradas</li> <li>[ ] <code>IMPLICIT NONE</code> est\u00e1 presente</li> <li>[ ] <code>STOP</code> e <code>END</code> est\u00e3o no final</li> <li>[ ] C\u00f3digo est\u00e1 nas colunas 7-72</li> <li>[ ] Arrays n\u00e3o excedem limites</li> <li>[ ] Divis\u00f5es por zero est\u00e3o protegidas</li> <li>[ ] Loops t\u00eam condi\u00e7\u00e3o de parada</li> <li>[ ] Coment\u00e1rios explicam l\u00f3gica complexa</li> <li>[ ] Nomes de vari\u00e1veis s\u00e3o descritivos</li> <li>[ ] Programa foi testado com diferentes entradas</li> </ul>"},{"location":"Fortran/Fortran_77/#exercicios-sugeridos","title":"Exerc\u00edcios Sugeridos","text":""},{"location":"Fortran/Fortran_77/#exercicios-basicos","title":"Exerc\u00edcios B\u00e1sicos","text":""},{"location":"Fortran/Fortran_77/#exercicio-1-calculadora-simples","title":"Exerc\u00edcio 1: Calculadora Simples","text":"<p>Escreva um programa que leia dois n\u00fameros e uma opera\u00e7\u00e3o (+, -, *, /) e calcule o resultado.</p>"},{"location":"Fortran/Fortran_77/#exercicio-2-media-de-notas","title":"Exerc\u00edcio 2: M\u00e9dia de Notas","text":"<p>Escreva um programa que leia 5 notas de um aluno e calcule a m\u00e9dia.</p>"},{"location":"Fortran/Fortran_77/#exercicio-3-fatorial","title":"Exerc\u00edcio 3: Fatorial","text":"<p>Escreva uma fun\u00e7\u00e3o que calcule o fatorial de um n\u00famero inteiro.</p>"},{"location":"Fortran/Fortran_77/#exercicios-intermediarios","title":"Exerc\u00edcios Intermedi\u00e1rios","text":""},{"location":"Fortran/Fortran_77/#exercicio-4-matriz-transposta","title":"Exerc\u00edcio 4: Matriz Transposta","text":"<p>Escreva um programa que leia uma matriz 3x3 e calcule sua transposta.</p>"},{"location":"Fortran/Fortran_77/#exercicio-5-busca-binaria","title":"Exerc\u00edcio 5: Busca Bin\u00e1ria","text":"<p>Implemente o algoritmo de busca bin\u00e1ria para encontrar um elemento em um array ordenado.</p>"},{"location":"Fortran/Fortran_77/#exercicio-6-ordenacao-por-selecao","title":"Exerc\u00edcio 6: Ordena\u00e7\u00e3o por Sele\u00e7\u00e3o","text":"<p>Implemente o algoritmo de ordena\u00e7\u00e3o por sele\u00e7\u00e3o.</p>"},{"location":"Fortran/Fortran_77/#exercicios-avancados","title":"Exerc\u00edcios Avan\u00e7ados","text":""},{"location":"Fortran/Fortran_77/#exercicio-7-sistema-de-equacoes-lineares","title":"Exerc\u00edcio 7: Sistema de Equa\u00e7\u00f5es Lineares","text":"<p>Escreva um programa que resolva um sistema de 3 equa\u00e7\u00f5es lineares usando o m\u00e9todo de Gauss.</p>"},{"location":"Fortran/Fortran_77/#exercicio-8-integracao-numerica","title":"Exerc\u00edcio 8: Integra\u00e7\u00e3o Num\u00e9rica","text":"<p>Implemente a regra do trap\u00e9zio para calcular a integral de uma fun\u00e7\u00e3o.</p>"},{"location":"Fortran/Fortran_77/#exercicio-9-processamento-de-arquivos","title":"Exerc\u00edcio 9: Processamento de Arquivos","text":"<p>Escreva um programa que leia um arquivo de texto e conte o n\u00famero de palavras, linhas e caracteres.</p>"},{"location":"Fortran/Fortran_77/#material-deste-guia","title":"Material deste guia","text":""},{"location":"Fortran/Fortran_77/#diretorio-de-exemplos","title":"Diret\u00f3rio de Exemplos","text":"<p>Este guia possui um diret\u00f3rio <code>f77_examples/</code> contendo todos os exemplos pr\u00e1ticos mencionados ao longo do texto. Cada exemplo est\u00e1 organizado em arquivos separados para facilitar o estudo e pr\u00e1tica.</p>"},{"location":"Fortran/Fortran_77/#estrutura-do-diretorio","title":"Estrutura do Diret\u00f3rio","text":"<pre><code>f77_examples/\n\u251c\u2500\u2500 1.hello_world.f          # Exemplo b\u00e1sico de Hello World\n\u251c\u2500\u2500 2.tipagem.f              # Demonstra\u00e7\u00e3o de tipos de dados\n\u251c\u2500\u2500 3.cadastro.f             # Exemplo de condicionais\n\u251c\u2500\u2500 4.1.loop.f               # Loops b\u00e1sicos\n\u251c\u2500\u2500 4.2.whiledo.f            # Loops while\n\u251c\u2500\u2500 4.3.untildo.f            # Loops until\n\u251c\u2500\u2500 5.1.quadrado.f           # Fun\u00e7\u00f5es\n\u251c\u2500\u2500 5.2.quad_cubo.f          # Subrotinas\n\u251c\u2500\u2500 6.1.array_basico.f       # Arrays b\u00e1sicos\n\u251c\u2500\u2500 6.2.array_soma.f         # Opera\u00e7\u00f5es com arrays\n\u251c\u2500\u2500 6.3.array_produto.f      # Produto de elementos\n\u251c\u2500\u2500 7.1.inicializacao.f      # Inicializa\u00e7\u00e3o com DATA\n\u251c\u2500\u2500 7.2.inicializacao_alt.f  # Inicializa\u00e7\u00e3o alternativa\n\u251c\u2500\u2500 7.3.inicializacao_matricial.f  # Inicializa\u00e7\u00e3o de matrizes\n\u251c\u2500\u2500 8.IO.f                   # Entrada e sa\u00edda de arquivos\n\u251c\u2500\u2500 9.format.f               # Formata\u00e7\u00e3o de sa\u00edda\n\u251c\u2500\u2500 10.solucao_linear.f      # Exemplo com bibliotecas (LAPACK)\n\u251c\u2500\u2500 points.dat               # Arquivo de dados para exemplo 8\n\u2514\u2500\u2500 Makefile                 # Script de compila\u00e7\u00e3o autom\u00e1tica\n</code></pre>"},{"location":"Fortran/Fortran_77/#makefile-para-compilacao-rapida","title":"Makefile para Compila\u00e7\u00e3o R\u00e1pida","text":"<p>O diret\u00f3rio inclui um <code>Makefile</code> que facilita a compila\u00e7\u00e3o e execu\u00e7\u00e3o dos exemplos. Este arquivo automatiza o processo de compila\u00e7\u00e3o, evitando a necessidade de digitar comandos longos manualmente.</p>"},{"location":"Fortran/Fortran_77/#comandos-disponiveis","title":"Comandos Dispon\u00edveis","text":"<pre><code># Compilar todos os exemplos\nmake \n\n# Compilar um exemplo espec\u00edfico\nmake 1.hello_world\nmake 2.tipagem\nmake 3.cadastro\n\n# Executar um exemplo espec\u00edfico\nmake run-1.hello_world\nmake run-2.tipagem\n\n# Limpar arquivos compilados\nmake clean\n\n# Listar todos os exemplos dispon\u00edveis\nmake list\n</code></pre>"},{"location":"Fortran/Fortran_77/#como-usar","title":"Como Usar","text":"<ol> <li> <p>Navegue at\u00e9 o diret\u00f3rio de exemplos: <pre><code>cd f77_examples/\n</code></pre></p> </li> <li> <p>Compile todos os exemplos: <pre><code>make \n</code></pre></p> </li> <li> <p>Execute um exemplo espec\u00edfico: <pre><code>make run-1.hello_world\n</code></pre></p> </li> <li> <p>Para exemplos que requerem bibliotecas externas (como o exemplo 10): <pre><code>make 10.solucao_linear\n</code></pre></p> </li> </ol>"},{"location":"Fortran/Fortran_77/#sugestoes-de-uso","title":"Sugest\u00f5es de Uso","text":"<ol> <li>Estudo Sequencial: Execute os exemplos na ordem num\u00e9rica para seguir a progress\u00e3o do guia</li> <li>Experimenta\u00e7\u00e3o: Modifique os exemplos para testar diferentes cen\u00e1rios</li> <li>Debugging: Use o Makefile para recompilar rapidamente ap\u00f3s modifica\u00e7\u00f5es</li> <li>Compara\u00e7\u00e3o: Execute exemplos similares para ver as diferen\u00e7as na pr\u00e1tica</li> </ol>"},{"location":"Fortran/Fortran_77/#requisitos","title":"Requisitos","text":"<ul> <li>Compilador Fortran (gfortran recomendado)</li> <li>Make (geralmente j\u00e1 instalado em sistemas Unix/Linux)</li> <li>Para o exemplo 10: bibliotecas LAPACK/BLAS (opcional)</li> </ul> <p>Use o Makefile como ponto de partida para seus pr\u00f3prios projetos. Ele \u00e9 boa pr\u00e1ticas de organiza\u00e7\u00e3o e automa\u00e7\u00e3o.</p>"},{"location":"Fortran/Fortran_77/#recursos-adicionais","title":"Recursos Adicionais","text":""},{"location":"Fortran/Fortran_77/#compiladores-gratuitos","title":"Compiladores Gratuitos","text":"<ul> <li>gfortran: Compilador GNU para Fortran (recomendado)</li> <li>Download: GNU Fortran</li> <li> <p>Dispon\u00edvel para Windows, Linux e macOS</p> </li> <li> <p>Intel Fortran: Vers\u00e3o gratuita para estudantes</p> </li> <li>Download: Intel OneAPI</li> </ul>"},{"location":"Fortran/Fortran_77/#livros-recomendados","title":"Livros Recomendados","text":"<ol> <li>\"Fortran 77 for Engineers and Scientists\" - Larry Nyhoff</li> <li>\"Introduction to Fortran 77\" - Ian Chivers</li> <li>\"Fortran 77: Reference Manual\" - Sun Microsystems</li> </ol>"},{"location":"Fortran/Fortran_77/#links-uteis","title":"Links \u00dateis","text":"<ul> <li>Fortran Wiki</li> <li>Netlib - Biblioteca de rotinas matem\u00e1ticas</li> <li>Fortran Standards - Padr\u00f5es oficiais</li> </ul>"},{"location":"Fortran/Fortran_77/#ferramentas-de-desenvolvimento","title":"Ferramentas de Desenvolvimento","text":"<ul> <li>Visual Studio Code com extens\u00e3o Fortran</li> <li>Eclipse com plugin Photran</li> <li>Emacs com modo Fortran</li> </ul>"},{"location":"Fortran/Fortran_77/#comunidades-online","title":"Comunidades Online","text":"<ul> <li>Stack Overflow - Fortran</li> <li>Reddit r/fortran</li> <li>Fortran Discourse</li> </ul>"},{"location":"Fortran/Fortran_77/#proximos-passos","title":"Pr\u00f3ximos Passos","text":"<p>Ap\u00f3s dominar Fortran 77, considere aprender:</p> <ol> <li>Fortran 90/95: Recursos modernos como aloca\u00e7\u00e3o din\u00e2mica</li> <li>Fortran 2003/2008: Programa\u00e7\u00e3o orientada a objetos</li> <li>Fortran 2018: Recursos mais recentes</li> </ol>"},{"location":"Fortran/Fortran_77/#troubleshooting-comum","title":"Troubleshooting Comum","text":"Problema Causa Solu\u00e7\u00e3o Erro de formata\u00e7\u00e3o C\u00f3digo fora das colunas 7-72 Verificar indenta\u00e7\u00e3o Vari\u00e1vel n\u00e3o declarada Falta <code>IMPLICIT NONE</code> Adicionar declara\u00e7\u00e3o expl\u00edcita Erro de compila\u00e7\u00e3o Sintaxe moderna Usar apenas sintaxe F77 Erro de execu\u00e7\u00e3o \u00cdndice fora dos limites Verificar limites de arrays <p>Nota: Este guia cobre os fundamentos do Fortran 77. Para projetos modernos, considere usar vers\u00f5es mais recentes do Fortran que oferecem recursos mais avan\u00e7ados e melhor seguran\u00e7a de tipos.</p>"},{"location":"Fortran/Fortran_90/","title":"Cap\u00edtulo 1 - Introdu\u00e7\u00e3o","text":"<p>Neste cap\u00edtulo visamos apresentar a linguagem Fortran (na vers\u00e3o Fortran 90) do zero, supondo pouca familiaridade com programa\u00e7\u00e3o, mas algum conhecimento de m\u00e9todos num\u00e9ricos (n\u00e3o s\u00e3o obrigat\u00f3rios, mas ser\u00e3o de grande ajuda para a compreens\u00e3o de algumas motiva\u00e7\u00f5es e exemplos). Ao longo deste cap\u00edtulo vamos introduzir os conhecimentos necess\u00e1rios para construirmos um dos m\u00e9todos num\u00e9ricos mais simples e cl\u00e1ssicos: o M\u00e9todo da Bisse\u00e7\u00e3o. E, para al\u00e9m de introduzirmos o ferramental, vamos construir um c\u00f3digo para este m\u00e9todo ao longo das se\u00e7\u00f5es, de forma que ao final do cap\u00edtulo teremos uma implementa\u00e7\u00e3o funcional do m\u00e9todo em Fortran.</p>"},{"location":"Fortran/Fortran_90/#caracteristicas-da-linguagem","title":"Caracter\u00edsticas da linguagem","text":"<p>Do ingl\u00eas, FORmula TRANslation system, a linguagem FORTRAN foi um avan\u00e7o nas d\u00e9cadas de 60 e 70 na programa\u00e7\u00e3o de computadores. Antes dela, o paradigma principal de codifica\u00e7\u00e3o dos programas de computador era escrev\u00ea-loss diretamente em  linguagem de montagem (Assembly), instru\u00e7\u00f5es que eram compreendidas de forma praticamente direta pelos computadores. Por\u00e9m para n\u00f3s humanos (que n\u00e3o somos computadores) \u00e9 muito dif\u00edcil e pouco transparente escrever fluxos e algoritmos t\u00e3o pr\u00f3ximos do metal. Visando incorporar abstra\u00e7\u00f5es que facilitariam a vida dos programadores, Foi criado o FORTRAN. </p> <p>Nessa metade final do s\u00e9culo XX, o surgimento do computador veio como ferramenta de c\u00e1lculo para auxiliar na execu\u00e7\u00e3o de m\u00e9todos sofisticados e muito extensos que eram utilizados nos contextos da \u00e9poca, principalmente de guerra, engenharia, etc. Isso influenciou fortemente a maneira que a linguagem FORTRAN foi constru\u00edda: pensada para fazer computa\u00e7\u00e3o cient\u00edfica, e acelerar o progresso nestas \u00e1reas; e tem impactos que reverberam at\u00e9 as vers\u00f5es mais modernas da linguagem, devido a este processo hist\u00f3rico.</p> <p>Algumas das filosofias principais da linguagem s\u00e3o:</p> <ul> <li>Ser estrita e eficiente para o que ela foi pensada</li> </ul> <p>O que explica a grande quantidade de bibliotecas extremamente otimizadas para \u00e1lgebra linear, implementa\u00e7\u00e3o nativa de estruturas importantes da matem\u00e1tica a n\u00edvel de  engenharia como n\u00fameros complexos, arrays multi-dimensionais e especifica\u00e7\u00e3o de precis\u00e3o num\u00e9rica, e aus\u00eancia de estruturas comuns em linguagens de prop\u00f3sito geral (como recursividade e ponteiros, at\u00e9 a d\u00e9cada de 90)</p> <ul> <li>Ser est\u00e1vel e retrocompat\u00edvel</li> </ul> <p>Muito tempo e esfor\u00e7o j\u00e1 foi colocado para construir programas robustos e de alta complexidade quando FORTRAN foi amplamente adotado pela comunidade cient\u00edfica: simula\u00e7\u00f5es, implementa\u00e7\u00f5es de  algoritmos para resolu\u00e7\u00e3o de in\u00fameros problemas n\u00e3o-lineares, etc. Para que nenhum destes projetos se perdessem durante as atualiza\u00e7\u00f5es da linguagem, FORTRAN \u00e9 extremamente retrocompat\u00edvel, de forma que todos os principais compiladores desenvolvidos at\u00e9 hoje s\u00e3o capazes de compilar programas  escritos na d\u00e9cada de 70 sem alter\u00e1-los em 1 linha de c\u00f3digo (o que n\u00e3o ocorre, por exemplo, com Python 2 vs Python 3). </p> <p>E para tamb\u00e9m certificar que os programas desenvolvidos sejam dur\u00e1veis e pouco sucet\u00edveis a erros num\u00e9ricos (j\u00e1 que isso pode ser fatal numa engenharia naval, aeroespacial e afins), o compilador \u00e9 muito rigoroso quanto ao uso das estruturas da linguagem, e n\u00e3o d\u00e1 muito espa\u00e7o para implementa\u00e7\u00f5es ex\u00f3ticas e imprevis\u00edveis (diferente da linguagem C, por exemplo). O design da sintaxe da linguagem segue esta mesma l\u00f3gica.</p>"},{"location":"Fortran/Fortran_90/#comparativo-fortran-77-fixed-form-vs-fortran-90-free-form","title":"Comparativo: FORTRAN 77 (fixed-form) vs FORTRAN 90 (free-form)","text":"<p>At\u00e9 sua vers\u00e3o 77, FORTRAN rodava principalmente nos grandes centros de computa\u00e7\u00e3o mantidos pelas universidades e pelo governo dos Estados Unidos. Estas m\u00e1quinas comumente utilizavam cart\u00f5es perfurados como forma de lerem e carregarem os programas desenvolvidos para a mem\u00f3ria, como este da foto abaixo</p> <p></p> <p>Devido a isso, a sintaxe do FORTRAN 77 \u00e9 conhecida como sendo de forma fixa, pois existe uma quantidade limite de caracteres por linha, al\u00e9m de um des\u00edgnio especial para cada faixa de caracteres na coluna.  Voc\u00ea pode consultar mais detalhes em nossa p\u00e1gina de FORTRAN77.</p> <p>Como voc\u00ea deve imaginar, isto n\u00e3o \u00e9 nada pr\u00e1tico nos moldes atuais (e j\u00e1 na \u00e9poca era problem\u00e1tico). Para endere\u00e7ar este e alguns outros problemas, na vers\u00e3o FORTRAN 90 adotou-se uma sintaxe diferente, a de forma livre. Nesta, removeu-se a limita\u00e7\u00e3o de colunas, aumentou-se a quantidade de caracteres permitido nos nomes das vari\u00e1veis e das fun\u00e7\u00f5es, coment\u00e1rios podem ser feitos em qualquer trecho do c\u00f3digo utilizando <code>!</code>, dentre muitas outras conven\u00e7\u00f5es de programa\u00e7\u00e3o que foram criadas com o aumento em popularidade das linguagens C e Pascal, al\u00e9m da reformula\u00e7\u00e3o das estruturas f\u00edsicas dos computadores (telas, teclados, disquetes, sistemas operacionais, etc).</p> <p>Nesta p\u00e1gina, iremos trabalhar com o padr\u00e3o FORTRAN 90. Vamos come\u00e7ar preparando o ambiente de  execu\u00e7\u00e3o dos nossos programas em Fortran.</p>"},{"location":"Fortran/Fortran_90/#topico-1-compilacao-arquivo-fonte-e-arquivo-executavel","title":"T\u00f3pico 1: Compila\u00e7\u00e3o, arquivo fonte e arquivo execut\u00e1vel","text":"<p>Antes de come\u00e7armos a programar, vamos aprender a como fazer um programa em Fortran ser executado. Vamos come\u00e7ar definindo alguns termos:</p> <ul> <li>C\u00f3digo-fonte: O c\u00f3digo fonte \u00e9 o arquivo escrito na linguagem de   programa\u00e7\u00e3o (no nosso cado, em Fortran). Ele cont\u00e9m as instru\u00e7\u00f5es   do programa, por\u00e9m o computador n\u00e3o sabe executar estes aquivos.   Utilizaremos a extens\u00e3o \".f90\" nos nossos arquivos. OBS: programas   escritos em FORTRAN 77 normalmente utilizam a extens\u00e3o \".f\". Segue   um exemplo de c\u00f3digo-fonte:</li> </ul> <pre><code>program cilindro\n! Calcula a \u00e1rea de um cilindro.\n!\n! Declara as vari\u00e1veis e constantes.\nimplicit none ! Requer que todas as vari\u00e1veis sejam declaradas\ninteger :: ierr\nreal :: raio,altura,area\nreal , parameter :: pi = 3.14159\ndo\n   ! Pergunta ao usu\u00e1rio o raio e a altura e l\u00ea os valores.\n   write (*,*) \"Entre com o raio e a altura, 'q' para sair.\"\n   read (*,*,iostat=ierr) raio,altura\n   !\n   ! Se o raio e a altura n\u00e3o puderam ser lidos da entrada, termina o programa.\n   if (ierr /= 0) stop \"finalizando o programa\"\n   !\n   ! Calcula a \u00e1rea. O sinal ** significa \"eleva a uma pot\u00eancia\".\n   area = 2*pi*(raio**2 + raio*altura)\n   !\n   ! Escreve as vari\u00e1veis de entrada (raio, altura) e a saida (\u00e1rea) na tela.\n   write (*,\"(1x,'raio=',f6.2,5x,'altura=',f6.2,5x,'area=',f6.2)\") raio,altura,area\nend do\nend program cilindro\n</code></pre> <ul> <li> <p>Compilador: O compilador \u00e9 o programa respons\u00e1vel por traduzir   as instru\u00e7\u00f5es do nosso c\u00f3digo-fonte para instru\u00e7\u00f5es que o   computador sabe executar. Este programa recebe como entrada o   c\u00f3digo-fonte, e gera um arquivo execut\u00e1vel como sa\u00edda. Utilizaremos   o compilador \"gfortran\".</p> </li> <li> <p>Arquivo execut\u00e1vel: O arquivo execut\u00e1vel \u00e9 o arquivo que,   efetivamente, ir\u00e1 rodar no computador, executando nosso programa.   Este arquivo n\u00e3o \u00e9 leg\u00edvel para n\u00f3s, humanos, e por isso usamos as   abstra\u00e7\u00f5es de uma linguagem de programa\u00e7\u00e3o. Veja o que ocorre ao   tentarmos abrir um arquivo bin\u00e1rio com um leitor de texto:</p> </li> </ul> <p></p> <p>Entendidos estes conceitos b\u00e1sicos, vamos fazer os 3 passos principais  para sairmos de um c\u00f3digo fonte a um bin\u00e1rio execut\u00e1vel:</p>"},{"location":"Fortran/Fortran_90/#como-instalar-um-compilador-gfortran","title":"Como instalar um compilador (gfortran)","text":"<p>instru\u00e7\u00f5es de instala\u00e7\u00e3o em ingl\u00eas</p>"},{"location":"Fortran/Fortran_90/#como-compilar-um-codigo-fonte-utilizando-o-compilador","title":"Como compilar um c\u00f3digo-fonte utilizando o compilador","text":"<p>Instalado o compilador, e com o arquivo execut\u00e1vel em m\u00e3os, podemos compilar o arquivo com:</p> <pre><code>gfortran &lt;nome do arquivo&gt; -o &lt;nome de sa\u00edda do arquivo&gt;\n</code></pre> <p>Se salv\u00e1ssemos o programa acima, que calcula a \u00e1rea de um cilindro, como \"cilindro.f90\", poder\u00edamos fazer:</p> <pre><code>gfortran cilindro.90 -o cilindro\n</code></pre> <p>E ter\u00edamos um arquivo bin\u00e1rio chamado <code>cilindro</code> para executar no Linux.  A depender do sistema, este arquivo talvez precise receber uma extens\u00e3o  espec\u00edfica, como <code>.exe</code> para execut\u00e1veis em Windows.</p>"},{"location":"Fortran/Fortran_90/#flags-de-compilacao","title":"Flags de Compila\u00e7\u00e3o","text":""},{"location":"Fortran/Fortran_90/#executando-o-arquivo-executavel-gerado-pela-compilacao","title":"Executando o arquivo execut\u00e1vel gerado pela compila\u00e7\u00e3o","text":"<p>Para executar um bin\u00e1rio, fazemos</p> <pre><code>./&lt;nome do binario&gt;\n</code></pre> <p>Do nosso exemplo anterior:</p> <pre><code>./cilindro\n</code></pre> <p>E temos uma poss\u00edvel execu\u00e7\u00e3o:</p> <pre><code> Entre com o raio e a altura, 'q' para sair.\n1\n2\n raio=  1.00     altura=  2.00     area= 18.85\n Entre com o raio e a altura, 'q' para sair.\nq\nSTOP finalizando o programa\n</code></pre>"},{"location":"Fortran/Fortran_90/#topico-2-estrutura-basica-de-um-programa-print-simples-variaveis-e-operacoes-basicas","title":"T\u00f3pico 2: Estrutura b\u00e1sica de um programa, print simples, vari\u00e1veis e opera\u00e7\u00f5es b\u00e1sicas.","text":"<p>Para come\u00e7armos a escrever um programa em Fortran, basta criarmos um arquivo novo em branco, e salv\u00e1-lo com a extens\u00e3o \".f90\".</p> <p>Todo programa v\u00e1lido em Fortran precisa ter um bloco \"program\", com o nome do programa. Dentro deste bloco, temos nosso c\u00f3digo principal a ser executado. Vamos iniciar fazendo um programa cl\u00e1ssico ao come\u00e7armos a aprender uma nova linguagem de programa\u00e7\u00e3o: Um programa que mostra \"Ol\u00e1 mundo!\" (ou \"Hello world!\") na tela e termina sua execu\u00e7\u00e3o.</p> <pre><code>    program exemplo\n        print *, 'Ol\u00e1 mundo!'\n    end program exemplo\n</code></pre> <p>Compilando e executando este programa, o programa imprime na tela \"Ol\u00e1 mundo\" e termina. O nome que segue a palavra chave <code>program</code> \u00e9 o nome do programa, e o bloco \u00e9 terminado por <code>end program</code>.</p> <p>O comando <code>print</code> utiliza um primeiro argumento, que \u00e9 a formata\u00e7\u00e3o, e em seguidas as informa\u00e7\u00f5es a serem mostradas. Como n\u00e3o queremos nenhuma formata\u00e7\u00e3o espec\u00edfica para nossos dados, usamos <code>*</code> como primeiro argumento, e em seguida a string <code>\"Ol\u00e1 mundo!\"</code>.</p>"},{"location":"Fortran/Fortran_90/#topico-21-variaveis","title":"T\u00f3pico 2.1: Vari\u00e1veis","text":"<p>Um dos conceitos mais b\u00e1sicos de programa\u00e7\u00e3o s\u00e3o as vari\u00e1veis. Elas s\u00e3o \u00e1reas de mem\u00f3ria que guardam algum valor. Fortran \u00e9 uma linguagem fortemente tipada, ou seja, para declaramos e usarmos uma vari\u00e1vel precisamos, primeiro, indicar qual o tipo dessa vari\u00e1vel (diferente de Python, por exemplo, que \u00e9 fracamente tipada). Nativamente, existem 5 tipos de vari\u00e1veis em Fortran:</p> <ul> <li><code>integer</code> - para valores inteiros, positivos ou   negativos</li> <li><code>real</code> - para valores em ponto-flutuante (n\u00fameros   fracion\u00e1rios)</li> <li><code>complex</code> - para valores complexos, consistindo de   uma parte real e uma parte imagin\u00e1ria</li> <li><code>character</code> - para texto em geral</li> <li><code>logical</code> - para valores verdade (verdadeiro ou   falso)</li> </ul> <p>Para declaramos uma vari\u00e1vel usamos a sintaxe <code>tipo :: nome</code> , onde <code>tipo</code> \u00e9 o tipo da vari\u00e1vel e <code>nome</code> \u00e9 o nome da vari\u00e1vel. Por exemplo, se quisermos declarar 2 vari\u00e1veis reais <code>x</code> e <code>y</code>, fazemos:</p> <pre><code>    real :: x\n    real :: y\n</code></pre> <p>Nomes de vari\u00e1vel precisam come\u00e7ar por uma letra, e podem ter letras, n\u00fameros e underscores \" <code>_</code>\". N\u00e3o s\u00e3o aceitos caracteres pontuados como \"\u00e9\", \"\u00e3\", \"\u00f3\", etc.</p> <p>Vari\u00e1veis do tipo <code>logical</code> trabalham com os valores <code>.true.</code> e <code>.false.</code> . Alguns compiladores podem permitir convers\u00e3o impl\u00edcita de valores inteiros para l\u00f3gico (i.e. assumir que 0 \u00e9 falso e qualquer n\u00famero inteiro diferente de 0 \u00e9 verdadeiro), mas esse comportamento n\u00e3o \u00e9 o padr\u00e3o da linguagem, n\u00e3o conte sempre com ele, e evite sempre que poss\u00edvel.</p> <p>Exemplos de declara\u00e7\u00e3o de vari\u00e1veis para cada tipo:</p> <pre><code>    program variaveis\n        implicit none\n\n        integer :: i\n        real :: distancia\n        complex :: frequencia\n        character :: inicial\n        logical :: eh_primo\n\n        i = 1\n        distancia = 1.41421356\n        frequencia = (1.0, -0.5)\n        inicial = \"f\"\n        eh_primo = .false.\n    end program variaveis\n</code></pre> <p>Por padr\u00e3o, utilizamos letras min\u00fasculas ao programar, mas a linguagem n\u00e3o \u00e9 sens\u00edvel a CaPiTaLiZa\u00c7\u00e3O, ent\u00e3o mai\u00fasculas e min\u00fasculas podem ser usadas para os tipos e nomes. Por\u00e9m, por quest\u00f5es de organiza\u00e7\u00e3o do c\u00f3digo, seja consistente quanto a isso ao longo do programa.</p> <p>Perceba que a primeira instru\u00e7\u00e3o do nosso programa \u00e9 um <code>implicit none</code>, e \u00e9 por um bom motivo: Devido a influ\u00eancia e heran\u00e7a do Fortran 77, por padr\u00e3o, vari\u00e1veis que come\u00e7am pelas letras I,J,K,L,M,N s\u00e3o do tipo <code>integer</code>, e vari\u00e1veis come\u00e7ando pelas outras letras restantes do alfabeto s\u00e3o do tipo <code>real</code>. Hoje em dia, n\u00e3o se \u00e9 mais recomendado usar essa tipagem impl\u00edcita, que permaneceu apenas por motivos de retrocompatibilidade (ser poss\u00edvel executar c\u00f3digos-fonte antigos utilizando compiladores mais novos, sem ter que alterar o c\u00f3digo). Para indicarmos que n\u00e3o utilizaremos este padr\u00e3o de tipagem impl\u00edcita, inclu\u00edmos a instru\u00e7\u00e3o <code>implicit none</code> no come\u00e7o do programa.</p>"},{"location":"Fortran/Fortran_90/#precisao-de-variaveis","title":"Precis\u00e3o de Vari\u00e1veis","text":"<p>A representa\u00e7\u00e3o de valores reais, em Fortran, \u00e9 feita utilizando ponto flutuante. Nesta forma de representa\u00e7\u00e3o, os n\u00fameros possuem sua parte fracion\u00e1ria armazenada em um tamanho finito de mem\u00f3ria. Por\u00e9m, existem diferentes padr\u00f5es de armazenamento destes n\u00fameros, mas n\u00e3o iremos nos aprofundar neste assunto e abordaremos apenas 2 casos de nosso interesse: Float32 e Float64 - definidos no padr\u00e3o IEE 754. Float32 \u00e9 o padr\u00e3o que reserva 32 bits para armazenamento de um n\u00famero, e possui uma precis\u00e3o de 6 a 9 d\u00edgitos decimais. J\u00e1 o padr\u00e3o Float64 \u00e9 o padr\u00e3o que reserva 64 bits para armazenamento do n\u00famero, possuindo uma precis\u00e3o maior: de 15 a 17 d\u00edgitos decimais.</p> <p>Por padr\u00e3o, Fortran utiliza Float32 para armazenar os n\u00fameros reais no tipo de vari\u00e1vel <code>real</code>. Caso queiramos armazenar valores com maior precis\u00e3o, usando o padr\u00e3o Float64, podemos utilizar um m\u00f3dulo disponibilizado pelos compiladores mais recentes de Fortran (2003/2008 em diante): o <code>iso_fortran_env</code>. Neste m\u00f3dulo, temos a defini\u00e7\u00e3o de v\u00e1rias constantes, sendo algumas delas as de defini\u00e7\u00e3o de precis\u00e3o - conhecidas como \"<code>kind</code> parameters\".</p> <p>Para declararmos uma vari\u00e1vel real com 64 bits de precis\u00e3o, importamos o m\u00f3dulo e declaramos a vari\u00e1vel como <code>real(real64)</code> :</p> <pre><code>    use, intrinsic :: iso_fortran_env\n    implicit none\n\n    real(real64) :: valor\n</code></pre> <p>Essa informa\u00e7\u00e3o \u00e9 expressamente relevante para computa\u00e7\u00f5es de alta precis\u00e3o. Se quisermos representar valores literais em Float64, colocamos \"_real64\" no final do valor. Veja a diferen\u00e7a na precis\u00e3o de representa\u00e7\u00e3o do n\u00famero de Euler:</p> <pre><code>    program euler\n            use, intrinsic :: iso_fortran_env\n            implicit none\n\n            real :: v1\n            real(real64) :: v2\n\n            v1 = exp(1.0)\n            v2 = exp(1.0_real64)\n\n            print *, v1\n            print *, v2\n\n    end program euler\n</code></pre> <p>E temos <code>v1 = 2.71828175</code> e <code>v2 = 2.7182818284590451</code>. No primeiro caso, temos erro no 7\u00ba d\u00edgito, e no segundo apenas no 16\u00ba d\u00edgito. Note que foi preciso chamar a fun\u00e7\u00e3o <code>exp(x)</code> (que retorna ) passando como argumento um valor de 64 bits, para que ele calculasse uma resposta com 64 bits de precis\u00e3o. Lembre-se disso e tome cuidado para n\u00e3o acabar armazenando, por engano, um resultado gerado por precis\u00e3o simples em uma vari\u00e1vel de precis\u00e3o dupla. No mesmo exemplo:</p> <pre><code>    program euler\n            use, intrinsic :: iso_fortran_env\n            implicit none\n\n            real(real64) :: v3\n            v3 = exp(1.0)\n\n            print *, v3\n\n    end program euler\n</code></pre> <p>Onde <code>v3 = 2.7182817459106445</code> parece ser um valor com precis\u00e3o maior, por estar em uma vari\u00e1vel que \u00e9 capaz de representar n\u00fameros com mais precis\u00e3o, mas cujo o conte\u00fado \u00e9 resultado de uma opera\u00e7\u00e3o em precis\u00e3o simples (ainda h\u00e1 erro no 7\u00ba d\u00edgito da constante).</p>"},{"location":"Fortran/Fortran_90/#topico-22-operacoes-basicas","title":"T\u00f3pico 2.2: Opera\u00e7\u00f5es B\u00e1sicas","text":"<p>Assim como muitas outras linguagens, Fortran vem com alguns operadores aritm\u00e9ticos b\u00e1sicos, tabelados abaixo em ordem de preced\u00eancia:</p> Operador Opera\u00e7\u00e3o ** Exponencia\u00e7\u00e3o * Multiplica\u00e7\u00e3o / Divis\u00e3o + Adi\u00e7\u00e3o - Subtra\u00e7\u00e3o <p>Muito cuidado com a preced\u00eancia dos operadores ao colocar express\u00f5es matem\u00e1ticas grandes no seu c\u00f3digo! Principalmente se elas envolvem fra\u00e7\u00f5es: a express\u00e3o pode acabar calculando uma express\u00e3o diferente da pretendida. Por exemplo, se quisermos calcular uma m\u00e9dia simples entre 3 n\u00fameros, ao escrever:</p> <pre><code>    program media\n        print *, 3 + 4 + 5 / 2\n    end program media\n</code></pre> <p>Temos como resultado <code>9</code>, e n\u00e3o <code>6</code>, pois quem tem a preced\u00eancia maior \u00e9 a divis\u00e3o, ent\u00e3o primeiro \u00e9 avaliado <code>5 / 2</code> e depois s\u00e3o feitas as somas. Para alterar preced\u00eancia de opera\u00e7\u00f5es, envolvemos a express\u00e3o com par\u00eanteses - que possuem a maior preced\u00eancia entre os operadores:</p> <pre><code>    program media\n        print *, (3 + 4 + 5) / 2\n    end program media\n</code></pre> <p>E agora temos o comportamento esperado. Outro detalhe curioso no trecho de c\u00f3digo anterior \u00e9 que a express\u00e3o foi avaliada como igual a <code>9</code>, e n\u00e3o <code>9.5</code> como esperar\u00edamos da aritm\u00e9tica usual. Isto ocorre por outra caracter\u00edstica importante da linguagem: opera\u00e7\u00f5es entre inteiros geram inteiros, opera\u00e7\u00f5es com reais geram reais. N\u00fameros reais s\u00e3o representados com ponto decimal, ainda que sua parte decimal seja toda zero. Essa regra explica o porqu\u00ea de</p> <pre><code>    program divisao\n        print *, 5 / 2\n    end program divisao\n</code></pre> <p>ser avaliado como <code>2</code> , e</p> <pre><code>    program divisao\n        print *, 5.0 / 2\n    end program divisao\n</code></pre> <p>ser avaliado como <code>2.50000000</code> . Portanto, cuidado tamb\u00e9m com os tipos das vari\u00e1veis que voc\u00ea estiver operando e com a formata\u00e7\u00e3o dos n\u00fameros.</p>"},{"location":"Fortran/Fortran_90/#comentarios","title":"Coment\u00e1rios","text":"<p>Apesar de n\u00e3o ser um operador, vamos aproveitar o final desta se\u00e7\u00e3o para falar de coment\u00e1rios. Linhas de coment\u00e1rios s\u00e3o iniciadas por <code>!</code>, e servem para escrever texto que n\u00e3o ser\u00e1 interpretado pelo programa. Coment\u00e1rios s\u00e3o \u00fateis para documentar o que est\u00e1 sendo feito no programa e para guiar as pessoas que forem ler o c\u00f3digo-fonte.</p> <pre><code>    program comentarios\n        implicit none\n        ! Esta linha ser\u00e1 ignorada pelo compilador, escreva o que quiser\n\n        real :: alpha  ! Coeficiente do termo linear\n        real :: beta   ! Coeficiente do termo n\u00e3o-linear\n        real :: x      ! Vari\u00e1vel de entrada\n        real :: y\n\n        alpha = 3.0\n        beta = 1.0\n        x = 1\n\n        ! Calculando a rela\u00e7\u00e3o y(x)\n        y = (alpha * x) + (beta * x * x)\n\n        print *, y\n\n    end program comentarios\n</code></pre> <p>N\u00e3o fa\u00e7a coment\u00e1rios em excesso, pois coment\u00e1rios demais podem prejudicar a legibilidade do c\u00f3digo, mas tamb\u00e9m evite deixar c\u00f3digos totalmente n\u00e3o comentados, j\u00e1 que voc\u00ea pode n\u00e3o se lembrar o que cada linha faz ao revisitar o c\u00f3digo no futuro. Uma dica para achar esse equil\u00edbrio \u00e9 escrever bons nomes de vari\u00e1veis e fun\u00e7\u00f5es, que sejam autodescritivos e dispensem coment\u00e1rios, quando poss\u00edvel. Caso voc\u00ea queira adaptar uma f\u00f3rmula diretamente, querendo manter a nota\u00e7\u00e3o original, voc\u00ea pode comentar as vari\u00e1veis ou a f\u00f3rmula referenciada por exemplo.</p>"},{"location":"Fortran/Fortran_90/#topico-3-funcoes-e-modulos","title":"T\u00f3pico 3: Fun\u00e7\u00f5es e M\u00f3dulos","text":"<p>Este \u00e9 um dos t\u00f3picos mais complexos, mas tamb\u00e9m um dos mais relevantes. Leia com calma e, se preciso, pare, rode e mude o c\u00f3digo. Leia mais de uma vez. </p>"},{"location":"Fortran/Fortran_90/#topico-31-funcoes","title":"T\u00f3pico 3.1: Fun\u00e7\u00f5es","text":"<p>Fun\u00e7\u00f5es s\u00e3o um dos objetos mais explorados e utilizados na matem\u00e1tica, e n\u00e3o ser\u00e1 diferente para n\u00f3s. No contexto de programa\u00e7\u00e3o, fun\u00e7\u00f5es trazem modularidade e organiza\u00e7\u00e3o ao c\u00f3digo, permitindo que um trecho de c\u00f3digo possa ser reutilizado em diferentes locais do programa, ou at\u00e9 exportado para outros programas que venhamos futuramente desenvolver.</p> <p>A sintaxe para declara\u00e7\u00e3o de uma fun\u00e7\u00e3o em Fortran segue um padr\u00e3o como o seguinte:</p> <pre><code>    function nome_funcao(arg1, arg2) result(var_result)\n        implicit none\n\n        tipo1, intent(in) :: arg1\n        tipo2, intent(in) :: arg2\n        tipo3 :: var_result\n\n        ! Corpo da fun\u00e7\u00e3o\n\n        return\n\n    end funtion nome_funcao\n</code></pre> <p>Vamos destrinchar cada parte. A declara\u00e7\u00e3o \u00e9 feita em bloco, assim como vimos anteriormente ao criarmos o programa principal com <code>program</code>. Ou seja, come\u00e7amos a declara\u00e7\u00e3o com <code>function nome_funcao</code> e terminamos com <code>end function nome_funcao</code>. Na frente do nome da fun\u00e7\u00e3o, entre par\u00eanteses, listamos os argumentos (ou vari\u00e1veis, no jarg\u00e3o matem\u00e1tico) da fun\u00e7\u00e3o. Podemos colocar quantos argumentos quisermos (at\u00e9 mesmo nenhum). Nesse nosso exemplo, temos 2 argumentos: <code>arg1</code> e <code>arg2</code>. Imediatamente ap\u00f3s, colocamos a palavra reservada <code>result</code> e, em seguida e entre par\u00eanteses, o nome da vari\u00e1vel que ter\u00e1 o valor a ser retornado no final da fun\u00e7\u00e3o, no caso do exemplo, <code>var_result</code>. Um ponto a ser ressaltado: fun\u00e7\u00f5es retornam um, e apenas um, resultado. Mas n\u00e3o se desespere. \u00c9 poss\u00edvel organizar as informa\u00e7\u00f5es de formar a fazer uma fun\u00e7\u00e3o retornar mais de 1 valor, por\u00e9m abordaremos este t\u00f3pico em outro momento. Por enquanto, trabalharemos com estruturas mais simples.</p> <p>Ao analisarmos o corpo da fun\u00e7\u00e3o notamos, inicialmente, temos uma linha <code>implicit none</code>, que tem o comportamento descrito ao final do t\u00f3pico 2.1, e em seguida duas linhas de declara\u00e7\u00e3o de vari\u00e1veis. Estas vari\u00e1veis s\u00e3o os argumentos da fun\u00e7\u00e3o. Por\u00e9m, diferente da declara\u00e7\u00e3o usual vista no t\u00f3pico 2.1, temos um trecho <code>intent(in)</code> no meio da declara\u00e7\u00e3o. A instru\u00e7\u00e3o <code>intent</code> declara quais opera\u00e7\u00f5es (escrita e leitura) ser\u00e3o feitas em uma vari\u00e1vel. Quando colocamos <code>intent(in)</code> na declara\u00e7\u00e3o da vari\u00e1vel, estamos dizendo que esta vari\u00e1vel ser\u00e1 apenas lida, mas n\u00e3o poder\u00e1 ter seu valor sobrescrito pela fun\u00e7\u00e3o. Essa instru\u00e7\u00e3o est\u00e1 certificando mais um padr\u00e3o de fun\u00e7\u00f5es em Fortran: fun\u00e7\u00f5es n\u00e3o devem alterar os argumentos de entrada. Esse padr\u00e3o previne comportamentos inesperados (side effects) e facilita interpreta\u00e7\u00e3o de resultados.</p> <p>Para vermos um exemplo que ilustra a import\u00e2ncia da declara\u00e7\u00e3o de inten\u00e7\u00e3o das vari\u00e1veis, vamos abordar apenas mais um conceito e estudar um caso. Para conseguirmos incorporar uma fun\u00e7\u00e3o em um programa, podemos utilizar, ao final do programa, uma instru\u00e7\u00e3o <code>contains</code> seguida da declara\u00e7\u00e3o da fun\u00e7\u00e3o. Sabendo disso, vejamos um exemplo: Suponha que temos um vetor , e queremos calcular a norma do dobro desse vetor. Ou seja, se temos o vetor , queremos a norma de . Vamos construir uma primeira fun\u00e7\u00e3o para isso, n\u00e3o seguindo o padr\u00e3o com <code>intent</code>:</p> <pre><code>    function norma_dobro(v1, v2) result(norma)\n        real :: v1\n        real :: v2\n        real :: norma\n\n        v1 = 2*v1\n        v2 = 2*v2\n\n        norma = ((v1**2) + (v2**2))**(1.0/2.0)\n\n        return\n\n    end function norma_dobro\n</code></pre> <p>Agora, vamos criar um programa e testar nossa fun\u00e7\u00e3o:</p> <pre><code>    program calcula_norma\n        implicit none\n        real :: norma_calculada\n        real :: vec1 !1\u00aa coordenada do vetor\n        real :: vec2 !2\u00aa coordenada do vetor\n\n        vec1 = 1\n        vec2 = 1\n\n        norma_calculada = norma_dobro(vec1, vec2)\n        print *, norma_calculada\n\n        contains\n            function norma_dobro(v1, v2) result(norma)\n                real :: v1\n                real :: v2\n                real :: norma\n\n                v1 = 2*v1\n                v2 = 2*v2\n\n                norma = ((v1**2) + (v2**2))**(1.0/2.0)\n\n                return\n\n            end function norma_dobro\n\n    end program calcula_norma\n</code></pre> <p>Ao executarmos o nosso programa, temos como sa\u00edda:</p> <pre><code>    2.82842708\n</code></pre> <p>Que \u00e9 a norma do vetor . A princ\u00edpio, parece que est\u00e1 tudo bem, mas nossa fun\u00e7\u00e3o gerou um efeito colateral e n\u00e3o percebemos isso. Podemos verificar o que aconteceu printando as coordenadas  antes e depois da chamada da fun\u00e7\u00e3o:</p> <pre><code>    program calcula_norma\n        implicit none\n        real :: norma_calculada\n        real :: vec1 !1\u00aa coordenada do vetor\n        real :: vec2 !2\u00aa coordenada do vetor\n\n        vec1 = 1\n        vec2 = 1\n\n        print *, vec1\n        print *, vec2\n\n        norma_calculada = norma_dobro(vec1, vec2)\n        print *, norma_calculada\n\n        print *, vec1\n        print *, vec2\n\n        contains\n            function norma_dobro(v1, v2) result(norma)\n                real :: v1\n                real :: v2\n                real :: norma\n\n                v1 = 2*v1\n                v2 = 2*v2\n\n                norma = ((v1**2) + (v2**2))**(1.0/2.0)\n\n                return\n\n            end function norma_dobro\n\n    end program calcula_norma\n</code></pre> <p>E no resultado desse programa:</p> <pre><code>    1.00000000\n    1.00000000\n    2.82842708\n    2.00000000\n    2.00000000\n</code></pre> <p>Podemos perceber que nossa fun\u00e7\u00e3o de c\u00e1lculo de norma mudou os valores do nosso vetor original, que n\u00e3o era nossa inten\u00e7\u00e3o inicial. Isso ocorre pois altera\u00e7\u00f5es em vari\u00e1veis passadas como argumentos em fun\u00e7\u00f5es refletem as altera\u00e7\u00f5es externamente. Vejamos agora o que acontece quando declaramos a fun\u00e7\u00e3o usando <code>intent</code>:</p> <pre><code>    program calcula_norma\n        implicit none\n        real :: norma_calculada\n        real :: vec1 !1\u00aa coordenada do vetor\n        real :: vec2 !2\u00aa coordenada do vetor\n\n        vec1 = 1\n        vec2 = 1\n\n        print *, vec1\n        print *, vec2\n\n        norma_calculada = norma_dobro(vec1, vec2)\n        print *, norma_calculada\n\n        print *, vec1\n        print *, vec2\n\n        contains\n            function norma_dobro(v1, v2) result(norma)\n                real, intent(in) :: v1\n                real, intent(in) :: v2\n                real :: norma\n\n                v1 = 2*v1\n                v2 = 2*v2\n\n                norma = ((v1**2) + (v2**2))**(1.0/2.0)\n\n                return\n\n            end function norma_dobro\n\n    end program calcula_norma\n</code></pre> <p>E ao tentarmos compilar e executar este programa:</p> <pre><code>    ./main.f95:27:3:\n\n             27 |    v1 = 2*v1\n    Error: Dummy argument \u2018v1\u2019 with INTENT(IN) in variable definition\n    context (assignment) at (1)\n    ./main.f95:28:3:\n\n             28 |    v2 = 2*v2\n    Error: Dummy argument \u2018v2\u2019 with INTENT(IN) in variable definition\n    context (assignment) at (1)\n</code></pre> <p>Nosso compilador n\u00e3o finalizou a compila\u00e7\u00e3o pois detectou uma inconsist\u00eancia: Declaramos que  s\u00e3o apenas argumentos de entrada, mas em seguida tentamos modificar o valor dessas vari\u00e1veis. A\u00ed est\u00e1 a import\u00e2ncia do uso do <code>intent</code>: caso n\u00f3s, programadores, acidentalmente fa\u00e7amos uma atribui\u00e7\u00e3o indevida, seremos alertados pelo compilador de que estamos fazendo algo que provavelmente n\u00e3o dever\u00edamos estar fazendo.</p> <p>Para contornar nosso problema da fun\u00e7\u00e3o <code>calcula_norma</code>, podemos:</p> <ol> <li>Criar novas vari\u00e1veis internas da fun\u00e7\u00e3o, que essas sim poder\u00e3o    ser modificadas, copiar o valor dos argumentos originais nestas    vari\u00e1veis e operar com ela; ou</li> <li>Usar os valores originais diretamente no c\u00e1lculo da norma</li> </ol> <p>Na primeira proposta, nossa fun\u00e7\u00e3o ficaria com a seguinte cara:</p> <pre><code>    function norma_dobro(v1, v2) result(norma)\n        real, intent(in) :: v1\n        real, intent(in) :: v2\n\n        real :: coord1\n        real :: coord2\n        real :: norma\n\n        coord1 = v1\n        coord2 = v2\n\n        coord1 = 2*coord1\n        coord2 = 2*coord2\n\n        norma = ((coord1**2) + (coord2**2))**(1.0/2.0)\n\n        return\n\n    end function norma_dobro\n</code></pre> <p>Com a segunda proposta:</p> <pre><code>    function norma_dobro(v1, v2) result(norma)\n        real, intent(in) :: v1\n        real, intent(in) :: v2\n        real :: norma\n\n        norma = (((2*v1)**2) + ((2*v2)**2))**(1.0/2.0)\n\n        return\n\n    end function norma_dobro\n</code></pre> <p>E, com qualquer uma dessas vers\u00f5es, nosso resultado final ao executar o programa ser\u00e1:</p> <pre><code>    1.00000000\n    1.00000000\n    2.82842708\n    1.00000000\n    1.00000000\n</code></pre> <p>Evitamos, assim, altera\u00e7\u00f5es nos dados originais. Dois coment\u00e1rios valem ser feitos: Apesar de ter menos c\u00f3digo, a segunda implementa\u00e7\u00e3o da fun\u00e7\u00e3o \u00e9 bem mais dif\u00edcil de ser entendida do que a primeira implementa\u00e7\u00e3o. Em programas mais complexos, isso pode vir a ser um problema para outros programadores que tentem entender o comportamento da fun\u00e7\u00e3o, e at\u00e9 mesmo para quem escreveu a fun\u00e7\u00e3o ao ler o pr\u00f3prio c\u00f3digo futuramente. Procure fazer c\u00f3digos compreens\u00edveis e, quando preciso, comente linhas mais dif\u00edceis ou relevantes. Segundo ponto: colocar o bloco de fun\u00e7\u00f5es abaixo do programa principal n\u00e3o \u00e9 melhor maneira de organizar o seu c\u00f3digo. A maneira ideal de se fazer esta organiza\u00e7\u00e3o \u00e9 utilizando M\u00f3dulos, que ser\u00e1 nosso pr\u00f3ximo assunto, no t\u00f3pico 3.3.</p>"},{"location":"Fortran/Fortran_90/#topico-32-funcoes-intrinsecas","title":"T\u00f3pico 3.2: Fun\u00e7\u00f5es Intr\u00ednsecas","text":"<p>Fortran j\u00e1 existe a muito tempo, e \u00e9 utilizado para diversos fins. Por\u00e9m, como v\u00e1rias delas acabaram por precisar de fun\u00e7\u00f5es comuns entre elas, a linguagem j\u00e1 implementa algumas destas fun\u00e7\u00f5es para nos poupar de ter que defini-las n\u00f3s mesmos. Buscando por \"Intrinsic functions in Fortran 90\" na internet, voc\u00ea vai encontrar algumas rela\u00e7\u00f5es/listas destas fun\u00e7\u00f5es. Alguns dos exemplos de fun\u00e7\u00f5es ofertadas s\u00e3o:</p> <ul> <li>Valor Absoluto - <code>ABS</code></li> <li>M\u00e1ximo - <code>MAX</code></li> <li>Logaritmo Natural - <code>LOG</code></li> <li>Exponencial - <code>EXP</code></li> <li>Raiz Quadrada - <code>SQRT</code></li> <li>Cosseno - <code>COS</code></li> <li>Arco tangente - <code>ATAN</code></li> <li>Conjugado Complexo - <code>CONJG</code>, etc</li> </ul> <p>Normalmente, as implementa\u00e7\u00f5es destas fun\u00e7\u00f5es s\u00e3o uma das melhores poss\u00edveis (geralmente s\u00e3o r\u00e1pidas!). Ent\u00e3o, quando for criar uma fun\u00e7\u00e3o simples pro seu c\u00f3digo, veja se ela j\u00e1 \u00e9 oferecida nativamente pela linguagem. Se sim, d\u00ea prioridade a implementa\u00e7\u00e3o nativa.</p>"},{"location":"Fortran/Fortran_90/#topico-33-modulos","title":"T\u00f3pico 3.3: M\u00f3dulos","text":"<p>M\u00f3dulos, como o pr\u00f3prio nome sugere, trazem modularidade ao programa. Ao subdividirmos um grande programa em componentes menores, facilitamos a manuten\u00e7\u00e3o e a eventual reutiliza\u00e7\u00e3o desses componentes em outros programas. Dessa forma, fun\u00e7\u00f5es que s\u00e3o utilizadas em v\u00e1rios programas diferentes s\u00f3 precisar\u00e3o ser escritas uma vez e reutilizadas sempre que poss\u00edvel. Al\u00e9m disso, voc\u00ea s\u00f3 precisar\u00e1 alterar 1 trecho que c\u00f3digo para aplicar a mudan\u00e7a em v\u00e1rios programas de uma s\u00f3 vez (em vez de fazer a altera\u00e7\u00e3o programa a programa).</p> <p>A sintaxe da declara\u00e7\u00e3o de um m\u00f3dulo segue um padr\u00e3o como o seguinte:</p> <pre><code>    module nome_do_modulo\n        implicit none\n\n    contains\n        ! Aqui come\u00e7a o bloco de declara\u00e7\u00e3o de\n        ! fun\u00e7\u00f5es, vari\u00e1veis, e o que mais quisermos\n\n    end module nome_do_modulo\n</code></pre> <p>E, para usarmos um m\u00f3dulo em um programa, inclu\u00edmos uma linha <code>use nome_do_modulo</code> logo abaixo da primeira linha do programa. Para o nosso exemplo do t\u00f3pico anterior, podemos criar um m\u00f3dulo de normas, e teremos um programa reestruturado da seguinte forma:</p> <pre><code>    module normas\n        implicit none\n\n    contains\n        function norma_do_dobro(v1, v2) result(norma)\n                real, intent(in) :: v1\n                real, intent(in) :: v2\n\n                real :: coord1\n                real :: coord2\n                real :: norma\n\n                coord1 = v1\n                coord2 = v2\n\n                coord1 = 2*coord1\n                coord2 = 2*coord2\n\n                norma = sqrt((coord1**2) + (coord2**2))\n\n                return\n\n        end function norma_do_dobro\n    end module funcs\n\n    program calcula_norma\n        use normas\n        implicit none\n        real :: norma_calculada\n        real :: vec1 !1\u00aa coordenada do vetor\n        real :: vec2 !2\u00aa coordenada do vetor\n\n        vec1 = 1\n        vec2 = 1\n\n        print *, vec1\n        print *, vec2\n\n        norma_calculada = norma_do_dobro(vec1, vec2)\n        print *, norma_calculada\n\n        print *, vec1\n        print *, vec2\n\n    end program calcula_norma\n</code></pre> <p>Desta forma, agrupamos fun\u00e7\u00f5es parecidas, ou de mesmo contexto, sem mistur\u00e1-las com todas as outras fun\u00e7\u00f5es do c\u00f3digo. Al\u00e9m disso, veremos posteriormente como m\u00f3dulos podem ser importados e exportados entre diferentes programas, ao declar\u00e1-los em arquivos separados e us\u00e1-los em nossos programas.</p>"},{"location":"Fortran/Fortran_90/#topico-4-estruturas-condicionais-if-then-else","title":"T\u00f3pico 4: Estruturas Condicionais: IF - THEN - ELSE","text":"<p>J\u00e1 sabemos como montar um programa que executa do come\u00e7o ao fim de acordo com um procedimento inicialmente bem determinado. Mas e se o comportamento do programa puder variar no meio da execu\u00e7\u00e3o, dependendo da entrada fornecida? N\u00e3o saberemos de antem\u00e3o como o programa ir\u00e1 executar, mas podemos preparar o c\u00f3digo para fazer as decis\u00f5es em tempo de execu\u00e7\u00e3o. Para fazermos isso, vamos ver como funcionam os desvios condicionais.</p>"},{"location":"Fortran/Fortran_90/#topico-41-operadores-logicos","title":"T\u00f3pico 4.1: Operadores L\u00f3gicos","text":"<p>Vimos anteriormente operadores aritm\u00e9ticos (+, -, *, etc) e como operam valores num\u00e9ricos. Mas, quando a \u00e1lgebra em quest\u00e3o \u00e9 a \u00e1lgebra de Boole, precisamos de novos operadores que lidam com os valores verdade <code>.true.</code> e <code>.false.</code>.</p> <p>Para formarmos express\u00f5es l\u00f3gicas, podemos utilizar os operadores:</p> Operador Opera\u00e7\u00e3o == Verifica se os 2 operandos s\u00e3o iguais /= Verifica se os 2 operandos s\u00e3o diferentes &gt; Verifica se o operando \u00e0 esquerda \u00e9 maior que o da direita &lt; Verifica se o operando \u00e0 esquerda \u00e9 menor que o da direita &gt;= Verifica se o operando \u00e0 esquerda \u00e9 maior ou igual ao da &lt;= Verifica se o operando \u00e0 esquerda \u00e9 menor ou igual ao dadireita <p>Estes operadores ir\u00e3o retornar valores <code>.true.</code> ou <code>.false.</code>, e podemos operar estes valores com os operadores booleanos:</p> Operador Opera\u00e7\u00e3o .and. Realiza um \"E\" l\u00f3gico .or. Realiza um \"OU\" l\u00f3gico .not. Realiza um \"N\u00c3O\" l\u00f3gico <p>Com isso, podemos fazer alguns testes como: Se um certo valor \u00e9 maior que 0, se 2 valores s\u00e3o iguais, etc.</p>"},{"location":"Fortran/Fortran_90/#topico-42-comando-if-then-else","title":"T\u00f3pico 4.2: Comando IF-THEN-ELSE","text":"<p>Agora que sabemos como montar e comparar express\u00f5es l\u00f3gicas, vamos us\u00e1-las com o comando IF-THEN-ELSE. A sintaxe do comando \u00e9:</p> <pre><code>    if (expressao_logica) then\n        ! C\u00f3digo a ser executado se a express\u00e3o for verdadeira\n    else\n        ! C\u00f3digo a ser executado se a express\u00e3o for falsa\n    end if\n</code></pre> <p>O trecho <code>else</code> pode ser omitido, caso n\u00e3o haja nenhum caso expl\u00edcito para a condi\u00e7\u00e3o falsa. E com isso, conseguimos implementar v\u00e1rias fun\u00e7\u00f5es que s\u00e3o definidas por parte, como:</p> <p>Fun\u00e7\u00e3o Valor Absoluto</p> <pre><code>    function absoluto(x) result(y)\n        real, intent(in) :: x\n        real :: y\n\n        y = x\n\n        if (x &lt; 0) then\n                y = -y\n        end if\n\n        return\n\n    end function absoluto\n</code></pre> <p>Fun\u00e7\u00e3o de Heaviside</p> <pre><code>    function heaviside(x) result(y)\n        real, intent(in) :: x\n        real :: y\n\n        if (x &gt;= 0) then\n                y = 1\n        else\n                y = 0\n        end if\n\n        return\n\n    end function heaviside\n</code></pre> <p>E assim por diante. Dica de programa\u00e7\u00e3o: evite colocar muitos IF's aninhados uns dentro dos outros, pois isso costuma dificultar a leitura do c\u00f3digo. Evite tamb\u00e9m colocar express\u00f5es muito longas no teste do IF, e tome cuidado com a preced\u00eancia das opera\u00e7\u00f5es (use par\u00eanteses, na d\u00favida). Aqui um exemplo de um bloco dif\u00edcil de entender devido a IF's aninhados:</p> <pre><code>    real, intent(in):: a\n    real, intent(in):: b\n    real, intent(in):: p\n\n    if (p &gt;= a) then\n        if (p &lt;= b) then\n            if (p == (a+b)/2 ) then\n                print *, \"p est\u00e1 no intervalo e \u00e9 ponto medio\"\n            else\n                if (p &gt; (a+b)/2) then\n                    print *, \"p est\u00e1 no intervalo, e est\u00e1 mais pr\u00f3ximo de\", b\n                else\n                    print *, \"p est\u00e1 no intervalo, e est\u00e1 mais pr\u00f3ximo de\", a\n                end if\n            end if\n        else\n            print *, \"p est\u00e1 fora do intervalo, e depois de\", b\n        end if\n    else\n        print *, \"p est\u00e1 fora do intervalo, e antes de\", a\n    end if\n</code></pre> <p>Perceba que voc\u00ea precisa manter os estados l\u00f3gicos na sua cabe\u00e7a para acompanhar a execu\u00e7\u00e3o. Para resolver estes problemas, geralmente aplicamos uma de duas t\u00e9cnicas: Invers\u00e3o L\u00f3gica ou Extra\u00e7\u00e3o em Fun\u00e7\u00e3o. Na primeira, usamos o teste l\u00f3gico inverso combinados com <code>return</code>, de forma que daquele trecho em diante, sabemos que n\u00e3o estamos mais naquele caso. O segundo m\u00e9todo consiste em extrair subtestes em fun\u00e7\u00f5es separadas, que realizam a l\u00f3gica internamente, e apenas chamar estas fun\u00e7\u00f5es no nosso bloco de IF. Veja como fica o c\u00f3digo acima utilizando a primeira t\u00e9cnica:</p> <pre><code>    real, intent(in):: a\n    real, intent(in):: b\n    real, intent(in):: p\n\n    if (p &lt; a) then\n        print *, \"p est\u00e1 fora do intervalo, e antes de\", a\n        return\n    end if\n\n    if (p &gt; b) then\n        print *, \"p est\u00e1 fora do intervalo, e depois de\", b\n        return\n    end if\n\n    if (p == (a+b)/2 ) then\n        print *, \"p est\u00e1 no intervalo e \u00e9 ponto medio\"\n        return\n    end if\n\n    ! Neste ponto, sabemos que p est\u00e1 no intervalo e n\u00e3o \u00e9 ponto m\u00e9dio\n    if (p &gt; (a+b)/2) then\n        print *, \"p est\u00e1 no intervalo, e est\u00e1 mais pr\u00f3ximo de\", b\n    else\n        print *, \"p est\u00e1 no intervalo, e est\u00e1 mais pr\u00f3ximo de\", a\n    end if\n\n    return\n</code></pre> <p>Bem melhor de acompanhar, n\u00e3o \u00e9? Usando a segunda t\u00e9cnica poder\u00edamos, por exemplo, extrair o bloco que testa se <code>p</code> est\u00e1 dentro do intervalo  em uma fun\u00e7\u00e3o, e verificar as outras propriedades no nosso IF ap\u00f3s chamar esta fun\u00e7\u00e3o. Caso queira, fa\u00e7a este segundo caso como exerc\u00edcio. Em alguns outros cen\u00e1rios, esta segunda t\u00e9cnica pode fazer mais sentido que a primeira, e vice versa.</p>"},{"location":"Fortran/Fortran_90/#topico-5-repeticao-comando-do","title":"T\u00f3pico 5: Repeti\u00e7\u00e3o - Comando DO","text":"<p>Uma das maiores vantagens de se utilizar um computador para fazer contas, al\u00e9m da velocidade, \u00e9 que, diferente de n\u00f3s seres humanos, m\u00e1quinas podem fazer tarefas repetitivas por longas horas sem enjoarem. Portanto, deixemos essas tarefas para o computador sempre que poss\u00edvel, poupando a n\u00f3s, programadores humanos, dessa tarefa. E, para isso, podemos utilizar o comando DO.</p> <p>A sintaxe do comando \u00e9:</p> <pre><code>    do iterador = valor_inicial, valor_final, passo\n        ! C\u00f3digo a ser repetido\n    end do\n</code></pre> <p>Onde: <code>iterador</code> \u00e9 a vari\u00e1vel de itera\u00e7\u00e3o da repeti\u00e7\u00e3o, <code>valor_inicial</code> \u00e9 o primeiro valor que o iterador assumir\u00e1, <code>valor_final</code> \u00e9 o \u00faltimo valor que a vari\u00e1vel pode assumir e <code>passo</code> \u00e9 o incremento que ser\u00e1 feito a cada rodada de repeti\u00e7\u00e3o. O exemplo mais comum na matem\u00e1tica? Somat\u00f3rios. Digamos que queremos fazer um somat\u00f3rio de 1 at\u00e9 n da express\u00e3o , como far\u00edamos? Desta forma:</p> <pre><code>    implicit none\n\n    real :: valor\n    integer :: k\n    integer :: n\n\n    valor = 0.0\n    n = 100\n    do k = 1, n, 1\n        valor = valor + 1.0/(k*k)\n    end do\n\n    print *, valor\n</code></pre> <p>E com 3 linhas fizemos 100 opera\u00e7\u00f5es (o valor de <code>n</code> neste exemplo), tal qual uma nota\u00e7\u00e3o de somat\u00f3rio dispensa escrevermos 100 somas por extenso. Algumas observa\u00e7\u00f5es sobre este trecho de c\u00f3digo:</p> <ul> <li>Come\u00e7amos iniciando a vari\u00e1vel <code>valor</code> com 0.0, para   garantir que n\u00e3o havia nenhum lixo de mem\u00f3ria da vari\u00e1vel   rec\u00e9m-criada. Crie o h\u00e1bito de inicializar vari\u00e1veis antes de   us\u00e1-las, especialmente em situa\u00e7\u00f5es onde ser\u00e3o utilizadas para   ac\u00famulos.</li> <li>O passo de itera\u00e7\u00e3o padr\u00e3o do comando <code>do</code> \u00e9 1.   Logo, \u00e9 equivalente escrever <code>do k = 1, n, 1</code> ou   <code>do k = 1, n</code></li> <li>Por fim, cuidado com a precis\u00e3o das vari\u00e1veis e seus tamanhos   m\u00e1ximos e m\u00ednimos ao fazer muitas opera\u00e7\u00f5es com elas, ou que   envolvam n\u00fameros muito grandes, ou muito pequenos. Pode ser que   voc\u00ea se depare com um resultado estranho mesmo com um c\u00f3digo que   deveria funcionar, devido ao fato dos n\u00fameros terem ficado grandes   demais ou pequenos demais para o tamanho de representa\u00e7\u00e3o suportado   pelas vari\u00e1veis</li> </ul> <p>Para este \u00faltimo ponto, podemos utilizar o pr\u00f3prio trecho de c\u00f3digo acima para nos deparamos com problemas do tipo. O somat\u00f3rio expresso neste trecho converge para , que \u00e9 aproximadamente igual a 1,6449340668482264. Vamos testar diferentes valores de <code>n</code> no c\u00f3digo, para ver a converg\u00eancia:</p> <ul> <li>Para n =  temos valor = 1.63498402</li> <li>Para n =  temos valor = 1.64393485</li> <li>Para n =  temos valor = 1.64472532</li> <li>Para n =  temos valor = Infinity</li> </ul> <p>A soma divergiu! Ora, mas nosso c\u00f3digo estava coerente at\u00e9  e a teoria diz que a soma converge. Qual foi o problema? as vari\u00e1veis <code>k</code> e <code>valor</code> s\u00e3o dos tipos <code>integer</code> e <code>real</code> que, por padr\u00e3o (em FORTRAN 90), s\u00e3o de 32 bits! Quando <code>k</code> assume valores pr\u00f3ximos de , temos do denominador , que \u00e9 um n\u00famero maior do que os  represent\u00e1veis em uma vari\u00e1vel do tipo Float32 (vide T\u00f3pico 2.1). Se representarmos nossas vari\u00e1veis com mais precis\u00e3o (64 bits):</p> <pre><code>    use, intrinsic :: iso_fortran_env\n    implicit none\n\n    real(real64) :: valor\n    integer(int64) :: k\n    integer(int64) :: n\n\n    valor = 0.0\n    n = 10**5_int64\n    do k = 1, n\n            valor = valor + 1.0_real64/(k*k)\n    end do\n\n    print *, valor\n</code></pre> <p>E agora sim temos sa\u00eddas que continuam convergindo:</p> <ul> <li>Para n =  temos valor = 1.6449240668982423</li> <li>Para n =  temos valor = 1.6449330668487701</li> <li>Para n =  temos valor = 1.6449339668472596</li> <li>Para n =  temos valor = 1.6449340578345750</li> </ul> <p>Detalhe: n\u00e3o \u00e9 permitido andar com passos fracion\u00e1rios, como 0.5, apenas passos inteiros. Caso deseja iterar desta forma, \u00e9 preciso construir uma itera\u00e7\u00e3o inteira que nos permita, internamente, representar a itera\u00e7\u00e3o fracion\u00e1ria. Por exemplo, se queremos avaliar uma express\u00e3o de 0 at\u00e9 1 com passo 0.1, n\u00e3o \u00e9 poss\u00edvel fazer</p> <pre><code>    do k = 0, 1, 0.1\n            print *, k\n    end do\n</code></pre> <p>Mas podemos fazer:</p> <pre><code>    do k = 0, 10, 1\n            print *, k/10.0\n    end do\n</code></pre> <p>Uma outra dica \u00fatil e que reflete nas possibilidades de uso do comando <code>do</code> \u00e9 que voc\u00ea pode andar com passos negativos, como -1, desde que tamb\u00e9m sejam inteiros. No caso da nossa soma que , pode ser \u00fatil que somemos dos menores n\u00fameros para os maiores, com o objetivo de somar as contribui\u00e7\u00f5es das menores parcelas da soma primeiro, e as maiores depois. Esta t\u00e9cnica pode aumentar a precis\u00e3o dos c\u00e1lculos devido o n\u00e3o-desperd\u00edcio de precis\u00e3o.</p> <p>Desta forma, o mais adequado, para o nosso exemplo seria somarmos come\u00e7ando de <code>n</code> e terminando em 1, j\u00e1 que  \u00e9 o menor n\u00famero da soma, e cada um anterior \u00e9 ligeiramente maior. Sendo assim, nosso somat\u00f3rio ficaria de tr\u00e1s pra frente:</p> <pre><code>    use, intrinsic :: iso_fortran_env\n    implicit none\n\n    real(real64) :: valor\n    integer(int64) :: k\n    integer(int64) :: n\n\n    valor = 0.0\n    n = 10**5_int64\n    do k = n, 1, -1\n            valor = valor + 1.0_real64/(k*k)\n    end do\n\n    print *, valor\n</code></pre> <p>E conseguimos ver o impacto na precis\u00e3o ao comparamos os casos de  e  em ambas as abordagens:</p> <p>Primeira abordagem:</p> <ul> <li>Para n =  temos valor = 1.6449340578345750, erro absoluto   da aproxima\u00e7\u00e3o = 9.0136513808403151E-009</li> <li>Para n =  temos valor = 1.6449340578345750, erro absoluto   da aproxima\u00e7\u00e3o = 9.0136513808403151E-009</li> </ul> <p>Segunda abordagem:</p> <ul> <li>Para n =  temos valor = 1.6449340568482265, erro absoluto   da aproxima\u00e7\u00e3o = 9.9999999392252903E-009</li> <li>Para n =  temos valor = 1.6449340658482263, erro absoluta   do aproxima\u00e7\u00e3o = 1.0000000827403710E-009</li> </ul> <p>E observamos que n\u00e3o continuamos convergindo utilizando a primeira abordagem, enquanto na segunda sim.</p> <p>OBS: Existem formas muito mais eficientes de se aproximar , o exemplo acima \u00e9 meramente did\u00e1tico.</p>"},{"location":"Fortran/Fortran_90/#topico-6-subrotinas","title":"T\u00f3pico 6: Subrotinas","text":"<p>Neste t\u00f3pico abordaremos o \u00faltimo assunto antes de partirmos para nossa constru\u00e7\u00e3o e implementa\u00e7\u00e3o do M\u00e9todo da Bisse\u00e7\u00e3o. No t\u00f3pico 3 abordamos fun\u00e7\u00f5es e m\u00f3dulos, e vimos que uma das caracter\u00edsticas padronizadas das fun\u00e7\u00f5es \u00e9 que elas n\u00e3o alteram os argumentos de entrada. E para usar livremente os valores dos argumentos de entrada, criamos vari\u00e1veis auxiliares dentro do corpo da fun\u00e7\u00e3o para armazenarem c\u00e1lculos intermedi\u00e1rios. Por\u00e9m nem sempre isso \u00e9 vi\u00e1vel ou desejado, e gostar\u00edamos de alterar os valores passados como argumento. Vale lembrar tamb\u00e9m que fun\u00e7\u00f5es retornam apenas 1 \u00fanico valor. Para contornar estas limita\u00e7\u00f5es de uso, temos as Subrotinas.</p> <p>Subrotinas possuem comportamento e estrutura muito parecidos com fun\u00e7\u00f5es. A sintaxe para declara\u00e7\u00e3o de uma subrotina \u00e9:</p> <pre><code>    subroutine nome_subrotina(arg1, arg2, arg3)\n        implicit none\n\n        tipo1, intent(in) :: arg1\n        tipo2, intent(inout) :: arg2\n        tipo3, intent(out) :: arg3\n\n        ! Corpo da subrotina\n\n        return\n    end subroutine\n</code></pre> <p>Que \u00e9 muito semelhante a declara\u00e7\u00e3o de uma fun\u00e7\u00e3o, mas com algumas diferen\u00e7as:</p> <ol> <li>N\u00e3o h\u00e1 <code>result</code> no cabe\u00e7alho, pois subrotinas n\u00e3o    retornam valores. Neste caso, \u00e9 preciso passar como argumento a(s)    vari\u00e1vel(eis) onde ser\u00e3o escritos os valores de retorno</li> <li>Os argumentos n\u00e3o necessariamente s\u00e3o apenas para leitura    ( <code>intent(in)</code>), mas podem ser pra leitura e escrita (    <code>intent(inout)</code>) ou apenas escrita    ( <code>intent(out)</code>)</li> <li>Subrotinas s\u00e3o chamadas por <code>call nome_subrotina</code>, e    n\u00e3o apenas o nome do procedimento, como \u00e9 o caso das fun\u00e7\u00f5es</li> </ol> <p>Tal qual nas fun\u00e7\u00f5es, podemos ter quantos argumentos quisermos. No exemplo, temos 3 argumentos na rotina. Para exemplificar os conceitos acima, vamos estruturar uma subrotina que resolva o seguinte problema: dado dois n\u00fameros consecutivos da sequ\u00eancia de fibonacci   e , retornamos  e .</p> <pre><code>    subroutine fib(f1, f2)\n        integer, intent(inout):: f1\n        integer, intent(inout):: f2\n        integer :: prox\n\n        prox = f1 + f2\n\n        f1 = f2\n        f2 = prox\n\n    end subroutine fib\n</code></pre> <p>Destrinchando o c\u00f3digo:</p> <ol> <li>Come\u00e7amos definindo que nossos par\u00e2metros da subrotina ser\u00e3o    utilizados tanto para leitura quanto para escrita, al\u00e9m de    definirmos todas as outras vari\u00e1veis intermedi\u00e1rias que    utilizaremos na subrotina.</li> <li>Calculamos  utilizando  e , e guardamos o    resultado numa vari\u00e1vel intermedi\u00e1ria</li> <li>Atualizamos os valores de <code>f1</code> e <code>f2</code>, e terminamos a    subrotina</li> </ol> <p>Perceba que, diferente das fun\u00e7\u00f5es, n\u00e3o h\u00e1 <code>return</code> e os par\u00e2metros passados sofrem altera\u00e7\u00e3o. Podemos testar o c\u00f3digo chamando a subrotina m\u00faltiplas vezes e exibindo a sequ\u00eancia gerada:</p> <pre><code>    module funcs\n        implicit none\n\n    contains\n        subroutine fib(f1, f2)\n            integer, intent(inout):: f1\n            integer, intent(inout):: f2\n            integer ::      prox\n\n            prox = f1 + f2\n\n            f1 = f2\n            f2 = prox\n\n        end subroutine fib\n    end module funcs\n\n    program test\n        use funcs\n        implicit none\n\n        integer :: f1\n        integer :: f2\n        integer :: i\n\n        f1 = 1\n        f2 = 1\n\n        do i = 1, 10\n            print *, f1, f2\n\n            call fib(f1, f2)\n        end do\n    end program test\n</code></pre> <p>E temos como sa\u00edda:</p> <pre><code>     1           1\n     1           2\n     2           3\n     3           5\n     5           8\n     8          13\n    13          21\n    21          34\n    34          55\n    55          89\n</code></pre> <p>E notamos que a cada chamada da subrotina as vari\u00e1veis <code>f1</code> e <code>f2</code> v\u00e3o tendo seus valores alterados e utilizados nas chamadas seguintes.</p>"},{"location":"Fortran/Fortran_90/#topico-7-construindo-o-metodo-da-bissecao","title":"T\u00f3pico 7: Construindo o M\u00e9todo da Bisse\u00e7\u00e3o","text":"<p>Com as t\u00e9cnincas e estruturas apresentadas nos t\u00f3picos anteriores, agora temos o que precisamos para constru\u00edrmos nossa primeira vers\u00e3o do M\u00e9todo da Bisse\u00e7\u00e3o. Esta primeira vers\u00e3o ser\u00e1 melhorada/modificada nos t\u00f3picos seguintes, por motivos que abordaremos ao final desta sess\u00e3o. Vamos come\u00e7ar relembrando/definindo a ideia algor\u00edtmica do m\u00e9todo em alto n\u00edvel de abstra\u00e7\u00e3o. Em suma, o m\u00e9todo da bisse\u00e7\u00e3o segue os seguintes passos:</p> <ol> <li>Come\u00e7amos informando a fun\u00e7\u00e3o que queremos encontrar o 0, e o    intervalo onde iremos come\u00e7ar a busca</li> <li>Calculamos o ponto m\u00e9dio do intervalo</li> <li>Verificamos se a fun\u00e7\u00e3o neste ponto \u00e9 0</li> <li>Se sim, retornamos este ponto e terminamos</li> <li>Se n\u00e3o, analisamos o sinal da fun\u00e7\u00e3o neste ponto e determinamos    um novo intervalo</li> <li>Repetimos, a partir do passo 2, at\u00e9 um crit\u00e9rio de parada (como    um n\u00famero m\u00e1ximo de passos), para evitarmos um loop infinito.</li> </ol> <p>Vamos contruir este programa utilizando a seguinte abordagem: come\u00e7amos escrevendo as partes centrais do c\u00f3digo primeiro, supondo que dispomos de todas as estruturas intermedi\u00e1rias e fun\u00e7\u00f5es necess\u00e1rias. Ou seja, vamos escrever o c\u00f3digo usando, por exemplo, uma fun\u00e7\u00e3o \"<code>abc(x)</code>\"  sem termos definido \"<code>abc</code>\" ainda, e tendo conclu\u00eddo o c\u00f3digo principal  definimos \"<code>abc</code>\" (pois se n\u00e3o o c\u00f3digo n\u00e3o funcionar\u00e1).</p>"},{"location":"Fortran/Fortran_90/#topico-71-arquitetando-o-codigo","title":"T\u00f3pico 7.1: Arquitetando o c\u00f3digo","text":"<p>Vamos pensar nas estruturas a serem utilizadas em cada passo.</p>"},{"location":"Fortran/Fortran_90/#1-comecamos-informando-a-funcao-que-queremos-encontrar-o-0-e-o-intervalo-onde-iremos-comecar-a-busca","title":"1. Come\u00e7amos informando a fun\u00e7\u00e3o que queremos encontrar o 0, e o intervalo onde iremos come\u00e7ar a busca","text":"<ul> <li>Neste primeiro passo, precisamos pensar em como forneceremos os   dados de entrada. N\u00e3o queremos que nosso programa seja espec\u00edfico   para uma fun\u00e7\u00e3o, mas sim para um grande conjunto de fun\u00e7\u00f5es. Vamos,   portanto, fazer um m\u00f3dulo a parte do programa principal, que seja   importado pelo programa e disponibilize essas fun\u00e7\u00f5es quando   necess\u00e1rias. Para fins de teste, vamos declarar um polin\u00f4mio   como fun\u00e7\u00e3o neste m\u00f3dulo.</li> </ul> <pre><code>    module funcoes\n        implicit none\n\n    contains\n        ! Polin\u00f4mio: x^3 - x - 2\n        function f(x) result(y)\n            real, intent(in) :: x\n            real :: y\n\n            y = x**3 - x - 2\n        end function f\n    end module funcoes\n</code></pre> <ul> <li>J\u00e1 o intervalo gostar\u00edamos de ter maior liberdade de escolha,   pois podemos fazer v\u00e1rias escolhas de onde come\u00e7ar a busca. Vamos,   ent\u00e3o, definir no programa as vari\u00e1veis a serem utilizadas,   que nomearemos <code>a</code> e <code>b</code>.</li> </ul> <pre><code>    program main\n        use funcoes\n\n        use, intrinsic :: iso_fortran_env\n        implicit none\n\n        real(real64) :: resultado\n        real(real64) :: a = 1\n        real(real64) :: b = 2\n\n\n    end program main\n</code></pre> <ul> <li>Por fim, percebendo que o m\u00e9todo recebe como entrada um conjunto de valores   e retorna como resultado um \u00fanico valor (um  tal que ), podemos modelar o   m\u00e9todo como uma fun\u00e7\u00e3o. Por quest\u00e3o de organiza\u00e7\u00e3o, vamos colocar o   m\u00e9todo num m\u00f3dulo pr\u00f3prio e us\u00e1-lo no programa principal. Vamos   escolher, por conveni\u00eancia, trabalhar com precis\u00e3o dupla.</li> </ul> <pre><code>    module metodos\n        use funcoes\n        implicit none\n\n    contains\n        function bissecao(a, b) result(raiz)\n              ! Limite inferior do intervalo\n              real(real64), intent(in) :: a\n\n              ! Limite superior do intervalo\n              real(real64), intent(in) :: b\n\n              ! Valor de x tal que f(x) = 0\n              real(real64) :: raiz\n\n        end function bissecao\n    end module metodos\n\n    program main\n        use funcoes\n        use metodos\n        use, intrinsic :: iso_fortran_env\n        implicit none\n\n        real(real64) :: resultado\n        real(real64) :: a = 1\n        real(real64) :: b = 2\n\n        resultado = bissecao(a, b)\n    end program main\n</code></pre>"},{"location":"Fortran/Fortran_90/#2-calculamos-o-ponto-medio-do-intervalo","title":"2. Calculamos o ponto m\u00e9dio do intervalo","text":"<p>Aqui criamos uma vari\u00e1vel a mais em nossa fun\u00e7\u00e3o da bisse\u00e7\u00e3o e realizamos a m\u00e9dia simples dos limites do intervalo para calcular o ponto m\u00e9dio.  Para evitar reexibir todo o c\u00f3digo, vamos mostrar apenas a fun\u00e7\u00e3o de bissecao, que ser\u00e1 alterada:</p> <pre><code>    function bissecao(a, b) result(raiz)\n        ! Limite inferior do intervalo\n        real(real64), intent(in) :: a\n\n        ! Limite superior do intervalo\n        real(real64), intent(in) :: b\n\n        ! Valor de x tal que f(x) = 0\n        real(real64) :: raiz\n\n        ! Ponto m\u00e9dio\n        real(real64) :: p_medio\n\n        p_medio = (a+b)/2\n\n    end function bissecao\n</code></pre>"},{"location":"Fortran/Fortran_90/#3-verificamos-se-a-funcao-neste-ponto-e-0","title":"3. Verificamos se a fun\u00e7\u00e3o neste ponto \u00e9 0.","text":""},{"location":"Fortran/Fortran_90/#4-se-sim-retornamos-este-ponto-e-terminamos","title":"4. Se sim, retornamos este ponto e terminamos","text":"<p>Estes 2 passos podem ser feitos por um teste condicional</p> <pre><code>    function bissecao(a, b) result(raiz)\n        ! Limite inferior do intervalo\n        real(real64), intent(in) :: a\n\n        ! Limite superior do intervalo\n        real(real64), intent(in) :: b\n\n        ! Valor de x tal que f(x) = 0\n        real(real64) :: raiz\n\n        ! Ponto m\u00e9dio\n        real(real64) :: p_medio\n\n        p_medio = (a+b)/2\n\n        if (f(p_medio) == 0) then\n            raiz = p_medio\n            return\n        end if\n\n    end function bissecao\n</code></pre>"},{"location":"Fortran/Fortran_90/#5-se-nao-analisamos-o-sinal-da-funcao-neste-ponto-e-determinamos-um-novo-intervalo","title":"5. Se n\u00e3o, analisamos o sinal da fun\u00e7\u00e3o neste ponto e determinamos um novo intervalo","text":"<p>Diferente dos passos anteriores, \"fazer a an\u00e1lise de sinal da fun\u00e7\u00e3o e determinar um novo intervalo\" n\u00e3o \u00e9 uma tarefa de poucas instru\u00e7\u00f5es. Por\u00e9m, como o pr\u00f3prio algoritmo nos mostra, tamb\u00e9m n\u00e3o queremos colocar todo o trecho de c\u00f3digo diretamente na fun\u00e7\u00e3o pois isso n\u00e3o deixa claro o que este grande conjunto de instru\u00e7\u00f5es faz. Para manter uma boa legibilidade e modularidade de c\u00f3digo, vamos colocar esta etapa em uma subrotina. Faremos a especifica\u00e7\u00e3o e ajustes referentes \u00e0 subrotina ap\u00f3s terminamos a constru\u00e7\u00e3o da fun\u00e7\u00e3o principal.</p> <pre><code>    function bissecao(a, b) result(raiz)\n        ! Limite inferior do intervalo\n        real(real64), intent(in) :: a\n\n        ! Limite superior do intervalo\n        real(real64), intent(in) :: b\n\n        ! Valor de x tal que f(x) = 0\n        real(real64) :: raiz\n\n        ! Ponto m\u00e9dio\n        real(real64) :: p_medio\n\n        p_medio = (a+b)/2\n\n        if (f(p_medio) == 0) then\n            raiz = p_medio\n            return\n        else\n            call novo_intervalo(a, b)\n        end if\n    end function bissecao\n</code></pre>"},{"location":"Fortran/Fortran_90/#6-repetimos-a-partir-do-passo-2-ate-um-criterio-de-parada-como-um-numero-maximo-de-passos-para-evitarmos-um-loop-infinito","title":"6. Repetimos, a partir do passo 2, at\u00e9 um crit\u00e9rio de parada (como um n\u00famero m\u00e1ximo de passos), para evitarmos um loop infinito.","text":"<p>Para repetir estes passos, envolvemos o trecho do programa em um la\u00e7o <code>do</code>, criando uma vari\u00e1vel de itera\u00e7\u00e3o. Quanto ao crit\u00e9rio de parada, \u00e9 de bom tom que seja um par\u00e2metro que possa ser escolhido por execu\u00e7\u00e3o. Logo, receberemos esta informa\u00e7\u00e3o como argumento de chamada da fun\u00e7\u00e3o.</p> <pre><code>    function bissecao(a, b, n_passos) result(raiz)\n        ! Limite inferior do intervalo\n        real(real64), intent(in) :: a\n\n        ! Limite superior do intervalo\n        real(real64), intent(in) :: b\n\n        ! N\u00ba m\u00e1ximo de passos\n        integer, intent(in) :: n_passos\n\n        ! Valor de x tal que f(x) = 0\n        real(real64) :: raiz\n\n        ! Ponto m\u00e9dio\n        real(real64) :: p_medio\n\n        ! Vari\u00e1vel do loop\n        integer :: i\n\n        do i = 1, n_passos\n            p_medio = (a+b)/2\n            if (f(p_medio) == 0) then\n                raiz = p_medio\n                return\n            else\n                call novo_intervalo(a, b)\n            end if\n        end do\n    end function bissecao\n</code></pre> <p>E nossa implementa\u00e7\u00e3o est\u00e1 quase pronta, a menos da especifica\u00e7\u00e3o da subrotina <code>novo_intervalo</code>.</p>"},{"location":"Fortran/Fortran_90/#especificacao-do-item-5","title":"Especifica\u00e7\u00e3o do item 5","text":"<p>Nossa subrotina ir\u00e1 receber um par  que representa o intervalo atual da busca e retornar\u00e1 um novo par . Portanto, note que a maneira como estamos chamando a subrotina em nossa fun\u00e7\u00e3o de bisse\u00e7\u00e3o n\u00e3o \u00e9 boa, pois <code>a, b</code> s\u00e3o par\u00e2metros da fun\u00e7\u00e3o <code>bissecao</code>. E como vimos na Se\u00e7\u00e3o 3, n\u00e3o devemos alterar par\u00e2metros passados para uma fun\u00e7\u00e3o. Vamos come\u00e7ar, portanto, mudando nossa fun\u00e7\u00e3o de bisse\u00e7\u00e3o para trabalhar com vari\u00e1veis c\u00f3pias dos par\u00e2metros originais</p> <pre><code>    function bissecao(a, b, n_passos) result(raiz)\n        ! Limite inferior do intervalo\n        real(real64), intent(in) :: a\n\n        ! Limite superior do intervalo\n        real(real64), intent(in) :: b\n\n        ! Vari\u00e1vel LOCAL do limite inferior do intervalo\n        real(real64) :: inf\n\n        ! Vari\u00e1vel LOCAL do limite superior do intervalo\n        real(real64) :: sup\n\n        ! N\u00ba m\u00e1ximo de passos\n        integer, intent(in) :: n_passos\n\n        ! Valor de x tal que f(x) = 0\n        real(real64) :: raiz\n\n        ! Ponto m\u00e9dio\n        real(real64) :: p_medio\n\n        ! Vari\u00e1vel do loop\n        integer :: i\n\n        inf = a\n        sup = b\n\n        do i = 1, n_passos\n            p_medio = (inf+sup)/2\n            if (f(p_medio) == 0) then\n                raiz = p_medio\n                return\n            else\n                call novo_intervalo(inf, sup)\n            end if\n        end do\n    end function bissecao\n</code></pre> <p>Agora que estamos chamando a subrotina propriamente, vamos definir melhor sua l\u00f3gica interna.</p> <ol> <li>Primeiro calculamos o ponto m\u00e9dio do intervalo (<code>c</code>)</li> <li>Calculamos <code>f</code> aplicada no ponto m\u00e9dio e <code>f</code> aplicada no limite inferior do intervalo (<code>inf</code>)</li> <li>Se <code>f</code> aplicada em <code>c</code> tiver o mesmo sinal de <code>f</code> aplicada em <code>inf</code>, o novo intervalo \u00e9 (<code>c, sup</code>)</li> <li>Caso contr\u00e1rio, ent\u00e3o sabemos que <code>f</code> aplicada em <code>c</code> tem o mesmo sinal que <code>f</code> aplicada em <code>sup</code>, e o novo intervalo \u00e9 (<code>inf, c</code>)</li> </ol>"},{"location":"Fortran/Fortran_90/#51-calcular-o-ponto-medio-do-intervalo","title":"5.1 Calcular o ponto m\u00e9dio do intervalo","text":"<pre><code>    subroutine novo_intervalo(inf, sup)\n        real(real64), intent(inout) :: inf\n        real(real64), intent(inout) :: sup\n        real(real64) :: c\n\n        c = (inf+sup)/2\n    end subroutine novo_intervalo\n</code></pre>"},{"location":"Fortran/Fortran_90/#52-calcular-finf-e-fc","title":"5.2 Calcular <code>f(inf)</code> e <code>f(c)</code>","text":"<pre><code>    subroutine novo_intervalo(inf, sup)\n        real(real64), intent(inout) :: inf\n        real(real64), intent(inout) :: sup\n        real(real64) :: c\n        real(real64) :: sinal_f_inf\n        real(real64) :: sinal_f_c\n        real(real64) :: novo_inf\n        real(real64) :: novo_sup\n\n        c = (inf+sup)/2\n\n        f_em_inf = f(inf)\n        f_em_c = f(c)\n    end subroutine novo_intervalo\n</code></pre>"},{"location":"Fortran/Fortran_90/#53-testar-sinal-e-determinar-um-novo-intervalo","title":"5.3 Testar sinal e determinar um novo intervalo","text":"<pre><code>    subroutine novo_intervalo(inf, sup)\n        real(real64), intent(inout) :: inf\n        real(real64), intent(inout) :: sup\n        real(real64) :: c\n        real(real64) :: sinal_f_inf\n        real(real64) :: sinal_f_c\n        real(real64) :: novo_inf\n        real(real64) :: novo_sup\n\n        c = (inf+sup)/2\n\n        f_em_inf = f(inf)\n        f_em_c = f(c)\n\n        sinal_f_inf = sign(1.0_real64, f_em_inf)\n        sinal_f_c = sign(1.0_real64, f_em_c)\n\n        if (sinal_f_inf == sinal_f_c) then\n            novo_inf = c\n            novo_sup = sup\n        end if\n\n        inf = novo_inf\n        sup = novo_sup\n    end subroutine novo_intervalo\n</code></pre>"},{"location":"Fortran/Fortran_90/#54-determinar-outro-novo-intervalo-caso-o-primeiro-teste-tenha-falhado","title":"5.4 Determinar outro novo intervalo caso o primeiro teste tenha falhado","text":"<pre><code>    subroutine novo_intervalo(inf, sup)\n        real(real64), intent(inout) :: inf\n        real(real64), intent(inout) :: sup\n        real(real64) :: c\n        real(real64) :: sinal_f_inf\n        real(real64) :: sinal_f_c\n        real(real64) :: novo_inf\n        real(real64) :: novo_sup\n\n        c = (inf+sup)/2\n\n        f_em_inf = f(inf)\n        f_em_c = f(c)\n\n        sinal_f_inf = sign(1.0_real64, f_em_inf)\n        sinal_f_c = sign(1.0_real64, f_em_c)\n\n        if (sinal_f_inf == sinal_f_c) then\n            novo_inf = c\n            novo_sup = sup  \n        else\n            novo_inf = inf\n            novo_sup = c\n        end if\n\n        inf = novo_inf\n        sup = novo_sup\n    end subroutine novo_intervalo\n</code></pre>"},{"location":"Fortran/Fortran_90/#topico-72-codigo-final","title":"T\u00f3pico 7.2: C\u00f3digo Final","text":"<p>Juntando os trechos finais de c\u00f3digo desenvolvidos acima temos a nossa primeira vers\u00e3o do programa:</p> <pre><code>    module funcoes\n        use, intrinsic :: iso_fortran_env\n        implicit none\n\n    contains    \n        ! Polin\u00f4mio: x^3 - x - 2\n        function f(x) result(y)\n            real(real64), intent(in) :: x\n            real(real64) :: y\n\n            y = x**3 - x - 2\n        end function f\n    end module funcoes\n\n    module metodos\n        use funcoes\n        implicit none\n\n    contains\n        subroutine novo_intervalo(inf, sup)\n            real(real64), intent(inout) :: inf\n            real(real64), intent(inout) :: sup\n            real(real64) :: c\n            real(real64) :: sinal_f_inf\n            real(real64) :: sinal_f_c\n            real(real64) :: novo_inf\n            real(real64) :: novo_sup\n\n            c = (inf+sup)/2\n            sinal_f_inf = sign(1.0_real64, f(inf))\n            sinal_f_c = sign(1.0_real64, f(c))\n\n            if (sinal_f_inf == sinal_f_c) then\n                novo_inf = c\n                novo_sup = sup\n\n            else\n                novo_inf = inf\n                novo_sup = c\n            end if\n\n            inf = novo_inf\n            sup = novo_sup\n        end subroutine novo_intervalo\n\n        function bissecao(a, b, n_passos) result(raiz)  \n            ! Limite inferior do intervalo\n            real(real64), intent(in) :: a                           \n\n            ! Limite superior do intervalo\n            real(real64), intent(in) :: b \n\n            ! N\u00ba m\u00e1ximo de passos \n            integer, intent(in) :: n_passos \n\n            ! Valor de x tal que f(x) = 0\n            real(real64) :: raiz \n\n            ! Ponto m\u00e9dio\n            real(real64) :: p_medio\n\n            ! Vari\u00e1vel LOCAL do limite inferior do intervalo\n            real(real64) :: inf\n\n            ! Vari\u00e1vel LOCAL do limite superior do intervalo\n            real(real64) :: sup\n\n            ! Vari\u00e1vel do loop\n            integer :: i\n\n            inf = a\n            sup = b\n\n            do i = 1, n_passos\n                p_medio = (inf+sup)/2\n                if (f(p_medio) == 0) then\n                    raiz = p_medio\n                    return\n\n                else\n                    call novo_intervalo(inf, sup)\n                end if\n            end do\n\n            raiz = p_medio\n        end function bissecao\n    end module metodos\n\n    program main\n        use funcoes\n        use metodos\n        use, intrinsic :: iso_fortran_env\n        implicit none\n\n        real(real64) :: resultado\n        real(real64) :: a = 1\n        real(real64) :: b = 2\n        integer :: n_passos = 20\n\n        resultado = bissecao(a, b, n_passos)\n        print *, resultado\n    end program main\n</code></pre>"},{"location":"Fortran/Fortran_90/#testes","title":"Testes","text":"<p>Rodando nosso programa para o polin\u00f4mio de teste , come\u00e7ando pelo intervalo  e iterando por 22 passos (valores acima na <code>main</code>) obtemos como sa\u00edda:</p> <pre><code>1.5213804244995117\n</code></pre> <p>E avaliando <code>f(resultado)</code> a sa\u00edda \u00e9 <code>4.2658294048258938E-006</code>, que est\u00e1 pr\u00f3ximo de 0 e portanto indica que a sa\u00edda do programa est\u00e1 pr\u00f3xima da raiz do polin\u00f4mio. Se aumentarmos o n\u00famero de itera\u00e7\u00f5es fazendo <code>n_passos = 50</code>, o programa retorna:</p> <pre><code>1.5213797068045674\n</code></pre> <p>E avaliando para esta sa\u00edda <code>f(resultado)</code> obtemos <code>-1.3322676295501878E-015</code>, um resultado ainda melhor e que faz jus ao resultado te\u00f3rico convergente: quanto mais passos, melhor a aproxima\u00e7\u00e3o.</p> <p>Vamos testar para uma outra fun\u00e7\u00e3o mais desafiadora? Troquemos o polin\u00f4mio pela fun\u00e7\u00e3o  </p> <p>Observando o gr\u00e1fico da fun\u00e7\u00e3o, sabemos que esta fun\u00e7\u00e3o possui ra\u00edzes pr\u00f3ximas do valor 10:</p> <p></p> <p>Vamos buscar um valor mais preciso para a raiz logo depois do 10 e antes do 12. Para isso, basta mudarmos nossa fun\u00e7\u00e3o <code>f</code> no m\u00f3dulo de fun\u00e7\u00f5es:</p> <pre><code>    function f(x) result(y)\n        real(real64), intent(in) :: x\n        real(real64) :: y\n\n        y = ((cos(x) * x**5) / exp(x)) + 1\n    end function f\n</code></pre> <p>E podemos utilizar como intervalo de chute inicial  , ou seja, fazemos <code>a = 10</code> e <code>b = 12</code> no programa <code>main</code>. Com 50 passos temos que a raiz \u00e9:</p> <p><pre><code>10.677725261441926     \n</code></pre> E nossa nova <code>f</code> avaliada neste ponto \u00e9 <code>-1.7763568394002505E-015</code>; temos uma \u00f3tima aproxima\u00e7\u00e3o. </p> <p>Fazer com que nosso algoritmo aceite uma fun\u00e7\u00e3o <code>f</code> externa qualquer n\u00e3o \u00e9 trivial, logo estamos satisfeitos, por hora, com este procedimento de trocar a declara\u00e7\u00e3o de <code>f</code> explicitamente no c\u00f3digo. Caso fique curioso sobre como \u00e9 feita esta implementa\u00e7\u00e3o mais gen\u00e9rica, ela envolve uso de uma estrutura ainda n\u00e3o apresentada: <code>interface</code>.</p>"},{"location":"Fortran/Fortran_90/#topico-8-formatacao-de-saidas-write","title":"T\u00f3pico 8: Formata\u00e7\u00e3o de Sa\u00eddas: WRITE","text":"<p>At\u00e9 o momento utilizamos apenas a fun\u00e7\u00e3o <code>print</code> para exibirmos resultados em nossos c\u00f3digos. Por\u00e9m, caso queiramos mostrar sa\u00eddas um pouco melhor elaboradas e formatadas, o uso da fun\u00e7\u00e3o <code>print</code> n\u00e3o \u00e9 o mais adequado. Isso porque esta fun\u00e7\u00e3o foi criada para exibir resultados utilizando uma formata\u00e7\u00e3o espec\u00edfica, pensada na compatibilidade com antigas impressoras e dispositivos de sa\u00edda utilizados nos anos 60 e 70. </p> <p>Para utilizar uma formata\u00e7\u00e3o de sa\u00edda personalizada, foi criada a fun\u00e7\u00e3o <code>write</code>, uma alternativa mais flex\u00edvel que a <code>print</code>.  A fun\u00e7\u00e3o <code>print</code> recebe como primeiro argumento onde ser\u00e1 escrita a sa\u00edda (quando passamos <code>*</code> indicamos que deve ser utilizada a sa\u00edda padr\u00e3o do sistema) e logo em seguida passamos todos os argumentos a serem impressos, separados por v\u00edrgulas. J\u00e1 na fun\u00e7\u00e3o <code>write</code>, passamos entre par\u00eanteses onde ser\u00e1 escrita a sa\u00edda e qual ser\u00e1 a formata\u00e7\u00e3o a ser utilizada, e ent\u00e3o a lista de argumentos a serem impressos, separados por v\u00edrgulas. </p> <p>Logo, a diferen\u00e7a maior est\u00e1 neste segundo argumento de formata\u00e7\u00e3o, chamados de \"descritores de edi\u00e7\u00e3o\". Como eles funcionam? Bom, existe uma lista de formatadores aceitos que podem variar a depender do compilador sendo utilizado. Vamos utilizar a tabela da Fortran Wiki como refer\u00eancia: </p> <p><code>w</code> : o n\u00famero exato de caracteres a serem utilizados</p> <p><code>m</code> : o n\u00famero m\u00ednimo de caracteres a serem utilizados</p> <p><code>d</code> : o n\u00famero de d\u00edgitos \u00e0 direita do ponto decimal</p> <p><code>e</code> : o n\u00famero de d\u00edgitos no expoente</p> Tipo do dado Descritores de        Edi\u00e7\u00e3o Outra op\u00e7\u00e3o <code>integer</code> <code>Iw</code> <code>Iw.m</code> <code>real</code> (nota\u00e7\u00e3o decimal) <code>Fw.d</code> <code>real</code> (nota\u00e7\u00e3o exponencial) <code>Ew.d</code> <code>Ew.dEe</code> <code>real</code> (nota\u00e7\u00e3o cient\u00edfica ) <code>ESw.d</code> <code>ESw.dEe</code> <code>real</code> (nota\u00e7\u00e3o de engenharia) <code>ENw.d</code> <code>ENw.dEe</code> <code>logical</code> <code>Lw</code> <code>character</code> <code>A</code> <code>Aw</code> posicionamento horizontal <code>nX</code> posicionamento de tabula\u00e7\u00e3o <code>Tc</code> <code>TLc</code>, <code>TRc</code> posicionamento vertical <code>/</code> <p>Com isso, podemos formatar a atual sa\u00edda do nosso programa da seguinte forma:  - Mostrar a string \"Raiz encontrada: \", seguida de 12 espa\u00e7os, seguidos do valor calculado para a raiz (<code>resultado</code>) com 15 casas depois da v\u00edrgula. - Logo em seguida mostrar a string \"Fun\u00e7\u00e3o avaliada nessa raiz: \", seguida de 1 espa\u00e7o, seguido do valor <code>f(resultado)</code> com 15 casas depois da v\u00edrgula.</p> <p>Usando os descritores da tabela acima, alteraremos ent\u00e3o o final do nosso programa principal do t\u00f3pico anterior para:</p> <pre><code>    program main\n        use funcoes\n        use metodos\n        use, intrinsic :: iso_fortran_env\n        implicit none\n\n        real(real64) :: resultado\n        real(real64) :: a = 1\n        real(real64) :: b = 2\n        integer :: n_passos = 22\n\n        resultado = bissecao(a, b, n_passos)\n        write (*,'(A, 12X, F20.15)') 'Raiz encontrada: ', resultado\n        write (*,'(A,  1X, F20.15)') 'Fun\u00e7\u00e3o avaliada nessa raiz: ', f(resultado)\n    end program main\n</code></pre> <p>E a sa\u00edda com  e 20 passos:</p> <pre><code>Raiz encontrada:              1.521380424499512\nFun\u00e7\u00e3o avaliada nessa raiz:   0.000004265829405\n</code></pre> <p>Aumentando para 50 passos:</p> <pre><code>Raiz encontrada:              1.521379706804567\nFun\u00e7\u00e3o avaliada nessa raiz:  -0.000000000000001\n</code></pre> <p>Trocando o descritor do segundo <code>write</code> de <code>F20.15</code> para <code>E22.15</code>:</p> <pre><code>Raiz encontrada:              1.521379706804567\nFun\u00e7\u00e3o avaliada nessa raiz:  -0.133226762955019E-14\n</code></pre> <p>E podemos utilizar a formata\u00e7\u00e3o de sa\u00edda que nos for mais conveniente. Aten\u00e7\u00e3o: note que o n\u00famero que segue o <code>E</code> e o <code>F</code> dos descritores precisa levar em conta todos os caracteres exibidos no argumento de sa\u00edda (incluindo sinais, pontos, o pr\u00f3prio \"E\", etc). </p> <p>A sa\u00edda \"-0.133226762955019E-14\" tem exatamente 22 caracteres. Caso coloc\u00e1ssemos um n\u00famero menor que 22 no descritor, a sa\u00edda sairia mal formatada. Veja o que ocorre quando colocamos <code>E20.15</code> :</p> <pre><code>Raiz encontrada:              1.521379706804567\nFun\u00e7\u00e3o avaliada nessa raiz:  ********************\n</code></pre> <p>Na d\u00favida, um tamanho maior que o necess\u00e1rio \u00e9 melhor que um menor.</p>"},{"location":"Fortran/Fortran_90/#topico-9-repeticao-do-while","title":"T\u00f3pico 9: Repeti\u00e7\u00e3o: DO - WHILE","text":""},{"location":"Fortran/Fortran_90/#topico-10-imports-e-linkagem","title":"T\u00f3pico 10: Imports e Linkagem","text":""},{"location":"Julia/capitulo_1/","title":"1. Introdu\u00e7\u00e3o","text":"<p>Este cap\u00edtulo foca em introduzir conceitos fundamentais relacionados \u00e0 linguagem de programa\u00e7\u00e3o Julia, abordando sua sintaxe, compilador JIT (Just-In-Time) e aspectos gerais de programa\u00e7\u00e3o com Julia.</p>"},{"location":"Julia/capitulo_1/#11-caracteristicas-da-linguagem-julia","title":"1.1. Caracter\u00edsticas da Linguagem Julia","text":"<p>Julia \u00e9 uma linguagem de programa\u00e7\u00e3o de alto desempenho para computa\u00e7\u00e3o t\u00e9cnica. Ela combina a facilidade de uma linguagem de script com a pot\u00eancia de linguagens compiladas, oferecendo um sistema de tipos din\u00e2mico, efici\u00eancia de desempenho e uma sintaxe elegante. Essa combina\u00e7\u00e3o de recursos facilita a express\u00e3o de muitos algoritmos num\u00e9ricos e a manipula\u00e7\u00e3o de dados, tornando Julia uma escolha excelente para ci\u00eancia de dados, an\u00e1lise num\u00e9rica, e mais. Abaixo, algumas caracter\u00edsticas chave de Julia:</p> <ul> <li>Desempenho de Alto N\u00edvel: Gra\u00e7as \u00e0 sua compila\u00e7\u00e3o JIT, Julia oferece desempenho que pode rivalizar com o de linguagens tradicionalmente compiladas como C e Fortran;</li> <li>Facilidade de Uso: A sintaxe de Julia \u00e9 clara e concisa, tornando a programa\u00e7\u00e3o em Julia acess\u00edvel para programadores de todos os n\u00edveis;</li> <li>Computa\u00e7\u00e3o Paralela e Distribu\u00edda: Julia foi desenhada com a paraleliza\u00e7\u00e3o e computa\u00e7\u00e3o distribu\u00edda em mente, permitindo a execu\u00e7\u00e3o eficiente de c\u00f3digo em clusters e na nuvem;</li> <li>Ecosistema Rico: A comunidade Julia desenvolveu um vasto ecossistema de pacotes, cobrindo diversas \u00e1reas como aprendizado de m\u00e1quina, visualiza\u00e7\u00e3o de dados, manipula\u00e7\u00e3o de dados, entre outros;</li> <li>Interoperabilidade: Julia permite a chamada de fun\u00e7\u00f5es de outras linguagens, como Python, C, e Fortran, facilitando a integra\u00e7\u00e3o com bibliotecas e sistemas existentes;</li> </ul> <p>Abaixo, voc\u00ea encontrar\u00e1 uma tabela com alguns tipos de dados b\u00e1sicos em Julia, destacando as palavras-chave utilizadas para a defini\u00e7\u00e3o de vari\u00e1veis e os formatos para a sua manipula\u00e7\u00e3o:</p> <p>Tabela de dados b\u00e1sicos em Julia</p> PALAVRA-CHAVE TIPO DESCRI\u00c7\u00c3O EXEMPLO DE USO Int Inteiro Tipo padr\u00e3o de inteiro, variando conforme a arquitetura (32 ou 64 bits) 5, -3 Float64 Ponto flutuante N\u00famero real em precis\u00e3o dupla 3.14, -2.71 Bool Booleano Verdadeiro ou falso true, false String Cadeia de caracteres Texto \"Ol\u00e1, mundo!\" Char Caractere Um \u00fanico caractere unicode 'a', '3' <p>\u00c9 importante destacar que Julia \u00e9 projetada para ser f\u00e1cil e intuitiva para usu\u00e1rios de outras linguagens de programa\u00e7\u00e3o, sem sacrificar o desempenho. Ao longo deste texto, exploraremos mais sobre como Julia atinge esse equil\u00edbrio e como voc\u00ea pode come\u00e7ar a aproveitar suas capacidades em seus pr\u00f3prios projetos de programa\u00e7\u00e3o.</p>"},{"location":"Julia/capitulo_1/#12-o-sistema-de-tipos-em-julia","title":"1.2. O Sistema de Tipos em Julia","text":"<p>O sistema de tipos em Julia \u00e9 sofisticado e permite defini\u00e7\u00f5es de tipos abstratos e concretos, heran\u00e7a de tipos e muito mais. A linguagem \u00e9 dinamicamente tipada, mas seu sistema de tipos \u00e9 projetado para promover pr\u00e1ticas que maximizam o desempenho do c\u00f3digo.</p> <p>A seguir, detalhamos o processo de compila\u00e7\u00e3o JIT em Julia, que \u00e9 fundamental para o seu desempenho.</p>"},{"location":"Julia/capitulo_1/#13-compilacao-just-in-time-jit-em-julia","title":"1.3. Compila\u00e7\u00e3o Just-In-Time (JIT) em Julia","text":"<p>A compila\u00e7\u00e3o Just-In-Time (JIT) \u00e9 uma das caracter\u00edsticas que distinguem Julia de outras linguagens de programa\u00e7\u00e3o. Em vez de compilar o c\u00f3digo para uma linguagem de m\u00e1quina de antem\u00e3o (Ahead-of-Time), Julia compila o c\u00f3digo no momento da execu\u00e7\u00e3o. Isso permite uma otimiza\u00e7\u00e3o espec\u00edfica para o hardware do usu\u00e1rio e melhora significativamente a velocidade de execu\u00e7\u00e3o de programas Julia, especialmente em c\u00e1lculos num\u00e9ricos e cient\u00edficos.</p> <p>Essa abordagem traz o melhor de dois mundos: a flexibilidade de uma linguagem interpretada, com a efici\u00eancia de uma linguagem compilada, tornando Julia uma excelente escolha para uma ampla gama de aplica\u00e7\u00f5es cient\u00edficas e t\u00e9cnicas.</p>"}]}