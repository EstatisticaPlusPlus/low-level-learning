{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Sobre","text":"<p>o projeto de extens\u00e3o visa criar materiais educacionais sobre as linguagens de programa\u00e7\u00e3o C e Fortran. Inicialmente, os materiais foram feitos em LaTeX, destacando os conceitos b\u00e1sicos de C e explorando o compilador GCC. Mais tarde, optamos por migrar para uma plataforma online usando HTML5 e CSS para oferecer conte\u00fado mais acess\u00edvel e interativo aos usu\u00e1rios interessados. Por fim, estou repassando para o MkDocs para facilitar a adi\u00e7\u00e3o de novos cap\u00edtulos. Essa transi\u00e7\u00e3o permitir\u00e1 uma melhor experi\u00eancia de aprendizado para os estudantes e entusiastas das linguagens.</p>"},{"location":"#estrutura","title":"Estrutura","text":"<p>Em constru\u00e7\u00e3o..</p>"},{"location":"#inspiracao","title":"Inspira\u00e7\u00e3o","text":"<p>Cap\u00edtulos da Linguagem C:</p> <p>\"An Introduction to GCC\" \u00e9 um livro que oferece uma introdu\u00e7\u00e3o pr\u00e1tica e abrangente sobre o compilador GNU Compiler Collection (GCC) e seu uso na programa\u00e7\u00e3o em linguagem C. Os autores explicam desde conceitos b\u00e1sicos at\u00e9 t\u00e9cnicas avan\u00e7adas de compila\u00e7\u00e3o, incluindo o funcionamento interno do GCC. \u00c9 uma leitura \u00fatil para estudantes e desenvolvedores interessados em compreender melhor como usar o GCC para compilar programas em C e aprofundar seus conhecimentos sobre compila\u00e7\u00e3o, otimiza\u00e7\u00e3o e depura\u00e7\u00e3o de c\u00f3digo.</p> <p>Cap\u00edtulos em Fortran:</p> <ul> <li>Fortran 77: Guia de Stanford para F77</li> <li>Fortran 90: ...</li> </ul>"},{"location":"#referencias","title":"Refer\u00eancias","text":"<p>UGH, Brian J.; STALLMAN, Richard M. An Introduction to GCC. Network Theory Ltd., 2004. ISBN 978-0954161798.</p> <p>TANFORD UNIVERSITY. ME 200C - Basics of the Finite Element Method. Dispon\u00edvel em: https://web.stanford.edu/class/me200c/tutorial_77/03_basics.html. Acesso em: 23 mar. 2025.</p>"},{"location":"Fortran/Fortran_77/","title":"Cap\u00edtulo 3 - Fortran 77","text":"<p>Neste cap\u00edtulo vamos retomar v\u00e1rios t\u00f3picos j\u00e1 abordados, adequando-os ao Fortran 77. Sua leitura fica a crit\u00e9rio da curiosidade ou necessidade do leitor.</p> <p>Este material foi fortemente inspirado no guia de Stanford para F77, dispon\u00edvel em Stanford ME200C Tutorial.</p>"},{"location":"Fortran/Fortran_77/#basico","title":"B\u00e1sico","text":"<p>A estrutura prim\u00e1ria do c\u00f3digo F77 \u00e9 da forma:</p> <pre><code>      c234567   \n      program *nome*\n\n      *declara\u00e7\u00f5es de vari\u00e1veis*\n\n      *comandos*\n\n      stop\n      end\n</code></pre> <p>A formata\u00e7\u00e3o da vers\u00e3o 77 \u00e9 r\u00edgida, seguindo um padr\u00e3o ditado pelo n\u00famero referente \u00e0 coluna no editor de texto, da seguinte forma:</p> <ul> <li>Coluna 1: Vazia ou preencha com \"c\" ou \"*\" para usar a linha como coment\u00e1rio.</li> <li>Colunas 1-5: Categoria da declara\u00e7\u00e3o da linha.</li> <li>Coluna 6: Indica a continua\u00e7\u00e3o da linha pr\u00e9via (opcional).</li> <li>Colunas 7-72: Comando.</li> <li>Colunas 73-80: N\u00famero de sequ\u00eancia (uso incomum).</li> </ul> <p>Importante salientar que n\u00e3o podemos ter uma vari\u00e1vel com o mesmo nome que o programa.</p> <pre><code>      c234567\n      PROGRAM HELLO\n      WRITE(UNIT=*, FMT=*) 'Hello World'\n      STOP\n      END\n\n      *exemplo do programa b\u00e1sico usual, note que os comandos come\u00e7am a partir da coluna 7*\n</code></pre> <p>Note que no c\u00f3digo acima o comando <code>write(UNIT=*, FMT=*)</code> tamb\u00e9m poder\u00e1 ser escrito como <code>write(*,*)</code>, o que \u00e9 uma simplifica\u00e7\u00e3o usual na atribui\u00e7\u00e3o desses argumentos compuls\u00f3rios.</p>"},{"location":"Fortran/Fortran_77/#variaveis-tipos-e-declaracoes","title":"Vari\u00e1veis, Tipos e Declara\u00e7\u00f5es","text":"<p>Vari\u00e1veis em Fortran consistem em no m\u00e1ximo 6 caracteres alfanum\u00e9ricos, iniciando com uma letra, sem diferenciar mai\u00fasculas e min\u00fasculas. Palavras reservadas como <code>program</code>, <code>real</code>, <code>stop</code> e <code>end</code> n\u00e3o podem ser usadas como nomes de vari\u00e1veis.</p> <p>Toda vari\u00e1vel deve ser definida em uma declara\u00e7\u00e3o que estabelece seu tipo, como:</p> <ul> <li>integer</li> <li>real</li> <li>double precision</li> <li>complex</li> <li>logical</li> <li>character</li> </ul> <p>Embora o Fortran utilize regras impl\u00edcitas se a vari\u00e1vel n\u00e3o for declarada, \u00e9 boa pr\u00e1tica usar <code>implicit none</code> para evitar ambiguidades e for\u00e7ar a declara\u00e7\u00e3o de todas as vari\u00e1veis.</p> <ul> <li>O tipo integer geralmente tem 32 bits, com limite aproximado de \u00b12\u00d710\u2079.</li> <li>Existem dois tipos de float: real (4 bytes) e double precision (8 bytes).</li> </ul> <p>Para definir constantes, declara-se um par\u00e2metro na sintaxe:</p> <pre><code>      parameter (name = constant, ..., name = constant)\n</code></pre> <p>O par\u00e2metro deve ser definido antes da primeira execu\u00e7\u00e3o do c\u00f3digo.</p> <pre><code>      c234567\n      PROGRAM TYPES\n      IMPLICIT NONE\n\n      ! Determina a declara\u00e7\u00e3o do tipo de vari\u00e1veis\n      INTEGER alfa, beta, delta\n\n      PARAMETER (alfa = 5, beta = 10)\n\n      delta = alfa + beta\n      write (*,*) 'Resulta em', delta\n\n      STOP\n      END\n</code></pre>"},{"location":"Fortran/Fortran_77/#expressoes-e-atribuicoes","title":"Express\u00f5es e Atribui\u00e7\u00f5es","text":""},{"location":"Fortran/Fortran_77/#expressoes","title":"Express\u00f5es","text":"<p>Uma express\u00e3o \u00e9 uma combina\u00e7\u00e3o de operandos e operadores, como em <code>x + y</code> (onde <code>x</code> e <code>y</code> s\u00e3o operandos e <code>+</code> \u00e9 o operador). O resultado de uma express\u00e3o torna-se um novo operando, permitindo nesting (express\u00f5es aninhadas).</p> <p>Existem constantes de seis tipos: integer, real, double precision, complex, logical e character. - O uso de <code>E</code> em um valor, como <code>2.0E6</code>, implica que o valor anterior \u00e0 <code>E</code> deve ser multiplicado por 10 elevado ao n\u00famero \u00e0 direita de <code>E</code> (ou seja, <code>2.0E6 = 2 * 10^6</code>). - Valores complexos s\u00e3o expressos como um par de constantes (por exemplo, <code>(2, -3)</code> ou <code>(1., 9.9E-1)</code>), onde o primeiro \u00e9 a parte real e o segundo a parte imagin\u00e1ria. - Constantes l\u00f3gicas s\u00e3o expressas como <code>.True.</code> ou <code>.False.</code> (os pontos s\u00e3o obrigat\u00f3rios). - Constantes de caractere, ou strings, s\u00e3o delimitadas por aspas simples (ex.: <code>'ABC'</code>, <code>'potato potato'</code>) e s\u00e3o sens\u00edveis a mai\u00fasculas e min\u00fasculas.</p>"},{"location":"Fortran/Fortran_77/#atribuicoes","title":"Atribui\u00e7\u00f5es","text":"<p>A sintaxe para atribui\u00e7\u00f5es \u00e9:</p> <pre><code>nome_da_variavel = express\u00e3o\n</code></pre> <p>O valor da express\u00e3o \u00e0 direita \u00e9 avaliado e atribu\u00eddo \u00e0 vari\u00e1vel \u00e0 esquerda.</p>"},{"location":"Fortran/Fortran_77/#conversao-de-tipos","title":"Convers\u00e3o de Tipos","text":"<p>Quando diferentes tipos de dados s\u00e3o usados em uma express\u00e3o, pode ocorrer convers\u00e3o impl\u00edcita ou \u00e9 necess\u00e1rio for\u00e7ar a convers\u00e3o usando fun\u00e7\u00f5es como: - <code>int</code> (para converter para integer) - <code>real</code> (para converter para real) - <code>dble</code> (para converter para double precision) - <code>ichar</code> (converte caractere em inteiro) - <code>char</code> (converte inteiro em caractere)</p> <p>Note que <code>w = dble(x) * dble(y)</code> difere de <code>w = dble(x*y)</code> para vari\u00e1veis reais <code>x</code> e <code>y</code>.</p>"},{"location":"Fortran/Fortran_77/#operadores-logicos-e-condicionais","title":"Operadores L\u00f3gicos e Condicionais","text":""},{"location":"Fortran/Fortran_77/#operadores-logicos","title":"Operadores L\u00f3gicos","text":"<p>Para comparar express\u00f5es, utilizamos operadores relacionais que avaliam como <code>.True.</code> ou <code>.False.</code>:</p> <ul> <li><code>.LT.</code> : \"menor que\" (equivalente a <code>&lt;</code>)</li> <li><code>.GT.</code> : \"maior que\" (equivalente a <code>&gt;</code>)</li> <li><code>.LE.</code> : \"menor ou igual\" (equivalente a <code>&lt;=</code>)</li> <li><code>.GE.</code> : \"maior ou igual\" (equivalente a <code>&gt;=</code>)</li> <li><code>.EQ.</code> : \"igual\" (equivalente a <code>=</code>)</li> <li><code>.NQ.</code> : \"diferente\" (equivalente a <code>!=</code>)</li> </ul> <p>Outros termos \u00fateis s\u00e3o: - <code>.AND.</code> - <code>.OR.</code> - <code>.NOT.</code></p>"},{"location":"Fortran/Fortran_77/#condicionais","title":"Condicionais","text":"<p>Condi\u00e7\u00f5es s\u00e3o estruturadas de tr\u00eas maneiras:</p> <ol> <li> <p>Condi\u00e7\u00e3o em linha \u00fanica:    Se a condi\u00e7\u00e3o l\u00f3gica for verdadeira, execute o comando.    <code>fortran          if (x .LT. 0) x = -x</code></p> </li> <li> <p>Condi\u00e7\u00e3o com m\u00faltiplos comandos: <code>fortran          if (condi\u00e7\u00e3o l\u00f3gica) then              comandos          endif</code></p> </li> <li> <p>Condi\u00e7\u00e3o com alternativas: <code>fortran          if (condi\u00e7\u00e3o l\u00f3gica) then              comandos          elseif (outra condi\u00e7\u00e3o l\u00f3gica) then              comandos          else              comandos          endif</code></p> </li> </ol>"},{"location":"Fortran/Fortran_77/#exemplo-cadastro-de-numeros-telefonicos-com-ddd","title":"Exemplo: Cadastro de N\u00fameros Telef\u00f4nicos com DDD","text":"<pre><code>      c234567\n      PROGRAM CONDITIONALS\n      IMPLICIT NONE\n      CHARACTER*11 NUMBER\n      CHARACTER*9 REST\n      INTEGER LEN\n\n      write (*,*) 'Input Number:'\n      read (*,*) NUMBER\n\n      LEN = LEN_TRIM(NUMBER)\n\n      IF (LEN .GT. 3) THEN\n          REST = NUMBER(3:LEN)\n      ELSE\n          REST = ''\n      END IF\n\n      IF (LEN .LT. 8 .OR. LEN .GT. 11) then\n          write(*,*) 'Invalid Number'\n      ELSE IF (LEN .EQ. 8 .OR. LEN .EQ. 9) then\n          write(*,*) NUMBER\n      ELSE IF (LEN .EQ. 10 .OR. LEN .EQ. 11) then         \n          write(*,*) 'DDD and number are ', NUMBER(1:2) // ' ' // REST\n      END IF\n\n      STOP\n      END\n</code></pre> <p>Funcionamento do Programa: - Solicita ao usu\u00e1rio um n\u00famero de telefone (string). - Calcula o comprimento real da string com <code>LEN_TRIM</code>. - Se o comprimento for menor que 8 ou maior que 11, imprime \"Invalid Number\". - Se for 8 ou 9, imprime o n\u00famero diretamente. - Se for entre 10 e 11, imprime o DDD (dois primeiros caracteres), um espa\u00e7o e o restante do n\u00famero.</p>"},{"location":"Fortran/Fortran_77/#loops","title":"Loops","text":""},{"location":"Fortran/Fortran_77/#do-loops","title":"Do Loops","text":"<p>A sintaxe geral \u00e9:</p> <pre><code>      c23456789\n      do label var = expr1, expr2, expr3\n          statements\n      label continue\n</code></pre> <ul> <li>var: vari\u00e1vel do loop (deve ser inteiro)</li> <li>expr1: valor inicial</li> <li>expr2: valor limitante</li> <li>expr3: incremento</li> </ul> <p>Exemplo:</p> <pre><code>      c234567\n      PROGRAM SHOW\n      IMPLICIT NONE\n\n      INTEGER a(10), I\n\n      DATA a /1, 2, 3, 4, 5, 6, 7, 8, 9, 10/\n\n      DO 10 I = 1, 10\n          PRINT *, 'Elemento', I, ':', a(I)\n10    CONTINUE\n\n      END\n</code></pre>"},{"location":"Fortran/Fortran_77/#while-loops-condicao-de-progresso","title":"While Loops (Condi\u00e7\u00e3o de Progresso)","text":"<p>Embora o m\u00e9todo abaixo seja o mais intuitivo, ele n\u00e3o \u00e9 ANSI Fortran 77. O adequado \u00e9:</p> <pre><code>      c23456789\n      label if (logical expr) then\n          statements\n          goto label\n      end if\n</code></pre> <p>Exemplo com While:</p> <pre><code>      c234567\n      PROGRAM WOW\n      IMPLICIT NONE\n\n      INTEGER a(10), I\n\n      DATA a /1, 2, 3, 4, 5, 6, 7, 8, 9, 10/\n\n      I = 1\n\n10    IF (a(I) /= 5) THEN\n          PRINT *, 'Elemento', I, ':', a(I)\n          I = I + 1\n          GOTO 10\n      END IF\n\n      END\n</code></pre>"},{"location":"Fortran/Fortran_77/#until-loops-condicao-de-parada","title":"Until Loops (Condi\u00e7\u00e3o de Parada)","text":"<p>Um exemplo de loop \"until\" usando <code>goto</code>:</p> <pre><code>      c23456789\n10    CONTINUE\n      PRINT *, 'Elemento', I, ':', a(I)\n      I = I + 1\n      IF (a(I) /= 9) THEN       \n          GOTO 10\n      END IF\n      END\n</code></pre>"},{"location":"Fortran/Fortran_77/#subprogramas","title":"Subprogramas","text":"<p>Subprogramas s\u00e3o blocos de c\u00f3digo que resolvem tarefas espec\u00edficas, podendo ser fun\u00e7\u00f5es ou subrotinas.</p>"},{"location":"Fortran/Fortran_77/#funcoes","title":"Fun\u00e7\u00f5es","text":"<p>Fun\u00e7\u00f5es recebem um ou mais argumentos e retornam um valor. A maioria das fun\u00e7\u00f5es inatas (como <code>abs</code>, <code>min</code>, <code>max</code>, <code>sqrt</code>) s\u00e3o gen\u00e9ricas, mas fun\u00e7\u00f5es definidas pelo usu\u00e1rio geralmente precisam especificar o tipo de retorno. O valor de retorno \u00e9 atribu\u00eddo \u00e0 vari\u00e1vel com o mesmo nome da fun\u00e7\u00e3o e o bloco termina com <code>RETURN</code>.</p> <pre><code>      c23456789\n      PROGRAM CHOOSE\n      IMPLICIT NONE\n\n      INTEGER P, R, QUADRADO\n\n      WRITE(*,*) 'CHOOSE A NUMBER 1 TO 10'\n      READ (*,*) P\n\n      R = QUADRADO(P)\n\n      WRITE(*,*) 'O RESULTADO \u00c9', R\n\n      END\n\n      INTEGER FUNCTION QUADRADO(X)\n      IMPLICIT NONE\n      INTEGER X\n\n      QUADRADO = X * X\n\n      RETURN\n      END\n</code></pre>"},{"location":"Fortran/Fortran_77/#subrotinas","title":"Subrotinas","text":"<p>Subrotinas podem retornar mais de um valor e s\u00e3o invocadas com <code>CALL</code>. Elas n\u00e3o possuem tipo.</p> <pre><code>      c2345678\n      PROGRAM CHAMA_SUBROTINA\n      IMPLICIT NONE\n\n      INTEGER N, QUADRADO, CUBO\n\n      PRINT *, 'Digite um n\u00famero:'\n      READ *, N\n\n      CALL CALCULA_QUADRADO_E_CUBO(N, QUADRADO, CUBO)\n\n      PRINT *, 'O quadrado de', N, '\u00e9', QUADRADO\n      PRINT *, 'O cubo de', N, '\u00e9', CUBO\n\n      END\n\n      SUBROUTINE CALCULA_QUADRADO_E_CUBO(X, QUAD, CUB)\n      IMPLICIT NONE\n      INTEGER X, QUAD, CUB\n\n      QUAD = X * X\n      CUB = X * X * X\n\n      RETURN\n      END\n</code></pre>"},{"location":"Fortran/Fortran_77/#arrays","title":"Arrays","text":"<p>Para declarar vetores e matrizes:</p> <pre><code>      c23456789\n      real a(20)\n      ! Declara um vetor com 20 componentes reais, indexados de 1 a 20\n\n      real A(3,5)\n      ! Declara uma matriz 3x5\n\n      logical B(20,5,39,29152)\n      ! Declara um array 20x5x39x2\n</code></pre> <p>Fortran 77 permite arrays de at\u00e9 7 dimens\u00f5es.</p>"},{"location":"Fortran/Fortran_77/#manipulacao-de-arrays","title":"Manipula\u00e7\u00e3o de Arrays","text":""},{"location":"Fortran/Fortran_77/#inicializacao-em-loop","title":"Inicializa\u00e7\u00e3o em Loop","text":"<pre><code>      c23456789\n      PROGRAM EXEMPLO_ARRAY\n      IMPLICIT NONE\n\n      INTEGER :: N = 5\n      INTEGER :: A(N)\n      INTEGER :: I\n\n      DO I = 1, N\n          A(I) = I * 2   \n      END DO\n\n      PRINT *, 'Elementos do array A:'\n      DO I = 1, N\n          PRINT *, 'A(', I, ') = ', A(I)\n      END DO\n\n      END\n</code></pre>"},{"location":"Fortran/Fortran_77/#soma-de-elementos","title":"Soma de Elementos","text":"<pre><code>      c23456789\n      PROGRAM SOMA_ARRAY\n      IMPLICIT NONE\n\n      INTEGER :: N = 5\n      INTEGER :: A(N) = (/1, 2, 3, 4, 5/)\n      INTEGER :: SUM\n      INTEGER :: I\n\n      SUM = 0\n\n      DO I = 1, N\n          SUM = SUM + A(I)\n      END DO\n\n      PRINT *, 'Soma dos elementos de A:', SUM\n\n      END\n</code></pre>"},{"location":"Fortran/Fortran_77/#produto-de-elementos","title":"Produto de Elementos","text":"<pre><code>      c23456789\n      PROGRAM MULTIPLICACAO_ARRAY\n      IMPLICIT NONE\n\n      INTEGER :: N = 5\n      INTEGER :: A(N) = (/1, 2, 3, 4, 5/)\n      INTEGER :: PRODUTO\n      INTEGER :: I\n\n      PRODUTO = 1\n\n      DO I = 1, N\n          PRODUTO = PRODUTO * A(I)\n      END DO\n\n      PRINT *, 'Produto dos elementos de A:', PRODUTO\n\n      END\n</code></pre>"},{"location":"Fortran/Fortran_77/#common-blocks","title":"Common Blocks","text":"<p>Common blocks permitem compartilhar vari\u00e1veis entre subprogramas. O bloco comum deve ser declarado antes das execu\u00e7\u00f5es.</p> <pre><code>      program main\n      ! Declara\u00e7\u00f5es\n      real alpha, beta\n      common /coeff/ alpha, beta\n\n      ! Statements\n      stop\n      end\n\n      subroutine sub1(...)\n      real alpha, beta\n      common /coeff/ alpha, beta\n\n      ! Statements\n      return\n      end\n\n      subroutine sub2(...)\n      real alpha, beta\n      common /coeff/ alpha, beta\n\n      ! Statements\n      return\n      end\n</code></pre> <p>Regras importantes: - O bloco comum deve ser declarado antes da execu\u00e7\u00e3o do c\u00f3digo. - Blocos comuns distintos devem ter nomes distintos. - Uma vari\u00e1vel n\u00e3o pode aparecer em dois blocos comuns diferentes. - Vari\u00e1veis devem ser listadas na mesma ordem, com o mesmo tipo e tamanho em todas as rotinas que utilizam o mesmo bloco comum. - Arrays com dimens\u00f5es vari\u00e1veis n\u00e3o devem constar em blocos comuns.</p>"},{"location":"Fortran/Fortran_77/#data-e-block-statements","title":"Data e Block Statements","text":"<p>O <code>data</code> statement \u00e9 usado para inicializar vari\u00e1veis antes da execu\u00e7\u00e3o do programa.</p> <pre><code>      c23456789\n      program main\n      data m/10/, n/20/, x/2.5/, y/2.5/\n      real m, n, x, y\n\n      write (*,*) m\n      write (*,*) n \n      write (*,*) x\n      write (*,*) y\n      STOP\n      END\n</code></pre> <p>Outra forma:</p> <pre><code>      c23456789\n      program main\n      data m,n/10,20/, x,y/2*2.5/\n      real m, n, x, y\n\n      write (*,*) m\n      write (*,*) n\n      write (*,*) x\n      write (*,*) y\n      STOP\n      END\n</code></pre> <p>Com matrizes:</p> <pre><code>      c23456789\n      program main\n      real A(10,20)\n      data A/ 200 * 0.0/\n      ...\n</code></pre> <p>O exemplo acima inicializa uma matriz 10x20 com todos os 200 valores iguais a zero.</p>"},{"location":"Fortran/Fortran_77/#file-io","title":"File I.O.","text":"<p>O comando principal para acessar um arquivo \u00e9:</p> <pre><code>      open ([UNIT=]u [, IOSTAT=ios, ERR=err, STATUS=sta])\n</code></pre> <p>Especificadores comuns: - unidade (\"u\"): valor inteiro \u00fanico de 1 a 99 que identifica o arquivo. - status (\"ios\"): vari\u00e1vel inteira que retorna zero se a opera\u00e7\u00e3o for bem-sucedida. - error (\"err\"): determina para qual comando o programa deve saltar em caso de erro. - nome (\"fname\"): nome do arquivo a ser acessado (string). - status (\"sta\"): deve ser NEW, OLD ou SCRATCH; define se o arquivo j\u00e1 existe ou se deve ser criado e se ser\u00e1 deletado ap\u00f3s o fechamento. - final (\"end\"): determina para qual comando o programa deve saltar ao chegar ao fim do arquivo (usado em <code>read</code> ou <code>write</code>).</p> <p>Para fechar o arquivo, usa-se:</p> <pre><code>      close ([UNIT=]u [, IOSTAT=ios, ERR=err, STATUS=sta])\n</code></pre> <p>Os comandos <code>read</code> e <code>write</code> s\u00e3o usados com o especificador de unidade obrigat\u00f3rio.</p> <p>Exemplo:</p> <pre><code>      c234567\n      program inpdat\n      ! Este programa l\u00ea n pontos de um arquivo e os armazena em 3 arrays: x, y, z.\n\n      integer nmax, u\n      parameter (nmax=1000, u=20)\n      real x(nmax), y(nmax), z(nmax)\n\n      ! Abre o arquivo de dados\n      open (u, FILE='points.dat', STATUS='OLD')\n\n      ! L\u00ea o n\u00famero de pontos\n      read(u,*) n\n      if (n.GT.nmax) then\n          write(*,*) 'Error: n = ', n, 'is larger than nmax =', nmax\n          goto 9999\n      endif\n\n      ! Loop sobre os pontos\n      do 10 i= 1, n\n          read(u,100) x(i), y(i), z(i)\n10    enddo\n100   format (3(F10.4))\n\n      ! Fecha o arquivo\n      close (u)\n\n      ! (Parte faltante para processar os dados)\n\n9999  stop\n      end\n</code></pre>"},{"location":"Fortran/Fortran_77/#format","title":"Format","text":"<p>A formata\u00e7\u00e3o \u00e9 definida com o comando <code>write</code> seguido de um label que especifica o formato.</p> <pre><code>      c23456789\n      program main\n      data m/10/, n/20/, x/2.5/, y/2.5/\n      real m, n, x, y\n\n      write (*,*) m\n      write (*,*) n\n      write (*,*) x\n      write (*,*) y\n      STOP\n      END\n</code></pre> <p>A sa\u00edda deste c\u00f3digo seria algo como:</p> <pre><code>10.0000000\n20.0000000\n2.50000000\n2.50000000\n</code></pre> <p>A formata\u00e7\u00e3o pode ser alterada seguindo o padr\u00e3o:</p> <pre><code>      c234567      \n      write(*,label) lista_de_variaveis\n      label format-code \n</code></pre> <p>C\u00f3digos comuns de formata\u00e7\u00e3o: - A: string de texto - D: n\u00fameros em double precision, nota\u00e7\u00e3o exponencial - E: n\u00fameros reais, nota\u00e7\u00e3o exponencial - F: n\u00fameros reais, formato fixo - I: inteiro - X: espa\u00e7o horizontal - /: salto de linha</p> <p>Exemplo:</p> <pre><code>      c23456789\n      program main\n      data m/10/, n/20/, x/2.5/, y/2.5/\n\n      ! Escreve m com formato I2\n      write (*,100) m\n100   format (I2)\n\n      ! Escreve n com formato inline\n      write (*,'(I2)') n  \n\n      ! Escreve x com formato F4.1\n      write (*,300) x\n300   format (F4.1)\n\n      ! Escreve y com formato E8.2\n      write (*,400) y\n400   format (E8.2)\n\n      STOP\n      END\n</code></pre> <p>Sa\u00edda esperada:</p> <pre><code>10\n20\n2.5\n0.25E+01\n</code></pre>"},{"location":"Fortran/Fortran_77/#bibliotecas","title":"Bibliotecas","text":"<p>Como em qualquer outra linguagem, \u00e9 poss\u00edvel utilizar pacotes j\u00e1 criados (muitos gratuitos) para resolver problemas comuns. Para problemas num\u00e9ricos, por exemplo, a plataforma Netlib disponibiliza softwares e databases de interesse cient\u00edfico, como os pacotes BLAS e LAPACK.</p>"},{"location":"Fortran/Fortran_77/#blas","title":"BLAS","text":"<ul> <li>Acr\u00f4nimo de Basic Linear Algebra Subroutines.</li> <li>Cont\u00e9m subprogramas para opera\u00e7\u00f5es com vetores e matrizes.</li> <li>Suas rotinas s\u00e3o organizadas em tr\u00eas n\u00edveis:</li> <li>N\u00edvel 1: Opera\u00e7\u00f5es vetor x vetor.</li> <li>N\u00edvel 2: Opera\u00e7\u00f5es matriz x vetor.</li> <li>N\u00edvel 3: Opera\u00e7\u00f5es matriz x matriz.</li> <li>A primeira letra dos nomes dos subprogramas indica a precis\u00e3o:</li> <li>S: Real precis\u00e3o \u00fanica.</li> <li>D: Real precis\u00e3o dupla.</li> <li>C: Complexo precis\u00e3o \u00fanica.</li> <li>Z: Complexo precis\u00e3o dupla.</li> </ul>"},{"location":"Fortran/Fortran_77/#lapack","title":"LAPACK","text":"<ul> <li>Constru\u00eddo sobre BLAS, \u00e9 uma cole\u00e7\u00e3o para problemas avan\u00e7ados de \u00e1lgebra linear.</li> <li>Documenta\u00e7\u00e3o dispon\u00edvel em:</li> <li>LAPACK Home</li> <li>LAPACK User's Guide</li> <li>Ao instalar, coloque os arquivos <code>.lib</code> (no Windows) ou <code>.a</code> (no Linux) em um diret\u00f3rio apropriado. Certifique-se de ajustar os caminhos de compila\u00e7\u00e3o conforme necess\u00e1rio. O BLAS deve ser especificado por \u00faltimo no comando de compila\u00e7\u00e3o.</li> </ul> <p>Exemplo para resolver um sistema linear simples:</p> <pre><code>      c234567\n      PROGRAM SolveLinearSystem\n      IMPLICIT NONE\n\n      INTEGER :: n, nrhs, lda, ldb, info\n      PARAMETER (n = 3, nrhs = 1, lda = n, ldb = n)\n\n      REAL :: A(lda, n), B(ldb, nrhs)\n      INTEGER :: ipiv(n)\n\n      EXTERNAL SGESV\n\n      DATA A / 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 10.0 /\n      DATA B / 6.0, 15.0, 25.0 /\n\n      PRINT *, 'Starting the linear system solver...'\n\n      CALL SGESV(n, nrhs, A, lda, ipiv, B, ldb, info)\n\n      PRINT *, 'SGESV call completed.'\n\n      IF (info .EQ. 0) THEN\n          PRINT *, 'The solution is:'\n          PRINT *, B\n      ELSE\n          PRINT *, 'An error occurred: info =', info\n      END IF\n\n      PRINT *, 'Program finished.'\n\n      STOP      \n      END\n</code></pre> <p>Para compilar:</p> <pre><code>$ gfortran -o solve_system solve_system.f -LC:/msys64/mingw64/lib -llapack -lblas\n</code></pre> <p>Observa\u00e7\u00e3o: O diret\u00f3rio especificado ap\u00f3s <code>-LC:</code> deve conter as bibliotecas necess\u00e1rias. Lembre-se que o LAPACK depende do BLAS, o qual deve ser listado por \u00faltimo no comando.</p> <p>A maior complica\u00e7\u00e3o pode estar na depura\u00e7\u00e3o de erros relacionados a vers\u00f5es de DLLs e compatibilidade com a arquitetura da CPU. Em edi\u00e7\u00f5es futuras, abordaremos a constru\u00e7\u00e3o de pacotes e a compila\u00e7\u00e3o de vers\u00f5es espec\u00edficas da BLAS ou LAPACK para sua m\u00e1quina.</p>"},{"location":"Fortran/Fortran_90/","title":"Cap\u00edtulo 1 - Introdu\u00e7\u00e3o","text":"<p>Neste cap\u00edtulo, visamos apresentar a linguagem Fortran (na vers\u00e3o Fortran 90) do zero, assumindo pouca familiaridade com programa\u00e7\u00e3o, mas algum conhecimento de m\u00e9todos num\u00e9ricos \u2013 que, embora n\u00e3o obrigat\u00f3rios, facilitar\u00e3o a compreens\u00e3o de algumas motiva\u00e7\u00f5es e m\u00e9todos. Ao longo deste cap\u00edtulo, ser\u00e3o apresentados os conceitos b\u00e1sicos necess\u00e1rios para construir, por exemplo, uma implementa\u00e7\u00e3o funcional do M\u00e9todo da Bisse\u00e7\u00e3o.</p>"},{"location":"Fortran/Fortran_90/#caracteristicas-da-linguagem","title":"Caracter\u00edsticas da Linguagem","text":"<ul> <li>Diferen\u00e7as para o Fortran 77: Fixed-form vs. free-form </li> <li>Vantagens e desvantagens para determinadas aplica\u00e7\u00f5es.</li> </ul>"},{"location":"Fortran/Fortran_90/#compilacao-e-suas-etapas","title":"Compila\u00e7\u00e3o e suas Etapas","text":"<p>Antes de come\u00e7armos a programar, \u00e9 importante entender alguns termos:</p> <ul> <li> <p>C\u00f3digo-fonte:   Arquivo escrito em Fortran (extens\u00e3o <code>.f90</code>) contendo as instru\u00e7\u00f5es do programa. Exemplo visual: imagem de c\u00f3digo fonte (n\u00e3o inclu\u00edda aqui).</p> </li> <li> <p>Compilador:   Programa (por exemplo, <code>gfortran</code>) que traduz o c\u00f3digo-fonte em instru\u00e7\u00f5es que o computador pode executar.</p> </li> <li> <p>Arquivo Execut\u00e1vel:   Arquivo resultante da compila\u00e7\u00e3o, que \u00e9 executado pelo sistema operacional. Exemplo visual: imagem de um execut\u00e1vel aberto em um editor de texto.</p> </li> </ul>"},{"location":"Fortran/Fortran_90/#instalacao-e-uso-do-compilador","title":"Instala\u00e7\u00e3o e Uso do Compilador","text":"<ul> <li> <p>Como instalar o compilador (<code>gfortran</code>):   Siga as instru\u00e7\u00f5es espec\u00edficas para seu sistema operacional.</p> </li> <li> <p>Compilando um C\u00f3digo-Fonte: <code>bash   gfortran -o programa exemplo.f90</code></p> </li> <li> <p>Executando o Programa Compilado: <code>bash   ./programa</code></p> </li> </ul>"},{"location":"Fortran/Fortran_90/#estrutura-basica-de-um-programa","title":"Estrutura B\u00e1sica de um Programa","text":"<p>Todo programa em Fortran deve ter um bloco <code>program</code> com o nome do programa. Veja o exemplo cl\u00e1ssico \"Ol\u00e1 mundo!\":</p> <pre><code>program exemplo\n    print *, 'Ol\u00e1 mundo!'\nend program exemplo\n</code></pre> <p>O comando <code>print</code> usa um argumento de formata\u00e7\u00e3o (aqui <code>*</code>, que significa formata\u00e7\u00e3o padr\u00e3o) seguido dos dados a serem impressos.</p>"},{"location":"Fortran/Fortran_90/#variaveis","title":"Vari\u00e1veis","text":"<p>Fortran \u00e9 fortemente tipado, ou seja, todas as vari\u00e1veis devem ser declaradas com seu tipo. Os tipos b\u00e1sicos s\u00e3o:</p> <ul> <li><code>integer</code> \u2013 n\u00fameros inteiros (positivos ou negativos)</li> <li><code>real</code> \u2013 n\u00fameros em ponto flutuante</li> <li><code>complex</code> \u2013 n\u00fameros complexos (parte real e imagin\u00e1ria)</li> <li><code>character</code> \u2013 cadeias de caracteres</li> <li><code>logical</code> \u2013 valores booleanos (.true. ou .false.)</li> </ul>"},{"location":"Fortran/Fortran_90/#exemplo-de-declaracao","title":"Exemplo de Declara\u00e7\u00e3o:","text":"<pre><code>program variaveis\n    implicit none\n\n    integer :: i\n    real :: distancia\n    complex :: frequencia\n    character :: inicial\n    logical :: eh_primo\n\n    i = 1\n    distancia = 1.41421356\n    frequencia = (1.0, -0.5)\n    inicial = \"f\"\n    eh_primo = .false.\nend program variaveis\n</code></pre> <p>Nota: Use <code>implicit none</code> para evitar tipagem impl\u00edcita (por exemplo, vari\u00e1veis iniciadas com I, J, K... s\u00e3o automaticamente inteiros em vers\u00f5es antigas).</p>"},{"location":"Fortran/Fortran_90/#precisao-de-variaveis","title":"Precis\u00e3o de Vari\u00e1veis","text":"<ul> <li>Float32 (real padr\u00e3o): Aproximadamente 6\u20139 d\u00edgitos de precis\u00e3o.  </li> <li>Float64: Para maior precis\u00e3o, use o m\u00f3dulo <code>iso_fortran_env</code>:   ```fortran   use, intrinsic :: iso_fortran_env   implicit none</li> </ul> <p>real(real64) :: valor   <code>``   Literais de 64 bits podem ser escritos com um sufixo, por exemplo,</code>1.0_real64`.</p>"},{"location":"Fortran/Fortran_90/#operacoes-basicas","title":"Opera\u00e7\u00f5es B\u00e1sicas","text":"<p>Fortran possui os seguintes operadores aritm\u00e9ticos (em ordem de preced\u00eancia):</p> Operador Opera\u00e7\u00e3o ** Exponencia\u00e7\u00e3o * Multiplica\u00e7\u00e3o / Divis\u00e3o + Adi\u00e7\u00e3o - Subtra\u00e7\u00e3o <p>Exemplo: </p> <pre><code>program media\n    print *, (3 + 4 + 5) / 2\nend program media\n</code></pre> <p>Dica: Lembre-se de usar par\u00eanteses para alterar a ordem natural de preced\u00eancia. Observa\u00e7\u00e3o: Opera\u00e7\u00f5es entre inteiros geram inteiros; para obter fra\u00e7\u00f5es, use n\u00fameros reais.</p>"},{"location":"Fortran/Fortran_90/#comentarios","title":"Coment\u00e1rios","text":"<p>Coment\u00e1rios iniciam com <code>!</code> e s\u00e3o \u00fateis para documentar o c\u00f3digo.</p> <pre><code>program comentarios\n    implicit none\n    ! Esta linha \u00e9 um coment\u00e1rio\n    real :: alpha  ! Coeficiente do termo linear\n    print *, alpha\nend program comentarios\n</code></pre>"},{"location":"Fortran/Fortran_90/#funcoes-e-modulos","title":"Fun\u00e7\u00f5es e M\u00f3dulos","text":"<p>Fun\u00e7\u00f5es e m\u00f3dulos promovem a modularidade e a reutiliza\u00e7\u00e3o de c\u00f3digo.</p>"},{"location":"Fortran/Fortran_90/#funcoes","title":"Fun\u00e7\u00f5es","text":"<p>Fun\u00e7\u00f5es retornam um valor \u00fanico. A sintaxe b\u00e1sica \u00e9:</p> <pre><code>function nome_funcao(arg1, arg2) result(var_result)\n    implicit none\n    tipo1, intent(in) :: arg1\n    tipo2, intent(in) :: arg2\n    tipo3 :: var_result\n\n    ! Corpo da fun\u00e7\u00e3o\n    return\nend function nome_funcao\n</code></pre> <p>Exemplo \u2013 Calculando a norma do dobro de um vetor em R\u00b2 (cuidado com efeitos colaterais):</p> <pre><code>function norma_dobro(v1, v2) result(norma)\n    real, intent(in) :: v1, v2\n    real :: norma\n\n    norma = sqrt((2*v1)**2 + (2*v2)**2)\n    return\nend function norma_dobro\n</code></pre> <p>Se for necess\u00e1rio evitar modificar os argumentos, use vari\u00e1veis auxiliares.</p>"},{"location":"Fortran/Fortran_90/#funcoes-intrinsecas","title":"Fun\u00e7\u00f5es Intr\u00ednsecas","text":"<p>Fortran possui diversas fun\u00e7\u00f5es intr\u00ednsecas que s\u00e3o otimizadas, como: - <code>ABS</code> - <code>MAX</code> - <code>LOG</code> - <code>SQRT</code> - <code>ATAN</code> - <code>CONJG</code></p> <p>Utilize-as sempre que poss\u00edvel.</p>"},{"location":"Fortran/Fortran_90/#modulos","title":"M\u00f3dulos","text":"<p>M\u00f3dulos permitem agrupar fun\u00e7\u00f5es e vari\u00e1veis:</p> <pre><code>module normas\n    implicit none\ncontains\n    function norma_do_dobro(v1, v2) result(norma)\n        real, intent(in) :: v1, v2\n        real :: coord1, coord2, norma\n        coord1 = 2*v1\n        coord2 = 2*v2\n        norma = sqrt(coord1**2 + coord2**2)\n        return\n    end function norma_do_dobro\nend module normas\n</code></pre> <p>Para utilizar o m\u00f3dulo:</p> <pre><code>program calcula_norma\n    use normas\n    implicit none\n    real :: norma_calculada, vec1, vec2\n\n    vec1 = 1.0\n    vec2 = 1.0\n\n    print *, vec1, vec2\n    norma_calculada = norma_do_dobro(vec1, vec2)\n    print *, norma_calculada\n    print *, vec1, vec2\nend program calcula_norma\n</code></pre>"},{"location":"Fortran/Fortran_90/#estruturas-condicionais","title":"Estruturas Condicionais","text":"<p>Para executar trechos de c\u00f3digo dependendo de condi\u00e7\u00f5es:</p> <pre><code>if (expressao_logica) then\n    ! C\u00f3digo se verdadeiro\nelse\n    ! C\u00f3digo se falso\nend if\n</code></pre> <p>Exemplo \u2013 Fun\u00e7\u00e3o Valor Absoluto:</p> <pre><code>function absoluto(x) result(y)\n    real, intent(in) :: x\n    real :: y\n    y = x\n    if (x &lt; 0) then\n        y = -y\n    end if\n    return\nend function absoluto\n</code></pre> <p>Exemplo \u2013 Fun\u00e7\u00e3o Heaviside:</p> <pre><code>function heaviside(x) result(y)\n    real, intent(in) :: x\n    real :: y\n    if (x &gt;= 0) then\n        y = 1\n    else\n        y = 0\n    end if\n    return\nend function heaviside\n</code></pre> <p>Dica: Para evitar muitos IF's aninhados, utilize a t\u00e9cnica de invers\u00e3o l\u00f3gica (testar condi\u00e7\u00f5es opostas com <code>return</code>) ou extraia o teste em uma fun\u00e7\u00e3o separada.</p>"},{"location":"Fortran/Fortran_90/#repeticao-do","title":"Repeti\u00e7\u00e3o - <code>DO</code>","text":"<p>A repeti\u00e7\u00e3o \u00e9 feita com o comando <code>do</code>:</p> <pre><code>do iterador = valor_inicial, valor_final, passo\n    ! C\u00f3digo a repetir\nend do\n</code></pre> <p>Exemplo \u2013 Somat\u00f3rio de 1/(k\u00b2) de k = 1 at\u00e9 n:</p> <pre><code>program somatorio\n    implicit none\n    real :: valor\n    integer :: k, n\n    valor = 0.0\n    n = 100\n    do k = 1, n\n        valor = valor + 1.0/(k*k)\n    end do\n    print *, valor\nend program somatorio\n</code></pre> <p>Observa\u00e7\u00f5es: - O passo padr\u00e3o \u00e9 1 (pode ser omitido). - Para passos fracion\u00e1rios, itere com inteiros e ajuste (por exemplo, <code>k/10.0</code>). - \u00c9 poss\u00edvel iterar com passos negativos.</p>"},{"location":"Fortran/Fortran_90/#subrotinas","title":"Subrotinas","text":"<p>Subrotinas s\u00e3o usadas quando se deseja modificar os argumentos e/ou retornar m\u00faltiplos valores. A sintaxe \u00e9:</p> <pre><code>subroutine nome_subrotina(arg1, arg2, arg3)\n    implicit none\n    tipo1, intent(in) :: arg1\n    tipo2, intent(inout) :: arg2\n    tipo3, intent(out) :: arg3\n\n    ! Corpo da subrotina\n    return\nend subroutine nome_subrotina\n</code></pre> <p>Exemplo:</p> <pre><code>program chama_subrotina\n    implicit none\n    integer :: N, QUADRADO, CUBO\n    print *, 'Digite um n\u00famero:'\n    read *, N\n    call calcula_quadrado_e_cubo(N, QUADRADO, CUBO)\n    print *, 'O quadrado de', N, '\u00e9', QUADRADO\n    print *, 'O cubo de', N, '\u00e9', CUBO\nend program chama_subrotina\n\nsubroutine calcula_quadrado_e_cubo(X, QUAD, CUB)\n    implicit none\n    integer, intent(in) :: X\n    integer, intent(out) :: QUAD, CUB\n    QUAD = X * X\n    CUB = X * X * X\n    return\nend subroutine calcula_quadrado_e_cubo\n</code></pre>"},{"location":"Fortran/Fortran_90/#construindo-o-metodo-da-bissecao","title":"Construindo o M\u00e9todo da Bisse\u00e7\u00e3o","text":"<p>O m\u00e9todo da bisse\u00e7\u00e3o segue os seguintes passos: 1. Definir a fun\u00e7\u00e3o cuja raiz se deseja encontrar e o intervalo inicial. 2. Calcular o ponto m\u00e9dio do intervalo. 3. Verificar se a fun\u00e7\u00e3o no ponto m\u00e9dio \u00e9 zero. 4. Se sim, retornar o ponto; caso contr\u00e1rio, determinar o novo intervalo baseado no sinal da fun\u00e7\u00e3o. 5. Repetir at\u00e9 que um crit\u00e9rio de parada seja atingido (por exemplo, n\u00famero m\u00e1ximo de itera\u00e7\u00f5es).</p> <p>Voc\u00ea dever\u00e1 estruturar uma fun\u00e7\u00e3o que implemente esses passos conforme o exerc\u00edcio proposto.</p>"},{"location":"Fortran/Fortran_90/#formatacao-de-saidas","title":"Formata\u00e7\u00e3o de Sa\u00eddas","text":"<p>O comando <code>write</code> permite formatar a sa\u00edda. Sua sintaxe \u00e9:</p> <pre><code>write (*, label) lista_de_variaveis\nlabel format-code\n</code></pre>"},{"location":"Fortran/Fortran_90/#exemplos-de-codigos-de-formatacao","title":"Exemplos de C\u00f3digos de Formata\u00e7\u00e3o","text":"<ul> <li>A: string</li> <li>D: n\u00fameros double precision (nota\u00e7\u00e3o exponencial)</li> <li>E: n\u00fameros reais (nota\u00e7\u00e3o exponencial)</li> <li>F: n\u00fameros reais (formato fixo)</li> <li>I: inteiro</li> <li>X: espa\u00e7o horizontal</li> <li>/: salto de linha</li> </ul> <p>Exemplo:</p> <pre><code>program formatacao\n    data m/10/, n/20/, x/2.5/, y/2.5/\n    real :: m, n, x, y\n    write (*,100) m\n100 format (I2)\n    write (*,'(I2)') n  \n    write (*,300) x\n300 format (F4.1)\n    write (*,400) y\n400 format (E8.2)\n    stop\nend program formatacao\n</code></pre>"},{"location":"Fortran/Fortran_90/#repeticao-goto","title":"Repeti\u00e7\u00e3o - <code>GOTO</code>","text":"<p>Embora Fortran 90 possua estruturas modernas, em Fortran 77 \u00e9 comum usar <code>do</code> junto com <code>goto</code> para simular loops while.</p> <p>Exemplo de loop com GOTO:</p> <pre><code>program exemplo_while\n    implicit none\n    integer :: a(10), I\n    data a /1, 2, 3, 4, 5, 6, 7, 8, 9, 10/\n    I = 1\n10  if (a(I) /= 5) then\n       print *, 'Elemento', I, ':', a(I)\n       I = I + 1\n       goto 10\n    end if\nend program exemplo_while\n</code></pre>"},{"location":"Fortran/Fortran_90/#imports-e-linkagem","title":"Imports e Linkagem","text":"<p>Este t\u00f3pico aborda como importar m\u00f3dulos e ligar bibliotecas externas para compilar programas mais complexos.</p>"},{"location":"Fortran/Fortran_90/#capitulo-2-matrizes-vetores-e-operacoes-vetoriais","title":"Cap\u00edtulo 2 - Matrizes, Vetores e Opera\u00e7\u00f5es Vetoriais","text":"<p>Conte\u00fado deste cap\u00edtulo a ser desenvolvido \u2013 abordar\u00e1 a declara\u00e7\u00e3o e manipula\u00e7\u00e3o de vetores, matrizes e opera\u00e7\u00f5es vetoriais, com exemplos e t\u00e9cnicas espec\u00edficas para Fortran.</p>"},{"location":"Julia/capitulo_1/","title":"1. Introdu\u00e7\u00e3o","text":"<p>Este cap\u00edtulo foca em introduzir conceitos fundamentais relacionados \u00e0 linguagem de programa\u00e7\u00e3o Julia, abordando sua sintaxe, compilador JIT (Just-In-Time) e aspectos gerais de programa\u00e7\u00e3o com Julia.</p>"},{"location":"Julia/capitulo_1/#11-caracteristicas-da-linguagem-julia","title":"1.1. Caracter\u00edsticas da Linguagem Julia","text":"<p>Julia \u00e9 uma linguagem de programa\u00e7\u00e3o de alto desempenho para computa\u00e7\u00e3o t\u00e9cnica. Ela combina a facilidade de uma linguagem de script com a pot\u00eancia de linguagens compiladas, oferecendo um sistema de tipos din\u00e2mico, efici\u00eancia de desempenho e uma sintaxe elegante. Essa combina\u00e7\u00e3o de recursos facilita a express\u00e3o de muitos algoritmos num\u00e9ricos e a manipula\u00e7\u00e3o de dados, tornando Julia uma escolha excelente para ci\u00eancia de dados, an\u00e1lise num\u00e9rica, e mais. Abaixo, algumas caracter\u00edsticas chave de Julia:</p> <ul> <li>Desempenho de Alto N\u00edvel: Gra\u00e7as \u00e0 sua compila\u00e7\u00e3o JIT, Julia oferece desempenho que pode rivalizar com o de linguagens tradicionalmente compiladas como C e Fortran;</li> <li>Facilidade de Uso: A sintaxe de Julia \u00e9 clara e concisa, tornando a programa\u00e7\u00e3o em Julia acess\u00edvel para programadores de todos os n\u00edveis;</li> <li>Computa\u00e7\u00e3o Paralela e Distribu\u00edda: Julia foi desenhada com a paraleliza\u00e7\u00e3o e computa\u00e7\u00e3o distribu\u00edda em mente, permitindo a execu\u00e7\u00e3o eficiente de c\u00f3digo em clusters e na nuvem;</li> <li>Ecosistema Rico: A comunidade Julia desenvolveu um vasto ecossistema de pacotes, cobrindo diversas \u00e1reas como aprendizado de m\u00e1quina, visualiza\u00e7\u00e3o de dados, manipula\u00e7\u00e3o de dados, entre outros;</li> <li>Interoperabilidade: Julia permite a chamada de fun\u00e7\u00f5es de outras linguagens, como Python, C, e Fortran, facilitando a integra\u00e7\u00e3o com bibliotecas e sistemas existentes;</li> </ul> <p>Abaixo, voc\u00ea encontrar\u00e1 uma tabela com alguns tipos de dados b\u00e1sicos em Julia, destacando as palavras-chave utilizadas para a defini\u00e7\u00e3o de vari\u00e1veis e os formatos para a sua manipula\u00e7\u00e3o:</p> <p>Tabela de dados b\u00e1sicos em Julia</p> PALAVRA-CHAVE TIPO DESCRI\u00c7\u00c3O EXEMPLO DE USO Int Inteiro Tipo padr\u00e3o de inteiro, variando conforme a arquitetura (32 ou 64 bits) 5, -3 Float64 Ponto flutuante N\u00famero real em precis\u00e3o dupla 3.14, -2.71 Bool Booleano Verdadeiro ou falso true, false String Cadeia de caracteres Texto \"Ol\u00e1, mundo!\" Char Caractere Um \u00fanico caractere unicode 'a', '3' <p>\u00c9 importante destacar que Julia \u00e9 projetada para ser f\u00e1cil e intuitiva para usu\u00e1rios de outras linguagens de programa\u00e7\u00e3o, sem sacrificar o desempenho. Ao longo deste texto, exploraremos mais sobre como Julia atinge esse equil\u00edbrio e como voc\u00ea pode come\u00e7ar a aproveitar suas capacidades em seus pr\u00f3prios projetos de programa\u00e7\u00e3o.</p>"},{"location":"Julia/capitulo_1/#12-o-sistema-de-tipos-em-julia","title":"1.2. O Sistema de Tipos em Julia","text":"<p>O sistema de tipos em Julia \u00e9 sofisticado e permite defini\u00e7\u00f5es de tipos abstratos e concretos, heran\u00e7a de tipos e muito mais. A linguagem \u00e9 dinamicamente tipada, mas seu sistema de tipos \u00e9 projetado para promover pr\u00e1ticas que maximizam o desempenho do c\u00f3digo.</p> <p>A seguir, detalhamos o processo de compila\u00e7\u00e3o JIT em Julia, que \u00e9 fundamental para o seu desempenho.</p>"},{"location":"Julia/capitulo_1/#13-compilacao-just-in-time-jit-em-julia","title":"1.3. Compila\u00e7\u00e3o Just-In-Time (JIT) em Julia","text":"<p>A compila\u00e7\u00e3o Just-In-Time (JIT) \u00e9 uma das caracter\u00edsticas que distinguem Julia de outras linguagens de programa\u00e7\u00e3o. Em vez de compilar o c\u00f3digo para uma linguagem de m\u00e1quina de antem\u00e3o (Ahead-of-Time), Julia compila o c\u00f3digo no momento da execu\u00e7\u00e3o. Isso permite uma otimiza\u00e7\u00e3o espec\u00edfica para o hardware do usu\u00e1rio e melhora significativamente a velocidade de execu\u00e7\u00e3o de programas Julia, especialmente em c\u00e1lculos num\u00e9ricos e cient\u00edficos.</p> <p>Essa abordagem traz o melhor de dois mundos: a flexibilidade de uma linguagem interpretada, com a efici\u00eancia de uma linguagem compilada, tornando Julia uma excelente escolha para uma ampla gama de aplica\u00e7\u00f5es cient\u00edficas e t\u00e9cnicas.</p>"},{"location":"Linguagem_C/capitulo_1/","title":"1. Introdu\u00e7\u00e3o","text":"<p>Esse cap\u00edtulo visa estabelecer conceitos importantes que envolvem a linguagem C, compiladores e programa\u00e7\u00e3o no geral.</p>"},{"location":"Linguagem_C/capitulo_1/#11-caracteristicas-da-linguagem-c","title":"1.1. Caracter\u00edsticas da Linguagem C","text":"<p>C \u00e9 uma linguagem de programa\u00e7\u00e3o compilada, isto \u00e9, ao escrevermos o c\u00f3digo fonte na pr\u00f3pria linguagem, no caso em C, um programa chamado compilador reescreve esse c\u00f3digo para a linguagem de m\u00e1quina. Sendo assim, o compilador tem como entrada um arquivo com c\u00f3digo fonte da linguagem e que gera como sa\u00edda um arquivo objeto, com c\u00f3digo objeto, que \u00e9 ligado a outros arquivos objeto para gerar um arquivo execut\u00e1vel. O arquivo execut\u00e1vel \u00e9 um arquivo que pode ser executado no computador alvo. Na pr\u00f3xima se\u00e7\u00e3o, ser\u00e3o dados mais detalhes sobre o processo de compila\u00e7\u00e3o de um arquivo em C. Abaixo seguem algumas caracter\u00edsticas importantes da linguagem C:</p> <ul> <li>Estruturada: A programa\u00e7\u00e3o estruturada (sucedida pela programa\u00e7\u00e3o orientada a objeto) \u00e9 um paradigma formado por tr\u00eas componentes:</li> <li>Sequ\u00eancia: Uma tarefa \u00e9 executada logo ap\u00f3s a outra;</li> <li>Decis\u00e3o: A tarefa \u00e9 executada logo ap\u00f3s um teste l\u00f3gico;</li> <li>Itera\u00e7\u00e3o: A partir de um teste l\u00f3gico, um trecho de c\u00f3digo pode ser repetido finitas vezes.</li> <li>Imperativa: Descreve a\u00e7\u00f5es/instru\u00e7\u00f5es que o programa dever\u00e1 executar. Ou seja, linguagens imperativas s\u00e3o programadas com uma sequ\u00eancia de comandos ordenada pelo programador;</li> <li>Procedural: Permite a constru\u00e7\u00e3o de procedimentos que podem ser compartimentados e reutilizados, tornando partes do c\u00f3digo mais independentes entre si;</li> <li>Padronizada: Garante que um mesmo c\u00f3digo gere sempre o mesmo resultado, seja ele compilado e executado ou interpretado;</li> <li>Fortemente Tipada: Em C, os tipos das vari\u00e1veis e fun\u00e7\u00f5es precisam ser bem definidos durante toda a execu\u00e7\u00e3o do programa. Com ponteiros do tipo <code>void</code>, \u00e9 poss\u00edvel contornar essa restri\u00e7\u00e3o, mas isso n\u00e3o \u00e9 aconselh\u00e1vel.</li> </ul> <p>Abaixo segue uma tabela com os tipos de dados b\u00e1sicos da linguagem, onde a palavra-chave \u00e9 usada para definir as vari\u00e1veis e o formato indica a forma de capturar (por meio de fun\u00e7\u00f5es como <code>scanf</code>) ou de imprimir (por exemplo, com <code>printf</code>):</p> <p>Tabela de dados b\u00e1sicos de C</p> PALAVRA-CHAVE TIPO BYTES INTERVALO FORMATO <code>char / signed char</code> Caracter 1 -128 a 127 <code>%c</code> <code>unsigned char</code> Caracter sem sinal 1 0 a 255 <code>%c</code> <code>short / short int / signed short / signed short int</code> Inteiro curto com sinal 2 -32768 a 32767 <code>%hi ou %hd</code> <code>unsigned short / unsigned short int</code> Inteiro curto sem sinal 2 0 a 65535 <code>%hu</code> <code>signed int / signed</code> Inteiro com sinal 2 -32768 a 32767 <code>%i ou %d</code> <code>unsigned / unsigned int</code> Inteiro sem sinal 2 0 a 65535 <code>%u</code> <code>long / long int / signed long / signed long int</code> Inteiro com sinal 4 -2147483648 a 2147483647 <code>%li ou %ld</code> <code>unsigned long / unsigned long int</code> Inteiro sem sinal 4 0 a 4294967295 <code>%lu</code> <code>long long / signed long long / long long int / signed long long int</code> Inteiro muito lingo com sinal 8 \u22122^+63 a 2^+63 \u22121 <code>%lli ou %lld</code> <code>unsigned long long / unsigned long long int</code> Inteiro muito lingo sem sinal 8 0 a 2^+64 \u22121 <code>%llu</code> <code>float</code> Ponto flutuante simples 4 3.4 X 10^-38 a 3.4 X 10^+38 <code>%f ou %F</code> <code>double</code> Ponto flutuante em precisao dupla 8 1.7 X 10^-308 a 1.7 X 10^+308 <code>%lf ou %lF</code> <code>long double</code> Ponto flutuante em precis\u00e3o estendida 16 3.4 X 10^-4932 a 3.4 X 10^+4932 <code>%Lf ou %LF</code> <p>Vale notar que esses tipos podem variar de m\u00e1quina para m\u00e1quina, sendo interessante imprimir os limites dos tipos presentes no cabe\u00e7alho limits.h. As padroniza\u00e7\u00f5es (como ANSI e ISO) da linguagem tamb\u00e9m podem afetar certos tipos e, consequentemente, o funcionamento do c\u00f3digo. Como C \u00e9 muito popular, diversos compiladores foram constru\u00eddos com caracter\u00edsticas distintas. As pr\u00f3ximas se\u00e7\u00f5es introduzir\u00e3o o processo de compila\u00e7\u00e3o.</p>"},{"location":"Linguagem_C/capitulo_1/#12-o-que-e-um-compilador","title":"1.2. O Que \u00c9 Um Compilador?","text":"<p>O compilador \u00e9 um programa de computador respons\u00e1vel por reescrever o c\u00f3digo fonte em c\u00f3digo de m\u00e1quina que poder\u00e1 ser executado. Assim, ele recebe como entrada um arquivo com o c\u00f3digo fonte e gera um arquivo execut\u00e1vel.</p> <p>Em outras palavras, o compilador traduz o c\u00f3digo fonte de uma linguagem compreens\u00edvel para os seres humanos para outra que o computador possa entender. Atualmente, o compilador possui muitas funcionalidades al\u00e9m da simples tradu\u00e7\u00e3o: ele pode agrupar instru\u00e7\u00f5es de m\u00e1quina em uma \u00fanica linha de c\u00f3digo, otimizar o c\u00f3digo, gerar arquivos intermedi\u00e1rios, tratar erros na programa\u00e7\u00e3o e oferecer ferramentas de depura\u00e7\u00e3o. Os primeiros compiladores eram focados na tradu\u00e7\u00e3o do c\u00f3digo fonte e na jun\u00e7\u00e3o das bibliotecas necess\u00e1rias para a execu\u00e7\u00e3o do c\u00f3digo objeto, num processo chamado de liga\u00e7\u00e3o. Esses compiladores iniciais foram escritos em Assembly e, com o tempo, surgiram diversas ferramentas para a constru\u00e7\u00e3o de compiladores, facilitando a cria\u00e7\u00e3o de novas linguagens.</p> <p>Com a evolu\u00e7\u00e3o das linguagens e a necessidade de novas funcionalidades, os compiladores passaram a ter caracter\u00edsticas variadas e m\u00e9todos de funcionamento diferentes. A seguir, os principais tipos de compiladores:</p> <ul> <li>Compilador Ahead-of-time: Compila o c\u00f3digo fonte antes da execu\u00e7\u00e3o do programa, gerando um arquivo objeto com instru\u00e7\u00f5es de m\u00e1quina nativas.</li> <li>Compilador Just-in-time: Compila o c\u00f3digo durante a execu\u00e7\u00e3o do programa. Na primeira execu\u00e7\u00e3o, cada linha do c\u00f3digo fonte \u00e9 traduzida para instru\u00e7\u00f5es de m\u00e1quina (ou para uma linguagem intermedi\u00e1ria) e executada imediatamente; em execu\u00e7\u00f5es subsequentes, o c\u00f3digo j\u00e1 compilado permite uma execu\u00e7\u00e3o mais r\u00e1pida.</li> <li>Compilador Cruzado: Gera um arquivo execut\u00e1vel a partir do c\u00f3digo fonte que pode ser executado em outras m\u00e1quinas, \u00fatil para sistemas embutidos ou ambientes com m\u00faltiplas arquiteturas.</li> <li>Compilador Source-to-source: Tem como sa\u00edda um c\u00f3digo fonte de alto n\u00edvel, em vez de instru\u00e7\u00f5es de m\u00e1quina. Isso possibilita a cria\u00e7\u00e3o de extens\u00f5es sint\u00e1ticas que s\u00e3o reescritas para o c\u00f3digo alvo. Um exemplo \u00e9 o TypeScript.</li> </ul> <p>Existe tamb\u00e9m o interpretador, que traduz e executa o c\u00f3digo fonte ou bytecode diretamente, sem gerar um arquivo objeto. Esse processo \u00e9 geralmente mais lento, pois cada linha precisa ser interpretada em tempo real. Por fim, programas que convertem c\u00f3digo Assembly para linguagem de m\u00e1quina e vice-versa s\u00e3o chamados de montador (assembler) e desmontador (disassembler), respectivamente. A descompila\u00e7\u00e3o, que converte c\u00f3digo de m\u00e1quina para um c\u00f3digo de alto n\u00edvel, tamb\u00e9m \u00e9 utilizada, especialmente em contextos de seguran\u00e7a.</p>"},{"location":"Linguagem_C/capitulo_1/#13-gnu-compiler-collection","title":"1.3. GNU Compiler Collection","text":"<p>O GNU Compiler Collection (GCC) \u00e9 uma cole\u00e7\u00e3o de compiladores Ahead-of-time do projeto GNU, criada em 1987. Ele oferece compiladores para linguagens como ADA, C++, Fortran, Java, Objective-C e Pascal, e possui compatibilidade com arquiteturas como ARM, x86 e AMD64 (x86-64). O GCC \u00e9 o compilador padr\u00e3o na maioria dos sistemas Linux, o principal compilador para o MAC OS e tamb\u00e9m pode ser utilizado no Windows por meio de ferramentas como MSYS2 e MinGW. Grande parte desses compiladores \u00e9 escrita em C, inclusive o pr\u00f3prio compilador C, num processo chamado de bootstrapping. O foco aqui ser\u00e1 o GNU C Compiler (GCC).</p> <ul> <li>Pr\u00e9-processamento: Realizado pelo pr\u00e9-processador, que trata todas as linhas que come\u00e7am com <code>#</code>. As diretivas principais nessa fase s\u00e3o <code>#include</code> (para inclus\u00e3o de arquivos de cabe\u00e7alho com defini\u00e7\u00f5es e declara\u00e7\u00f5es) e <code>#define</code> (para defini\u00e7\u00e3o de macros e constantes). Outras diretivas, como <code>#if...#else...#endif</code> e <code>#error</code>, tamb\u00e9m s\u00e3o utilizadas para controle condicional e exibi\u00e7\u00e3o de mensagens de erro.</li> <li>Compila\u00e7\u00e3o: Nesta fase, o c\u00f3digo \u00e9 traduzido para assembly em v\u00e1rios n\u00edveis:</li> <li>An\u00e1lise l\u00e9xica: Verifica se os s\u00edmbolos (vari\u00e1veis, fun\u00e7\u00f5es e palavras reservadas) est\u00e3o corretos, removendo espa\u00e7os e coment\u00e1rios. Erros como vari\u00e1veis n\u00e3o definidas ou operadores inexistentes s\u00e3o identificados aqui.</li> <li>An\u00e1lise sint\u00e1tica: Garante que as express\u00f5es seguem a gram\u00e1tica formal do C, verificando a organiza\u00e7\u00e3o correta dos s\u00edmbolos.</li> <li>An\u00e1lise sem\u00e2ntica: Valida o sentido l\u00f3gico das express\u00f5es, checando a consist\u00eancia dos tipos, regras de visibilidade e contexto.</li> <li>Otimiza\u00e7\u00e3o de alto n\u00edvel: Otimiza o c\u00f3digo, eliminando redund\u00e2ncias e trechos desnecess\u00e1rios.</li> <li>Montagem: Converte cada linha de assembly em c\u00f3digo de m\u00e1quina.</li> <li>Liga\u00e7\u00e3o: Na fase de liga\u00e7\u00e3o, as bibliotecas e todo o c\u00f3digo necess\u00e1rio para a execu\u00e7\u00e3o do programa s\u00e3o carregados e incorporados ao c\u00f3digo objeto.</li> </ul> <p>Vale ressaltar que muitas otimiza\u00e7\u00f5es ficam desabilitadas por padr\u00e3o e precisam ser ativadas por meio de flags. Ap\u00f3s esta introdu\u00e7\u00e3o aos conceitos b\u00e1sicos da linguagem C e do GCC, os pr\u00f3ximos cap\u00edtulos discutir\u00e3o as formas de utiliza\u00e7\u00e3o deste compilador e as ferramentas que ele oferece.</p>"},{"location":"Linguagem_C/capitulo_2/","title":"2. Compilando Programas em C","text":""},{"location":"Linguagem_C/capitulo_2/#21-primeiros-passos","title":"2.1. Primeiros Passos","text":"<p>Um dos primeiros programas que muitos programadores aprendem a escrever \u00e9 o famoso <code>\"Hello, World!\"</code>. A seguir, mostraremos como compilar esse programa em C utilizando o compilador GCC:</p>"},{"location":"Linguagem_C/capitulo_2/#helloworldc","title":"helloworld.c","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n  printf(\"Hello, World!\");\n  return 0;\n}\n</code></pre> <p>No entanto, o c\u00f3digo-fonte ainda n\u00e3o pode ser entendido pelo computador, sendo necess\u00e1rio compil\u00e1-lo para gerar um arquivo execut\u00e1vel. Para isso, usamos um compilador de C, como o GCC. No caso deste exemplo, o arquivo com o c\u00f3digo fonte se chama helloworld.c e o execut\u00e1vel, hello. A compila\u00e7\u00e3o \u00e9 feita pelo terminal:</p> <pre><code>$ gcc helloworld.c -o hello\n</code></pre> <p>O par\u00e2metro <code>-o</code> indica que queremos criar um execut\u00e1vel com o nome hello. Al\u00e9m disso, \u00e9 recomend\u00e1vel utilizar a flag <code>-Wall</code> para habilitar avisos de poss\u00edveis problemas:</p> <pre><code>$ gcc -Wall helloworld.c -o hello\n</code></pre> <p>Para executar o programa, digite:</p> <pre><code>$ ./hello\n</code></pre> <p>Se tudo ocorrer bem, a mensagem <code>Hello, World!</code> ser\u00e1 exibida no terminal.</p>"},{"location":"Linguagem_C/capitulo_2/#22-trabalhando-com-multiplos-arquivos","title":"2.2. Trabalhando com M\u00faltiplos Arquivos","text":"<p>Em projetos em C, \u00e9 comum dividir o c\u00f3digo em m\u00faltiplos arquivos para melhorar a organiza\u00e7\u00e3o e reduzir o tempo de compila\u00e7\u00e3o. Por exemplo, para criar um programa que calcula o quadrado de um n\u00famero, podemos usar:</p>"},{"location":"Linguagem_C/capitulo_2/#mainc","title":"main.c","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"quadrado.h\"\n\nint main() {\n  int x;\n  printf(\"Digite um n\u00famero: \");\n  scanf(\"%d\", &amp;x);\n  printf(\"O quadrado de %d \u00e9 %d\\n\", x, calc_quadrado(x));\n  return 0;\n}\n</code></pre>"},{"location":"Linguagem_C/capitulo_2/#quadradoc","title":"quadrado.c","text":"<pre><code>int calc_quadrado(int x) {\n  return x * x;\n}\n</code></pre>"},{"location":"Linguagem_C/capitulo_2/#quadradoh","title":"quadrado.h","text":"<pre><code>int calc_quadrado(int x);\n</code></pre> <p>Se inclu\u00edssemos diretamente quadrado.c em main.c, ter\u00edamos duas defini\u00e7\u00f5es da fun\u00e7\u00e3o <code>int calc_quadrado(int x)</code>, o que causaria um erro. Assim, usamos quadrado.h para declarar a fun\u00e7\u00e3o. Para compilar todos os arquivos de uma vez, execute:</p> <pre><code>$ gcc -Wall main.c quadrado.c -o programa\n</code></pre> <p>E para rodar o programa:</p> <pre><code>$ ./programa\n</code></pre> <p>Para evitar recompilar o programa inteiro ap\u00f3s uma altera\u00e7\u00e3o, compile cada arquivo em um objeto:</p> <pre><code>$ gcc -Wall main.c -c\n$ gcc -Wall quadrado.c -c\n</code></pre> <p>Isso gera os arquivos main.o e quadrado.o. Em seguida, ligue-os para criar o execut\u00e1vel:</p> <pre><code>$ gcc main.o quadrado.o -o programa\n</code></pre> <p>Assim, voc\u00ea pode compilar apenas os arquivos modificados e ligar os objetos pr\u00e9-compilados.</p>"},{"location":"Linguagem_C/capitulo_2/#23-utilizando-makefiles","title":"2.3. Utilizando Makefiles","text":"<p>Em projetos grandes com muitos arquivos, \u00e9 comum que apenas alguns precisem ser recompilados ap\u00f3s altera\u00e7\u00f5es. Para gerenciar essas depend\u00eancias, utiliza-se o <code>make</code> com um Makefile. Esse arquivo especifica como os arquivos-fonte s\u00e3o compilados e ligados para criar o programa final.</p> <p>A estrutura b\u00e1sica de um Makefile \u00e9:</p> <pre><code>alvo: dependencia\n  comando\n\ndependencia:\n  comando\n</code></pre> <p>Por exemplo, um Makefile simples para imprimir uma mensagem:</p> <pre><code>saudacao:\n    echo \"Ola, mundo!\"\n</code></pre> <p>Se o arquivo saudacao n\u00e3o existe, o comando \u00e9 executado. Para for\u00e7ar sua execu\u00e7\u00e3o, chame:</p> <pre><code>$ make saudacao\n</code></pre> <p>Um exemplo mais complexo:</p> <pre><code>hello: hello.o\n  gcc hello.o -o hello\n\nhello.o: hello.c\n  gcc -Wall hello.c -c\n</code></pre> <p>O arquivo hello.c tem o seguinte conte\u00fado:</p>"},{"location":"Linguagem_C/capitulo_2/#helloc","title":"hello.c","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n  printf(\"Hello, World!\\n\");\n  return 0;\n}\n</code></pre> <p>Nesse exemplo, o objetivo \u00e9 criar o execut\u00e1vel hello. Ele depende do objeto hello.o, que depende do arquivo fonte hello.c. Ao chamar <code>make</code>, o sistema:</p> <ol> <li>Verifica se hello precisa ser recompilado.</li> <li>Verifica se hello.o precisa ser recompilado.</li> <li>Executa <code>gcc -Wall hello.c -c</code> se necess\u00e1rio.</li> <li>Executa <code>gcc hello.o -o hello</code> para gerar o execut\u00e1vel.</li> </ol> <p>Usar um Makefile garante que somente os arquivos modificados sejam recompilados, otimizando o tempo de compila\u00e7\u00e3o e a gest\u00e3o das depend\u00eancias.</p>"},{"location":"Linguagem_C/capitulo_3/","title":"3. Bandeiras de Aviso do Compilador","text":"<p>O GCC compila programas usando o dialeto GNU da linguagem C como base, que incorpora o padr\u00e3o ANSI C e v\u00e1rias extens\u00f5es do GNU C. Essas extens\u00f5es incluem recursos como declara\u00e7\u00f5es de vari\u00e1veis no meio de um bloco de c\u00f3digo, express\u00f5es com efeitos colaterais e construtores de atributos, entre outros. No entanto, programas v\u00e1lidos escritos em ANSI C podem conflitar com algumas extens\u00f5es do GNU C.</p> <p>Para lidar com esses conflitos, o GCC oferece v\u00e1rias op\u00e7\u00f5es de linha de comando, conhecidas como bandeiras ou flags, que permitem aos desenvolvedores controlar o comportamento do compilador ao compilar o c\u00f3digo fonte. A flag <code>-ansi</code> \u00e9 usada para desabilitar as extens\u00f5es do GNU C que conflitam com o padr\u00e3o ANSI C. A flag <code>-pedantic</code> desabilita todas as extens\u00f5es do GNU C, n\u00e3o apenas aquelas que conflitam com o padr\u00e3o ANSI.</p> <p>No cap\u00edtulo anterior, usamos a flag <code>-Wall</code> na compila\u00e7\u00e3o do nosso programa. Essa flag \u00e9 uma combina\u00e7\u00e3o de v\u00e1rias flags de aviso especializadas que detectam erros comuns de programa\u00e7\u00e3o. Cada uma das flags contidas em <code>-Wall</code> pode ser usada individualmente. Algumas dessas flags s\u00e3o:</p> <ul> <li><code>-Wcomment</code>: Avisa sobre problemas de formata\u00e7\u00e3o em coment\u00e1rios, como coment\u00e1rios dentro de coment\u00e1rios.</li> <li><code>-Wformat</code>: Avisa sobre o uso incorreto de formata\u00e7\u00e3o em strings em fun\u00e7\u00f5es como <code>printf</code> e <code>scanf</code>.</li> <li><code>-Wunused</code>: Avisa sobre vari\u00e1veis que foram declaradas mas n\u00e3o foram usadas no programa.</li> <li><code>-Wimplicit</code>: Avisa sobre fun\u00e7\u00f5es que foram usadas sem serem declaradas, o que pode acontecer se esquecer de incluir o arquivo de cabe\u00e7alho.</li> <li><code>-Wreturn-type</code>: Avisa sobre fun\u00e7\u00f5es que n\u00e3o retornam nenhum valor mas que n\u00e3o foram declaradas como <code>void</code>.</li> </ul> <p>O GCC tamb\u00e9m inclui outras flags de aviso \u00fateis, como:</p> <ul> <li><code>-W</code>: Uma flag geral, semelhante a <code>-Wall</code>, que avisa sobre diversos erros comuns.</li> <li><code>-Wconversion</code>: Avisa sobre convers\u00f5es impl\u00edcitas de tipo, como entre <code>float</code> e <code>int</code>, que podem causar resultados inesperados.</li> <li><code>-Wshadow</code>: Avisa sobre a declara\u00e7\u00e3o de vari\u00e1veis em um escopo em que elas j\u00e1 foram declaradas.</li> <li><code>-Wtraditional</code>: Avisa sobre partes do c\u00f3digo que seriam interpretadas de forma diferente por um compilador ANSI/ISO e um pr\u00e9-ANSI.</li> </ul> <p>Se voc\u00ea quiser que o programa pare de compilar se houver qualquer aviso das flags que voc\u00ea aplicou, use a flag <code>-Werror</code>. Usar flags ao compilar um programa \u00e9 uma boa pr\u00e1tica, mas a grande quantidade pode tornar a escolha de quais usar dif\u00edcil. Com isso em mente, recomendamos que, em geral, as seguintes flags sejam usadas:</p> <pre><code>$ gcc -ansi -pedantic -Wall -W programa.c -o programa\n</code></pre>"},{"location":"Linguagem_C/capitulo_4/","title":"4. Depura\u00e7\u00e3o","text":""},{"location":"Linguagem_C/capitulo_4/#41-compilando-para-depuracao","title":"4.1. Compilando para Depura\u00e7\u00e3o","text":"<p>Durante o desenvolvimento de software, a depura\u00e7\u00e3o ou debugging desempenha um papel fundamental na identifica\u00e7\u00e3o e corre\u00e7\u00e3o eficiente de erros no c\u00f3digo. Ao compilar programas em C, existe uma pr\u00e1tica recomendada para facilitar a depura\u00e7\u00e3o: a utiliza\u00e7\u00e3o da op\u00e7\u00e3o <code>-g</code> ao chamar o GCC. Essa op\u00e7\u00e3o instrui o compilador a incluir informa\u00e7\u00f5es de depura\u00e7\u00e3o no execut\u00e1vel gerado. Essas informa\u00e7\u00f5es, como s\u00edmbolos de fun\u00e7\u00e3o, vari\u00e1veis locais e localiza\u00e7\u00f5es de linha, permitem uma an\u00e1lise detalhada do c\u00f3digo durante a depura\u00e7\u00e3o. Por exemplo, ao executar o programa em um depurador, \u00e9 poss\u00edvel definir pontos de interrup\u00e7\u00e3o, inspecionar valores de vari\u00e1veis e rastrear a execu\u00e7\u00e3o do c\u00f3digo passo a passo.</p> <p>Abaixo est\u00e1 um exemplo de c\u00f3digo que podemos usar para ilustrar como compilar programas em C para depura\u00e7\u00e3o:</p>"},{"location":"Linguagem_C/capitulo_4/#exemploc","title":"exemplo.c","text":"<pre><code>int foo (int *p);\n\nint main (void)\n{\n  int *p = 0;\n  /* ponteiro nulo */\n  return foo (p);\n}\n\nint foo (int *p)\n{\n  int y = *p;\n  return y;\n}\n</code></pre> <p>Nesse c\u00f3digo, temos duas fun\u00e7\u00f5es: <code>int main()</code> e <code>int foo()</code>. A fun\u00e7\u00e3o <code>main</code> inicializa um ponteiro <code>p</code> com o valor nulo (0) e, em seguida, chama a fun\u00e7\u00e3o <code>foo</code> passando esse ponteiro como argumento. A fun\u00e7\u00e3o <code>foo</code> recebe um ponteiro como par\u00e2metro e tenta acessar o valor apontado por ele. No entanto, como <code>p</code> \u00e9 nulo, essa opera\u00e7\u00e3o resulta em um erro. Para compilar esse c\u00f3digo com a op\u00e7\u00e3o de depura\u00e7\u00e3o, voc\u00ea pode usar o seguinte comando:</p> <pre><code>$ gcc -Wall -g exemplo.c -o exemplo\n</code></pre> <p>Ao execut\u00e1-lo, receberemos uma mensagem de erro, indicando que houve uma viola\u00e7\u00e3o de segmenta\u00e7\u00e3o, <code>segmentation fault</code>. Essa mensagem \u00e9 exibida quando ocorre uma tentativa de acessar uma \u00e1rea da mem\u00f3ria que n\u00e3o \u00e9 permitida, como no caso em que o ponteiro <code>p</code> aponta para o valor nulo.</p> <pre><code>$ ./exemplo\nsegmentation fault (core dumped)\n</code></pre> <p>Vamos falar sobre o arquivo core mencionado na mensagem de erro. Ele \u00e9 um arquivo de despejo de mem\u00f3ria que pode ser gerado quando ocorre uma falha grave em um programa e cont\u00e9m informa\u00e7\u00f5es sobre o estado da mem\u00f3ria no momento da falha, sendo \u00fatil para analisar e depurar o problema. Nem todos os sistemas geram automaticamente o core por padr\u00e3o. Se ele n\u00e3o for gerado, essa funcionalidade pode ser habilitada executando o comando abaixo, que define temporariamente o tamanho m\u00e1ximo do arquivo core como ilimitado, permitindo a gera\u00e7\u00e3o do core em caso de falha no programa:</p> <pre><code>$ ulimit -c unlimited\n</code></pre> <p>\u00c9 poss\u00edvel que, ainda assim, o arquivo core n\u00e3o seja gerado. Caso voc\u00ea utilize o Ubuntu ou algum de seus derivados, \u00e9 poss\u00edvel que ao desativar o Apport, o programa que reporta erros no Ubuntu, resolva o problema. Isso pode ser feito com o seguinte comando:</p> <pre><code>$ sudo service apport stop\n</code></pre> <p>\u00c9 importante ressaltar que, se o core n\u00e3o tiver sido gerado durante a primeira execu\u00e7\u00e3o do programa, o core ter\u00e1 que ser gerado novamente.</p>"},{"location":"Linguagem_C/capitulo_4/#42-depurando-programas","title":"4.2. Depurando Programas","text":"<p>Vamos agora usar o gdb para depurar o nosso execut\u00e1vel exemplo. Para isso, escrevemos o seguinte comando:</p> <pre><code>$ gdb exemplo core\n(...)\nCore was generated by './exemplo'.\nProgram terminated with signal SIGSEGV, Segmentation fault.\n\nwarning: Section '.reg-xstate/17012' in core file too small.\n#0  0x00005636c35b715b in foo (p=0x0) at exemplo.c:12\n11    int y = *p;\n(gdb)\n</code></pre> <p>O GDB aponta a linha do c\u00f3digo onde ocorreu a falha do programa. Nesse caso, o erro ocorreu quando o programa tentou desreferenciar o ponteiro <code>p</code>. Para entender melhor o motivo da falha, podemos examinar o valor de <code>p</code> com o comando <code>print</code>:</p> <pre><code>(gdb) print p\n$1 = (int *) 0x0\n</code></pre> <p>Como visto acima, o ponteiro <code>p</code> \u00e9 nulo, explicando a falha ao tentarmos desreferenci\u00e1-lo. Para investigar a sequ\u00eancia de chamadas de fun\u00e7\u00f5es que conduziu ao estado atual do programa, pode-se exibir um rastreamento de pilha com o comando <code>backtrace</code>:</p> <pre><code>(gdb) backtrace\n#0  0x000055661c11315b in foo (p=0x0) at exemplo.c:12\n#1  0x000055661c113149 in main () at exemplo.c:7\n</code></pre> <p>Outra funcionalidade importante do GDB \u00e9 a capacidade de definir pontos de interrup\u00e7\u00e3o usando o comando <code>break</code>, permitindo a parada da execu\u00e7\u00e3o do programa em pontos espec\u00edficos. Tais pontos podem ser determinados para fun\u00e7\u00f5es espec\u00edficas, linhas ou locais na mem\u00f3ria. Vamos definir um ponto de interrup\u00e7\u00e3o no in\u00edcio da fun\u00e7\u00e3o <code>main</code>:</p> <pre><code>(gdb) break main\nBreakpoint 1 at 0x55661c113135: file exemplo.c, line 5.\n</code></pre> <p>Agora, quando executarmos o programa no GDB, ele ir\u00e1 parar assim que a fun\u00e7\u00e3o <code>main</code> for executada. Poderemos, ent\u00e3o, avan\u00e7ar pela execu\u00e7\u00e3o do programa passo a passo com o comando <code>step</code>, aprimorando a observa\u00e7\u00e3o do comportamento do programa:</p> <pre><code>(gdb) run\nStarting program: exemplo\nBreakpoint 1, main () at exemplo.c:5\n5    int *p = 0;\n(gdb) step\n7    return foo(p);\n(gdb) print p\n$2 = (int *) 0x0    /* ponteiro nulo */\n(gdb)\n</code></pre> <p>As vari\u00e1veis podem ser modificadas durante a depura\u00e7\u00e3o com o comando <code>set var</code>, o que \u00e9 \u00fatil para testar diferentes cen\u00e1rios. Vamos continuar com o nosso exemplo e modificar os valores de <code>p</code> e <code>*p</code>. Por fim, ap\u00f3s modificarmos as vari\u00e1veis, retomaremos a execu\u00e7\u00e3o do programa com o comando <code>continue</code>:</p> <pre><code>(gdb) set variable p = malloc(sizeof(int))\n(gdb) print p\n$3 = (int *) 0x5555555592a0\n(gdb) set variable *p = 255\n(gdb) print *p\n$4 = 255\n(gdb) continue\nContinuing.\n[Inferior 1 (process 17673) exited with code 0377]    /* 0377 base 8 = 255 base 10 */\n(gdb)\n</code></pre> <p>Em resumo, introduzimos o processo de depura\u00e7\u00e3o de programas em C usando o depurador GNU, GDB. Abrangemos os comandos essenciais, incluindo como iniciar o GDB, definir pontos de interrup\u00e7\u00e3o, inspecionar vari\u00e1veis e alterar seus valores, bem como rastrear a sequ\u00eancia de chamadas de fun\u00e7\u00f5es, t\u00e9cnicas vitais para entender e resolver os problemas que ocorrem durante a execu\u00e7\u00e3o do seu c\u00f3digo.</p>"},{"location":"Linguagem_C/capitulo_5/","title":"5. Componentes do Compilador","text":""},{"location":"Linguagem_C/capitulo_5/#51-pre-processador","title":"5.1. Pr\u00e9-processador","text":"<p>Como dito no cap\u00edtulo inicial, o pr\u00e9-processador \u00e9 o componente do GCC respons\u00e1vel por processar e manipular o c\u00f3digo-fonte antes da compila\u00e7\u00e3o come\u00e7ar. Ele l\u00ea o c\u00f3digo-fonte e realiza um conjunto de opera\u00e7\u00f5es, incluindo substitui\u00e7\u00e3o de macros, inclus\u00e3o de arquivos e compila\u00e7\u00e3o condicional. Essas opera\u00e7\u00f5es s\u00e3o definidas por um conjunto de diretivas, que s\u00e3o comandos especiais iniciados pelo s\u00edmbolo <code>#</code>.</p>"},{"location":"Linguagem_C/capitulo_5/#511-inclusao-de-arquivos","title":"5.1.1. Inclus\u00e3o de Arquivos","text":"<p>A diretiva de pr\u00e9-processamento <code>#include</code> \u00e9 utilizada para incluir no c\u00f3digo o conte\u00fado de um arquivo especificado. Existem duas nota\u00e7\u00f5es: - <code>#include&lt;arquivo&gt;</code>: o pr\u00e9-processador buscar\u00e1 o arquivo em algum diret\u00f3rio do sistema (geralmente em <code>/usr/include</code>, em sistemas Unix); - <code>#include\"arquivo\"</code>: o arquivo ser\u00e1 buscado no diret\u00f3rio onde o c\u00f3digo est\u00e1 localizado.</p> <p>Geralmente, os arquivos inclu\u00eddos possuem a extens\u00e3o <code>.h</code> (de header), que s\u00e3o arquivos cabe\u00e7alhos contendo defini\u00e7\u00f5es de macros e declara\u00e7\u00f5es de prot\u00f3tipos de fun\u00e7\u00f5es padr\u00e3o do C. Por\u00e9m, \u00e9 poss\u00edvel criar arquivos de cabe\u00e7alho personalizados e adicionar outros programas em C contendo outros <code>#include</code>, que ser\u00e3o tratados de maneira recursiva pelo pr\u00e9-processador. Veja o exemplo:</p>"},{"location":"Linguagem_C/capitulo_5/#mainc","title":"main.c","text":"<pre><code>#include \"preproc.c\"\n\nint main(){\n  say_hello();\n\n  puts(\"Digite um n\u00famero para obter sua raiz quadrada:\");\n  scanf(\"%lf\", &amp;y);\n  raiz = raiz_quadrada(y);\n  printf(\"O valor da raiz quadrada desse n\u00famero \u00e9: %lf\\n\", raiz);\n  return 0;\n}\n</code></pre>"},{"location":"Linguagem_C/capitulo_5/#preprocc","title":"preproc.c","text":"<pre><code>#pragma once\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n\ndouble y, raiz;\n\nvoid say_hello(){\n  puts(\"Hello!\");\n}\n\ndouble raiz_quadrada(double x){\n  return sqrt(x);\n}\n</code></pre> <p>Ao compilar o programa main.c, o pr\u00e9-processador acoplar\u00e1 o c\u00f3digo de preproc.c. Note que foi necess\u00e1rio utilizar apenas o <code>#include \"preproc.c\"</code> no arquivo principal, pois esse arquivo j\u00e1 cont\u00e9m as diretivas necess\u00e1rias para a execu\u00e7\u00e3o do c\u00f3digo. Caso ocorram m\u00faltiplos <code>#include</code> acidentais, a diretiva <code>#pragma once</code> garante que o respectivo arquivo seja lido apenas uma vez durante o processo de compila\u00e7\u00e3o. Para gerar um arquivo com o c\u00f3digo pr\u00e9-processado, utilize:</p> <pre><code>$ gcc main.c -E -o main_preproc.c\n</code></pre> <p>No final do arquivo gerado, estar\u00e1 o c\u00f3digo dos dois arquivos (preproc.c e main.c).</p>"},{"location":"Linguagem_C/capitulo_5/#512-definicao-de-macros","title":"5.1.2. Defini\u00e7\u00e3o de Macros","text":"<p>Uma macro \u00e9 um peda\u00e7o de c\u00f3digo ao qual se atribui um nome, definida pela diretiva <code>#define</code>. Essa diretiva permite que voc\u00ea atribua um nome a um valor, uma express\u00e3o ou at\u00e9 mesmo a um bloco de c\u00f3digo, facilitando a reutiliza\u00e7\u00e3o sem precisar repetir o c\u00f3digo. Veja o exemplo:</p>"},{"location":"Linguagem_C/capitulo_5/#mainc_1","title":"main.c","text":"<pre><code>#include &lt;stdio.h&gt;\n\n#define SQUARE(x) ((x) * (x))\n#define NUM 10\n\nint main()\n{\n  printf(\"The value of NUM is: %d\\n\", NUM);\n  printf(\"The value of SQUARE(NUM) is: %d\\n\", SQUARE(NUM));\n  return 0;\n}\n</code></pre> <p>O pr\u00e9-processador substitui as ocorr\u00eancias das macros pelo seu conte\u00fado correspondente. Note que, como as macros n\u00e3o possuem escopo ou tipo expl\u00edcito, elas realizam substitui\u00e7\u00f5es simples. No exemplo, a macro <code>NUM</code> \u00e9 interpretada como um inteiro (10) em tempo de compila\u00e7\u00e3o e <code>SQUARE(NUM)</code> executa a multiplica\u00e7\u00e3o. Ao compilar e executar, a sa\u00edda ser\u00e1:</p> <pre><code>The value of NUM is: 10\nThe value of SQUARE(NUM) is: 100\n</code></pre>"},{"location":"Linguagem_C/capitulo_5/#513-compilacao-condicional","title":"5.1.3. Compila\u00e7\u00e3o Condicional","text":"<p>A compila\u00e7\u00e3o condicional permite que se execute uma parte do programa somente se uma certa macro estiver definida. Para isso, utilizamos as diretivas <code>#ifdef</code> e <code>#endif</code>. Por exemplo:</p>"},{"location":"Linguagem_C/capitulo_5/#mainc_2","title":"main.c","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main()\n{\n#ifdef NUM\n  printf(\"The value of NUM is: %d\\n\", NUM);\n#else\n  #error \"A macro NUM n\u00e3o foi definida!\";\n#endif\n  return 0;\n}\n</code></pre> <p>Neste caso, se a macro <code>NUM</code> n\u00e3o estiver definida, a mensagem de erro <code>\"A macro NUM n\u00e3o foi definida!\"</code> ser\u00e1 exibida e a compila\u00e7\u00e3o ser\u00e1 interrompida. Entretanto, podemos definir a macro ao compilar o programa com a op\u00e7\u00e3o <code>-D</code>. Por exemplo:</p> <pre><code>$ gcc -Wall -DNUM=5 main.c -o main\n$ ./main\nThe value of NUM is: 5\n</code></pre> <p>As defini\u00e7\u00f5es de macros passadas na linha de comando possuem maior preced\u00eancia, ou seja, s\u00e3o consideradas antes das defini\u00e7\u00f5es presentes no c\u00f3digo fonte. Um c\u00f3digo similar pode ser feito usando <code>#ifndef</code> e <code>#undef</code>, como no exemplo a seguir:</p>"},{"location":"Linguagem_C/capitulo_5/#mainc_3","title":"main.c","text":"<pre><code>#include &lt;stdio.h&gt;\n#undef NUM\n\nint main(){\n#ifndef NUM\n  #error \"A macro NUM n\u00e3o foi definida!\";\n#else\n  printf(\"The value of NUM is: %d\\n\", NUM);\n#endif\n  return 0;\n}\n</code></pre> <p>Tamb\u00e9m \u00e9 poss\u00edvel utilizar a diretiva <code>#elif</code> em conjunto com <code>#ifdef</code> para simplificar o c\u00f3digo. Por exemplo, se somente a macro <code>Z</code> estiver definida:</p>"},{"location":"Linguagem_C/capitulo_5/#mainc_4","title":"main.c","text":"<pre><code>#include &lt;stdio.h&gt;\n//#define X 'x'\n//#define Y 'y'\n#define Z 'z'\nint main(){\n#ifdef X\n  printf(\"The value of X is: %c\\n\", X);\n#elif defined(Y)\n  printf(\"The value of Y is: %c\\n\", Y);\n#elif defined(Z)\n  printf(\"The value of Z is: %c\\n\", Z);\n#endif\n  return 0;\n}\n</code></pre>"},{"location":"Linguagem_C/capitulo_5/#514-fornecendo-instrucoes","title":"5.1.4. Fornecendo Instru\u00e7\u00f5es","text":"<p>A diretiva <code>#pragma</code> \u00e9 utilizada para fornecer instru\u00e7\u00f5es ao compilador. Essa diretiva n\u00e3o faz parte do padr\u00e3o C e pode variar de acordo com o compilador e a plataforma. Ela \u00e9 utilizada, por exemplo, para for\u00e7ar que uma fun\u00e7\u00e3o seja inline:</p>"},{"location":"Linguagem_C/capitulo_5/#exemplo","title":"Exemplo","text":"<pre><code>#pragma inline\nint add(int a, int b){\n  return a + b;\n}\n</code></pre> <p>Nesse caso, a fun\u00e7\u00e3o <code>add</code> ser\u00e1 substitu\u00edda diretamente em sua chamada, evitando uma chamada de rotina. Tamb\u00e9m \u00e9 poss\u00edvel controlar quais trechos do c\u00f3digo ser\u00e3o otimizados:</p>"},{"location":"Linguagem_C/capitulo_5/#exemplo_1","title":"Exemplo","text":"<pre><code>#pragma optimize(\"\", off) // Desliga a otimiza\u00e7\u00e3o\nint add(int a, int b){\n  return a + b;\n}\n#pragma optimize(\"\", on) // Liga a otimiza\u00e7\u00e3o novamente\n</code></pre> <p>Al\u00e9m disso, <code>#pragma</code> pode ser utilizada para determinar o alinhamento de estruturas de dados em mem\u00f3ria. No exemplo abaixo, for\u00e7amos o alinhamento m\u00ednimo para a estrutura <code>s2</code>:</p>"},{"location":"Linguagem_C/capitulo_5/#mainc_5","title":"main.c","text":"<pre><code>#include &lt;stdio.h&gt;\n\nstruct{\n  char c;  // 1 byte\n  int i;   // 4 bytes\n  double d; // 8 bytes\n}s1;\n#pragma pack(push, 1) // For\u00e7a o alinhamento m\u00ednimo\nstruct{\n  char c;  // 1 byte\n  int i;   // 4 bytes\n  double d; // 8 bytes\n}s2;\n#pragma pack(pop) // Restaura o alinhamento padr\u00e3o\n\nint main(){\n  printf(\"The size of struct 1 is: %ld\\n\", sizeof(s1));\n  printf(\"The size of struct 2 is: %ld\\n\", sizeof(s2));\n  return 0;\n}\n</code></pre> <p>Ao compilar e executar o c\u00f3digo:</p> <pre><code>$ gcc -Wall main.c -o main\n$ ./main\nThe size of struct 1 is: 16\nThe size of struct 2 is: 13\n</code></pre> <p>\u00c9 poss\u00edvel ver que a primeira estrutura consome 3 bytes a mais, pois h\u00e1 preenchimento entre as vari\u00e1veis <code>char</code> e <code>int</code> para garantir o alinhamento adequado (por exemplo, para que o <code>int</code> esteja alinhado a um endere\u00e7o m\u00faltiplo de 4 e o <code>double</code> a um m\u00faltiplo de 8).</p>"},{"location":"Linguagem_C/capitulo_5/#52-compilador","title":"5.2. Compilador","text":"<p>Falar sobre \u00c1rvore de Deriva\u00e7\u00e3o, resumir o processo de compila\u00e7\u00e3o e t\u00e9cnicas, comentar sobre otimiza\u00e7\u00e3o (otimiza\u00e7\u00e3o j\u00e1 foi falada no cap\u00edtulo seguinte, ent\u00e3o \u00e9 s\u00f3 comentar informa\u00e7\u00f5es relevantes)...</p>"},{"location":"Linguagem_C/capitulo_5/#53-montador","title":"5.3. Montador","text":"<p>O montador \u00e9 o componente respons\u00e1vel por traduzir um c\u00f3digo de montagem em c\u00f3digo de m\u00e1quina, conforme mencionado na introdu\u00e7\u00e3o. Al\u00e9m disso, ele lida com s\u00edmbolos, diretivas de montagem e dados, organizando-os de forma execut\u00e1vel. Como o GCC \u00e9 compat\u00edvel com diversas arquiteturas, ele suporta diretivas espec\u00edficas que tratam de alinhamento dos dados, defini\u00e7\u00e3o de constantes e strings, determina\u00e7\u00e3o de se\u00e7\u00f5es de c\u00f3digo, dados e endere\u00e7os de mem\u00f3ria onde as instru\u00e7\u00f5es e/ou os dados ser\u00e3o posicionados, entre outras fun\u00e7\u00f5es. Durante a montagem, o GCC resolve endere\u00e7os, offsets (deslocamentos), alinha dados, manipula macros e gera a tabela de s\u00edmbolos e de realoca\u00e7\u00e3o. Para ilustrar, considere o seguinte exemplo de c\u00f3digo em C:</p>"},{"location":"Linguagem_C/capitulo_5/#mainc_6","title":"main.c","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n  printf(\"Ol\u00e1, mundo!\\n\");\n  return 0;\n}\n</code></pre> <p>Ao compilar esse programa com o GCC, o compilador gera um c\u00f3digo intermedi\u00e1rio que \u00e9 convertido em c\u00f3digo de montagem. Esse arquivo de montagem pode ser gerado explicitamente com:</p> <pre><code>gcc -S hello_world.c\n</code></pre> <p>Isso criar\u00e1 um arquivo chamado hello_world.s. Para compilar esse arquivo de montagem e gerar um objeto, utilize:</p> <pre><code>gcc -c hello_world.s -o hello_world.o\n</code></pre> <p>Continuar...</p>"},{"location":"Linguagem_C/capitulo_5/#54-ligador","title":"5.4. Ligador","text":"<p>O ligador \u00e9 o componente que atua na fase final da compila\u00e7\u00e3o. Ele combina os arquivos-objeto gerados, resolve s\u00edmbolos definidos em outros arquivos-fonte e incorpora bibliotecas ao c\u00f3digo para gerar o arquivo execut\u00e1vel final. Enquanto na fase anterior os endere\u00e7os dos dados e c\u00f3digos s\u00e3o tratados de forma relativa, nesta etapa esses endere\u00e7os s\u00e3o ajustados para refletir suas posi\u00e7\u00f5es reais na mem\u00f3ria.</p> <p>Continuar...</p>"},{"location":"Linguagem_C/capitulo_6/","title":"6. Compilando com Otimiza\u00e7\u00e3o","text":"<p>O GCC \u00e9 um compilador otimizador que pode gerar arquivos execut\u00e1veis mais r\u00e1pidos e/ou menores, levando em considera\u00e7\u00e3o as caracter\u00edsticas do processador alvo e a ordem das instru\u00e7\u00f5es. A otimiza\u00e7\u00e3o \u00e9 um processo complexo que envolve a escolha da melhor combina\u00e7\u00e3o de instru\u00e7\u00f5es de m\u00e1quina para cada comando de alto n\u00edvel no c\u00f3digo-fonte. Diferentes c\u00f3digos devem ser gerados para processadores distintos, devido ao uso de linguagens de montagem e m\u00e1quina incompat\u00edveis. Al\u00e9m disso, cada tipo de processador possui caracter\u00edsticas pr\u00f3prias, como o n\u00famero de registradores dispon\u00edveis, que afetam a forma como o c\u00f3digo \u00e9 gerado. Ao compilar com otimiza\u00e7\u00e3o, o GCC leva em considera\u00e7\u00e3o todos esses fatores.</p>"},{"location":"Linguagem_C/capitulo_6/#61-otimizacao-em-nivel-de-codigo-fonte","title":"6.1. Otimiza\u00e7\u00e3o em N\u00edvel de C\u00f3digo-fonte","text":"<p>A otimiza\u00e7\u00e3o em n\u00edvel de c\u00f3digo-fonte melhora o desempenho de um programa por meio de altera\u00e7\u00f5es no c\u00f3digo-fonte. Duas otimiza\u00e7\u00f5es comuns s\u00e3o a elimina\u00e7\u00e3o de subexpress\u00f5es repetidas e o inline de fun\u00e7\u00f5es.</p>"},{"location":"Linguagem_C/capitulo_6/#611-eliminacao-de-subexpressoes-comuns","title":"6.1.1. Elimina\u00e7\u00e3o de Subexpress\u00f5es Comuns","text":"<p>A elimina\u00e7\u00e3o de subexpress\u00f5es repetidas evita a reavalia\u00e7\u00e3o de uma mesma express\u00e3o v\u00e1rias vezes. Por exemplo, a express\u00e3o</p> <pre><code>x = cos(v).(1+sin(u/2)) + sin(w).(1-sin(u/2))\n</code></pre> <p>pode ser reescrita como</p> <pre><code>t = sin(u/2); x = cos(v).(1+t) + sin(w).(1-t)\n</code></pre> <p>evitando a avalia\u00e7\u00e3o duplicada de <code>sin(u/2)</code>.</p>"},{"location":"Linguagem_C/capitulo_6/#612-inclusao-de-funcao","title":"6.1.2. Inclus\u00e3o de Fun\u00e7\u00e3o","text":"<p>O inline de fun\u00e7\u00f5es substitui uma chamada de fun\u00e7\u00e3o pelo seu pr\u00f3prio corpo, reduzindo a sobrecarga das chamadas de fun\u00e7\u00e3o. Por exemplo, a fun\u00e7\u00e3o <code>sq(x)</code> pode ser inlineada no loop:</p> <pre><code>for (i = 0; i &lt; 1000000; i++)\n  sum += sq(i + 0.5);\n</code></pre> <p>Isso substitui o loop interno pelo corpo da fun\u00e7\u00e3o <code>sq(x)</code>, melhorando o desempenho ao evitar chamadas de fun\u00e7\u00e3o.</p>"},{"location":"Linguagem_C/capitulo_6/#613-trade-offs-de-velocidade-e-espaco","title":"6.1.3. Trade-offs de Velocidade e Espa\u00e7o","text":"<p>Algumas formas de otimiza\u00e7\u00e3o podem aumentar a velocidade e reduzir o tamanho do programa simultaneamente, enquanto outras produzem c\u00f3digo mais r\u00e1pido em troca de um execut\u00e1vel maior. Esse \u00e9 o chamado trade-off de velocidade e espa\u00e7o. Tais otimiza\u00e7\u00f5es podem, inclusive, ser aplicadas de forma inversa, diminuindo o tamanho do execut\u00e1vel em detrimento da velocidade de execu\u00e7\u00e3o.</p>"},{"location":"Linguagem_C/capitulo_6/#614-desenrolamento-de-loops","title":"6.1.4. Desenrolamento de Loops","text":"<p>O desenrolamento de loops \u00e9 uma otimiza\u00e7\u00e3o que aumenta a velocidade dos loops eliminando a condi\u00e7\u00e3o de \"fim do loop\" em cada itera\u00e7\u00e3o. Ele permite atribui\u00e7\u00f5es diretas, sem a necessidade de testes, resultando em uma execu\u00e7\u00e3o mais r\u00e1pida. Contudo, o desenrolamento pode aumentar o tamanho do execut\u00e1vel, exceto em loops muito curtos.</p>"},{"location":"Linguagem_C/capitulo_6/#615-agendamento","title":"6.1.5. Agendamento","text":"<p>O agendamento \u00e9 o n\u00edvel mais baixo de otimiza\u00e7\u00e3o, onde o compilador determina a melhor ordem de execu\u00e7\u00e3o das instru\u00e7\u00f5es individuais. Essa t\u00e9cnica melhora a velocidade do execut\u00e1vel sem aumentar seu tamanho, mas exige mem\u00f3ria adicional e tempo durante o processo de compila\u00e7\u00e3o.</p>"},{"location":"Linguagem_C/capitulo_6/#62-niveis-de-otimizacao-no-gcc","title":"6.2. N\u00edveis de Otimiza\u00e7\u00e3o no GCC","text":"<p>O GCC oferece diferentes n\u00edveis de otimiza\u00e7\u00e3o (0 a 3) para controlar o tempo de compila\u00e7\u00e3o, o uso de mem\u00f3ria do compilador e o trade-off entre velocidade e espa\u00e7o no execut\u00e1vel resultante. Os n\u00edveis de otimiza\u00e7\u00e3o s\u00e3o:</p> <ul> <li><code>-O0</code> (padr\u00e3o): Sem otimiza\u00e7\u00e3o, compilando de forma direta para facilitar a depura\u00e7\u00e3o.</li> <li><code>-O1</code>: Otimiza\u00e7\u00f5es comuns sem trade-offs significativos de velocidade e espa\u00e7o.</li> <li><code>-O2</code>: Otimiza\u00e7\u00f5es adicionais sem aumentar o tamanho do execut\u00e1vel.</li> <li><code>-O3</code>: Otimiza\u00e7\u00f5es mais custosas que podem aumentar o tamanho do execut\u00e1vel.</li> <li><code>-funroll-loops</code>: Desenrolamento de loops, aumentando o tamanho do execut\u00e1vel.</li> <li><code>-Os</code>: Otimiza\u00e7\u00f5es para reduzir o tamanho do execut\u00e1vel.</li> </ul> <p>\u00c9 importante considerar os custos das otimiza\u00e7\u00f5es, como maior complexidade na depura\u00e7\u00e3o e maior tempo/mem\u00f3ria de compila\u00e7\u00e3o. Geralmente, <code>-O0</code> \u00e9 usado para depura\u00e7\u00e3o e <code>-O2</code> para desenvolvimento e implanta\u00e7\u00e3o.</p>"},{"location":"Linguagem_C/capitulo_6/#63-otimizacao-e-depuracao","title":"6.3. Otimiza\u00e7\u00e3o e Depura\u00e7\u00e3o","text":"<p>Com o GCC, \u00e9 poss\u00edvel usar otimiza\u00e7\u00e3o em combina\u00e7\u00e3o com a op\u00e7\u00e3o de depura\u00e7\u00e3o <code>-g</code>. Muitos compiladores n\u00e3o permitem essa combina\u00e7\u00e3o. Ao usar depura\u00e7\u00e3o e otimiza\u00e7\u00e3o juntas, as reorganiza\u00e7\u00f5es internas feitas pelo otimizador podem dificultar a compreens\u00e3o do que est\u00e1 acontecendo ao examinar um programa otimizado no depurador. Por exemplo, vari\u00e1veis tempor\u00e1rias geralmente s\u00e3o eliminadas e a ordem das instru\u00e7\u00f5es pode ser alterada. No entanto, quando um programa trava inesperadamente, qualquer informa\u00e7\u00e3o de depura\u00e7\u00e3o \u00e9 melhor do que nenhuma, portanto, o uso de <code>-g</code> \u00e9 recomendado tanto para desenvolvimento quanto para implanta\u00e7\u00e3o. Nas vers\u00f5es dos pacotes GNU, a op\u00e7\u00e3o de depura\u00e7\u00e3o <code>-g</code> \u00e9 habilitada por padr\u00e3o juntamente com a op\u00e7\u00e3o de otimiza\u00e7\u00e3o <code>-O2</code>.</p>"},{"location":"Linguagem_C/capitulo_6/#64-otimizacao-e-avisos-do-compilador","title":"6.4. Otimiza\u00e7\u00e3o e Avisos do Compilador","text":"<p>Quando a otimiza\u00e7\u00e3o \u00e9 ativada, o GCC pode produzir avisos adicionais que n\u00e3o aparecem ao compilar sem otimiza\u00e7\u00e3o. Durante a otimiza\u00e7\u00e3o, o compilador realiza uma an\u00e1lise de fluxo de dados, examinando o uso de todas as vari\u00e1veis e seus valores iniciais. Essa an\u00e1lise \u00e9 a base para outras estrat\u00e9gias de otimiza\u00e7\u00e3o, como o agendamento de instru\u00e7\u00f5es, e pode detectar o uso de vari\u00e1veis n\u00e3o inicializadas.</p> <p>A op\u00e7\u00e3o <code>-Wuninitialized</code> (inclu\u00edda em <code>-Wall</code>) avisa sobre vari\u00e1veis que s\u00e3o lidas sem serem inicializadas. Ela s\u00f3 funciona quando o programa \u00e9 compilado com otimiza\u00e7\u00e3o, pois \u00e9 necess\u00e1rio que a an\u00e1lise de fluxo de dados esteja ativa. Considere o seguinte exemplo:</p>"},{"location":"Linguagem_C/capitulo_6/#exemplo","title":"Exemplo","text":"<pre><code>int sign(int x)\n{\n  int s;\n  if (x &gt; 0)\n    s = 1;\n  else if (x &lt; 0)\n    s = -1;\n  return s;\n}\n</code></pre> <p>A fun\u00e7\u00e3o funciona corretamente para a maioria dos argumentos, mas tem um bug quando <code>x</code> \u00e9 zero \u2013 nesse caso, o valor de retorno da vari\u00e1vel <code>s</code> ser\u00e1 indefinido. Compilar o programa apenas com a op\u00e7\u00e3o <code>-Wall</code> n\u00e3o produz nenhum aviso, porque a an\u00e1lise de fluxo de dados n\u00e3o \u00e9 realizada sem otimiza\u00e7\u00e3o:</p> <pre><code>$ gcc -Wall -c uninit.c\n</code></pre> <p>Para gerar um aviso, o programa deve ser compilado com <code>-Wall</code> e otimiza\u00e7\u00e3o simultaneamente. Na pr\u00e1tica, o n\u00edvel de otimiza\u00e7\u00e3o <code>-O2</code> \u00e9 recomendado para obter bons avisos:</p> <pre><code>$ gcc -Wall -O2 -c uninit.c\n</code></pre> <p>Isso detecta corretamente a possibilidade de a vari\u00e1vel <code>s</code> ser usada sem ser definida. Embora o GCC geralmente encontre a maioria das vari\u00e1veis n\u00e3o inicializadas, ele utiliza heur\u00edsticas que podem, ocasionalmente, deixar passar casos complicados ou emitir falsos avisos. Nesses casos, pode ser \u00fatil reescrever as partes relevantes do c\u00f3digo para melhorar a legibilidade e eliminar o aviso.</p>"},{"location":"Linguagem_C/gloss%C3%A1rio/","title":"Gloss\u00e1rio","text":"<ul> <li>Arquivo Execut\u00e1vel: \u00c9 um arquivo, interpretado pelo sistema operacional como um programa, que cont\u00e9m instru\u00e7\u00f5es do processador em quest\u00e3o, geralmente representadas em bin\u00e1rio, para a execu\u00e7\u00e3o de tarefas no computador.</li> <li>Arquivo Objeto: Arquivo resultante da compila\u00e7\u00e3o de um c\u00f3digo fonte. Possui v\u00e1rios formatos, como o ELF (Executable and Linking Format) do padr\u00e3o Unix. Al\u00e9m de c\u00f3digo objeto, \u00e9 composto por um cabe\u00e7alho com informa\u00e7\u00f5es de debug, aloca\u00e7\u00e3o de mem\u00f3ria e s\u00edmbolos (nome de vari\u00e1veis e de fun\u00e7\u00f5es). Podem ser ligados a outros arquivos objetos para formar um arquivo execut\u00e1vel ou arquivo de biblioteca.</li> <li>Assembly: Nota\u00e7\u00e3o leg\u00edvel para o ser humano do c\u00f3digo de m\u00e1quina, isto \u00e9, um apelido que representa uma instru\u00e7\u00e3o de m\u00e1quina, mais f\u00e1cil de ser entendido do que uma sequ\u00eancia bin\u00e1ria.</li> <li>Bootstrapping: Processo pelo qual o compilador de uma linguagem \u00e9 escrito na pr\u00f3pria linguagem. Geralmente, o compilador inicial \u00e9 feito em uma linguagem de baixo n\u00edvel e, depois, \u00e9 reescrito na pr\u00f3pria linguagem em alto n\u00edvel.</li> <li>Bytecode: C\u00f3digo intermedi\u00e1rio gerado pelo interpretador e que ser\u00e1 executado diretamente em uma m\u00e1quina virtual.</li> <li>C\u00f3digo Fonte: \u00c9 um arquivo que cont\u00e9m as instru\u00e7\u00f5es escritas pelo programador, interpretado pelo sistema operacional como um programa, e que ser\u00e1 transformado em c\u00f3digo execut\u00e1vel.</li> <li>C\u00f3digo Objeto: C\u00f3digo escrito em linguagem de m\u00e1quina (bin\u00e1ria) ou em uma linguagem intermedi\u00e1ria que pode ser interpretada e executada pelo computador.</li> <li>Linguagem de Programa\u00e7\u00e3o: Estrutura contendo regras sem\u00e2nticas e sint\u00e1ticas expressas atrav\u00e9s de um c\u00f3digo fonte, que pode ser transformado em um programa de computador por meio da compila\u00e7\u00e3o ou ser interpretado para execu\u00e7\u00e3o.</li> </ul>"}]}