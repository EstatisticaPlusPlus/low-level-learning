{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Sobre","text":"<p>O projeto de extens\u00e3o visa criar materiais educacionais sobre as linguagens de programa\u00e7\u00e3o C e Fortran. Inicialmente, os materiais foram feitos em LaTeX, destacando os conceitos b\u00e1sicos de C e explorando o compilador GCC. Mais tarde, optamos por migrar para uma plataforma online usando HTML5 e CSS para oferecer conte\u00fado mais acess\u00edvel e interativo aos usu\u00e1rios interessados. Por fim, estou repassando para o MkDocs para facilitar a adi\u00e7\u00e3o de novos cap\u00edtulos. Essa transi\u00e7\u00e3o permitir\u00e1 uma melhor experi\u00eancia de aprendizado para os estudantes e entusiastas das linguagens.</p>"},{"location":"#estrutura","title":"Estrutura","text":"<p>Em constru\u00e7\u00e3o..</p>"},{"location":"#inspiracao","title":"Inspira\u00e7\u00e3o","text":"<p>Cap\u00edtulos da Linguagem C:</p> <p>\"An Introduction to GCC\" \u00e9 um livro que oferece uma introdu\u00e7\u00e3o pr\u00e1tica e abrangente sobre o compilador GNU Compiler Collection (GCC) e seu uso na programa\u00e7\u00e3o em linguagem C. Os autores explicam desde conceitos b\u00e1sicos at\u00e9 t\u00e9cnicas avan\u00e7adas de compila\u00e7\u00e3o, incluindo o funcionamento interno do GCC. \u00c9 uma leitura \u00fatil para estudantes e desenvolvedores interessados em compreender melhor como usar o GCC para compilar programas em C e aprofundar seus conhecimentos sobre compila\u00e7\u00e3o, otimiza\u00e7\u00e3o e depura\u00e7\u00e3o de c\u00f3digo.</p> <p>Cap\u00edtulos em Fortran:</p> <ul> <li>Fortran 77: Guia de Stanford para F77</li> <li>Fortran 90: ...</li> </ul>"},{"location":"#referencias","title":"Refer\u00eancias","text":"<p>UGH, Brian J.; STALLMAN, Richard M. An Introduction to GCC. Network Theory Ltd., 2004. ISBN 978-0954161798.</p> <p>TANFORD UNIVERSITY. ME 200C - Basics of the Finite Element Method. Dispon\u00edvel em: https://web.stanford.edu/class/me200c/tutorial_77/03_basics.html. Acesso em: 23 mar. 2025.</p>"},{"location":"Autotools/capitulo_1/","title":"1. Introdu\u00e7\u00e3o e Instala\u00e7\u00e3o","text":""},{"location":"Autotools/capitulo_1/#11-introducao","title":"1.1. Introdu\u00e7\u00e3o","text":"<p>GNU Autotools \u00e9 um conjunto de ferramentas do GNU que visam a padroniza\u00e7\u00e3o e facilitamento da compila\u00e7\u00e3o de diversas linguagens para diferente arquiteturas e sistemas operacionais.</p>"},{"location":"Autotools/capitulo_1/#12-instalacao","title":"1.2. Instala\u00e7\u00e3o","text":"<p>O pacote do Autotools possivelmente est\u00e1 presente no seu gerenciador de pacotes padr\u00e3o do seu sistema. No Ubuntu, por exemplo, o comando para baixar \u00e9:</p> <pre><code>$ sudo apt install autotools-dev\n</code></pre> <p>Este comando baixar\u00e1 e instalar\u00e1 todas as ferramentas necess\u00e1rias para acompanhar essa documenta\u00e7\u00e3o</p>"},{"location":"Autotools/capitulo_2/","title":"2. Comandos B\u00e1sicos","text":"<p>Para come\u00e7ar, crie um arquivo com o nome <code>configure.ac</code> e escreva:</p> <pre><code>AC_INIT\n\nAC_OUTPUT\n</code></pre> <ul> <li> <p><code>AC_INIT([projeto], [vers\u00e3o])</code>: Macro para iniciar o Autoconf com dois   argumentos opcionais para o nome do projeto e para a vers\u00e3o do projeto</p> </li> <li> <p><code>AC_OUTPUT</code>: Macro para indicar a sa\u00edda das mensagens do autoconf, nesse   caso ser\u00e1 o <code>stdout</code></p> </li> </ul> <p>Agora, dentro do mesmo diret\u00f3rio onde o arquivo <code>configure.ac</code> reside, digite:</p> <pre><code>$ autoconf\n</code></pre> <p>Caso n\u00e3o haja erros, a n\u00e3o haver\u00e1 nenhuma sa\u00edda e um execut\u00e1vel <code>configure</code> ser\u00e1 criado.</p> <p>Agora, executando esse arquivo a sa\u00edda ser\u00e1: <pre><code>$ ./configure\nconfigure: creating ./config.status\n</code></pre> e tamb\u00e9m ser\u00e3o criados outros arquivos que n\u00e3o s\u00e3o relevantes no momento</p>"},{"location":"Autotools/capitulo_2/#21-checagem-de-compiladores-comuns","title":"2.1. Checagem de Compiladores Comuns","text":"<p>No mesmo arquivo, adicione:</p> <pre><code>AC_INPUT\n\nAC_PROG_CC\nAC_PROG_CXX\n\nAC_OUTPUT\n</code></pre> <ul> <li><code>AC_PROG_CC</code>: Macro para fazer as verifia\u00e7\u00f5es padr\u00e3o do compilador gcc</li> <li><code>AC_PROG_CXX</code>: Macro para fazer as verifia\u00e7\u00f5es padr\u00e3o do compilador g++</li> </ul> <p>Caso o seu sistema possua um compilador de c e c++, a saida deste programa ser\u00e1:</p> <pre><code>$ autoconf\n$ ./configure\nchecking for gcc... gcc\nchecking whether the C compiler works... yes\nchecking for C compiler default output file name... a.out\nchecking for suffix of executables...\nchecking whether we are cross compiling... no\nchecking for suffix of object files... o\nchecking whether the compiler supports GNU C... yes\nchecking whether gcc accepts -g... yes\nchecking for gcc option to enable C11 features... none needed\nchecking for g++... g++\nchecking whether the compiler supports GNU C++... yes\nchecking whether g++ accepts -g... yes\nchecking for g++ option to enable C++11 features... none needed\nconfigure: creating ./config.status\n</code></pre> <p>A saida pode ser levemente diferente dependendo das vers\u00f5es dispon\u00edveis do c e c++ no seu sistema e do sistema operacional presente.</p> <p>Os comandos na forma <code>AC_PROG_XX</code> s\u00e3o usados para verifia\u00e7\u00f5es de compiladores, nesse caso o gcc</p> <p>Outros compiladores s\u00e3o suportados, como o de fortran, objetive-c e go, consulte o manual do autoconf para encontrar os comandos desses compiladores.</p>"},{"location":"Autotools/capitulo_2/#22-checagem-de-bibliotecas-tipos-e-funcoes","title":"2.2 Checagem de Bibliotecas, Tipos e Fun\u00e7\u00f5es","text":"<p>\u00c9 poss\u00edvel tamb\u00e9m fazer checagens de fun\u00e7\u00f5es, bibliotecas e at\u00e9 tipos definidos nativamente com autoconf</p> <p>No arquivo <code>configure.ac</code> criado anteriormente, adicione as seguintes linhas:</p> <pre><code>AC_INIT\n\nAC_PROG_CC\n\nAC_TYPE_SIZE_T\nAC_TYPE_UINT32_T\n\nAC_CHECK_HEADERS([stdlib.h stdio.h string.h unistd.h])\n\nAC_CHECK_LIB([pthread], [pthread_create])\nAC_CHECK_LIB([m], [sqrt])\n\nAC_CHECK_FUNCS([malloc memset strchr])\n\nAC_OUTPUT\n</code></pre> <ul> <li><code>AC_TYPE_SIZE_T</code>: Macro para verificar a exist\u00eancia do tipo <code>size_t</code></li> <li><code>AC_TYPE_UINT32_T</code>: Macro para verificar a exist\u00eancia do tipo <code>uint32_t</code></li> <li><code>AC_CHECK_HEADERS([headers])</code>: Macro para verificar a exist\u00eancia de   bibliotecas no sistema. As bibliotecas devem ser separadas por espa\u00e7os</li> <li><code>AC_CHECK_LIB([lib], [func])</code>: Macro para verificar a exist\u00eancia de uma   fun\u00e7\u00e3o espec\u00edfica dentro de uma biblioteca</li> <li><code>AC_CHECK_FUNCS([funcs])</code>: Macro para verificar a exist\u00eancia de fun\u00e7\u00f5es no   sistema, independente de onde elas venham. As fun\u00e7\u00f5es devem ser separadas por   espa\u00e7os</li> </ul> <p>Ao executar os comandos corretos para a checagem, caso n\u00e3o hajam erros, a sa\u00edda ser\u00e1:</p> <pre><code>$ autoconf\n$ ./configure\nchecking for gcc... gcc\nchecking whether the C compiler works... yes\nchecking for C compiler default output file name... a.out\nchecking for suffix of executables...\nchecking whether we are cross compiling... no\nchecking for suffix of object files... o\nchecking whether the compiler supports GNU C... yes\nchecking whether gcc accepts -g... yes\nchecking for gcc option to enable C11 features... none needed\nchecking for stdio.h... yes\nchecking for stdlib.h... yes\nchecking for string.h... yes\nchecking for inttypes.h... yes\nchecking for stdint.h... yes\nchecking for strings.h... yes\nchecking for sys/stat.h... yes\nchecking for sys/types.h... yes\nchecking for unistd.h... yes\nchecking for size_t... yes\nchecking for uint32_t... yes\nchecking for stdlib.h... yes\nchecking for stdio.h... yes\nchecking for string.h... yes\nchecking for unistd.h... yes\nchecking for pthread_create in -lpthread... yes\nchecking for sqrt in -lm... yes\nchecking for malloc... yes\nchecking for memset... yes\nchecking for strchr... yes\nconfigure: creating ./config.status\n</code></pre> <p>Em um sistema operacional diferente, e em vers\u00f5es diferentes do c, a sa\u00edda ser\u00e1 levemente diferente, por\u00e9m, sem mensagens de errors sendo apresentadas, est\u00e1 tudo correto.</p> <p>Como \u00e9 poss\u00edvel observar, o autoconf automaticamente determina de onde certos tipos vem e checa a exist\u00eancia do header que conteria esse tipo. A verifica\u00e7\u00e3o da biblioteca <code>inttypes.h</code> \u00e9 respons\u00e1vel por aferir a presen\u00e7a dos tipos <code>size_t</code> e <code>uint32_t</code>, os quais foram constatada a exist\u00eancia logo ap\u00f3s.</p> <p>O mesmo se aplica \u00e0s fun\u00e7\u00f5es, <code>malloc</code> e <code>memset</code> est\u00e3o presentes em <code>stdlib.h</code>, que foram checados anteriormente pelo <code>configure</code>, e logo ap\u00f3s averiguados.</p>"},{"location":"C%2B%2B/1_introducao/","title":"Introdu\u00e7\u00e3o","text":"<p>Primeiro encontro com o b\u00e1sico de alguns conceitos de programa\u00e7\u00e3o.</p>"},{"location":"C%2B%2B/1_introducao/#programa-de-computador","title":"Programa de computador","text":"<p>Um programa de computador \u00e9 uma sequ\u00eancia de instru\u00e7\u00f5es que descreve tarefas a serem executadas por um computador. Uma receita de bolo est\u00e1 para um confeiteiro como um programa est\u00e1 para um computador.</p>"},{"location":"C%2B%2B/1_introducao/#linguagem-de-programacao","title":"Linguagem de programa\u00e7\u00e3o","text":"<p>Para escrever programas, utiliza-se linguagens especializadas em escrever instru\u00e7\u00f5es para computadores: as linguagens de programa\u00e7\u00e3o. Nos concentraremos na linguagem C++.</p> <p>\u00c0s instru\u00e7\u00f5es escritas em uma linguagem de programa\u00e7\u00e3o damos o nome de c\u00f3digo.</p>"},{"location":"C%2B%2B/1_introducao/#editor-de-texto","title":"Editor de texto","text":"<p>Um programa pode ser escrito em qualquer editor de texto, como Word, bloco de notas, Google Docs e WordPad, por exemplo. Por\u00e9m, existem editores de texto especializados no desenvolvimento de programas, trazendo consigo ferramentas indispens\u00e1veis.</p> <p>Desses, um editor muito comum entre programadores e simples de utilizar \u00e9 o Visual Studio Code. Segue um tutorial de como baixar e instalar o Visual Studio Code no Windows.</p>"},{"location":"C%2B%2B/1_introducao/#compiladores","title":"Compiladores","text":"<p>Apesar de utilizarmos uma linguagem de programa\u00e7\u00e3o, o computador ainda n\u00e3o consegue executar instru\u00e7\u00f5es. Um computador entende apenas instru\u00e7\u00f5es em linguagem de m\u00e1quina, codificadas apenas com sequ\u00eancias de caracteres 0 e 1. Este \u00e9 o \u00fanico formato em que um computador \u00e9 capaz de executar uma instru\u00e7\u00e3o.</p> <p>A compila\u00e7\u00e3o \u00e9 o processo de transformar  instru\u00e7\u00f5es em uma linguagem de programa\u00e7\u00e3o em um arquivo execut\u00e1vel com instru\u00e7\u00f5es em linguagem de m\u00e1quina.</p> <p>Um compilador \u00e9 um programa capaz de compilar um programa. O compilador de C++ que usaremos \u00e9 o G++. Segue um tutorial de como baixar e instalar o G++ no Windows.</p>"},{"location":"C%2B%2B/1_introducao/#hello-world","title":"Hello World","text":"<p>Come\u00e7aremos analisando um programa simples que apenas exibe a frase \"Hello World!\" na tela: <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main() {\n    cout &lt;&lt; \"Hello World!\" &lt;&lt; endl;\n}\n</code></pre></p> <p>Ele estar\u00e1 no arquivo hello-world.cpp. Arquivos em c++ tem a extens\u00e3o .cpp.</p>"},{"location":"C%2B%2B/1_introducao/#main","title":"<code>main</code>","text":"<p>Primeiramente, analisemos: <pre><code>int main() {\n\n}\n</code></pre> Esta se\u00e7\u00e3o do programa \u00e9 a fun\u00e7\u00e3o <code>main</code>. Todo programa em C++ tem uma <code>main</code>, ela \u00e9 o ponto de partida de sua execu\u00e7\u00e3o. Em outras palavras: ao executar um programa, os comandos entre as chaves da main partem a ser executados sequencialmente, de cima para baixo.</p>"},{"location":"C%2B%2B/1_introducao/#cout","title":"<code>cout</code>","text":"<p>Agora, vejamos o comando <pre><code>cout &lt;&lt; \"Hello World!\" &lt;&lt; endl;\n</code></pre></p> <p>O comando <code>cout</code>, acr\u00f4nimo para \"character output\"(sa\u00edda de caracteres), exibe caracteres na tela. Os caracteres a serem exibidos s\u00e3o passados para o comando atrav\u00e9s do operador <code>&lt;&lt;</code>. Pode-se pensar que a informa\u00e7\u00e3o segue o fluxo das setas.</p> <p>O texto \"Hello World!\" \u00e9 passado para o comando e, logo ap\u00f3s, \u00e9 passado o <code>endl</code>. O <code>endl</code> pula uma linha no texto sendo exibido. Caso mais caracteres fossem exibidos ap\u00f3s ele, apareceriam na linha abaixo. Para \"Hello\" e \"World\" estarem em linhas diferentes, por exemplo, uma op\u00e7\u00e3o \u00e9: <pre><code>cout &lt;&lt; \"Hello\" &lt;&lt; endl &lt;&lt; \"World!\" &lt;&lt; endl;\n</code></pre></p> <p>Que pode ser separado em dois comandos com o mesmo efeito <pre><code>cout &lt;&lt; \"Hello\" &lt;&lt; endl;\ncout &lt;&lt; \"World!\" &lt;&lt; endl;\n</code></pre></p> <p>Em C++, a grande maioria dos comandos terminam em <code>;</code> , assim como acima. Esquecer um <code>;</code> ao fim de um comando \u00e9 um erro comum.</p>"},{"location":"C%2B%2B/1_introducao/#diretivas","title":"Diretivas","text":"<p>Os comandos <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n</code></pre></p> <p>S\u00e3o diretivas. Uma diretiva \u00e9 um comando que \u00e9 executado em tempo de compila\u00e7\u00e3o, alterando o comportamento da compila\u00e7\u00e3o.</p>"},{"location":"C%2B%2B/1_introducao/#include","title":"<code>#include</code>","text":"<p>A diretiva <code>#include</code> faz com que o compilador inclua, no lugar do comando, um c\u00f3digo em outro lugar do computador, especificado logo ap\u00f3s a diretiva. Este c\u00f3digo pode ser um c\u00f3digo seu ou uma biblioteca: uma cole\u00e7\u00e3o de c\u00f3digo contendo funcionalidades que podem ser utilizadas no programa atual.</p> <p>No programa Hello World inclu\u00edmos a biblioteca \\&lt;iostream&gt;, que cont\u00e9m o comando <code>cout</code>. Essa biblioteca faz parte da biblioteca padr\u00e3o do C++.</p> <p>Pode-se at\u00e9 incluir a biblioteca padr\u00e3o inteira com o comando <pre><code>#include &lt;bits/stdc++.h&gt;\n</code></pre></p> <p>Por\u00e9m, por tornar os arquivos muito grandes ao incluir c\u00f3digo demais, isso n\u00e3o \u00e9 uma boa pr\u00e1tica de programa\u00e7\u00e3o.</p>"},{"location":"C%2B%2B/1_introducao/#using-namespace","title":"<code>using namespace</code>","text":"<p>A diretiva <code>**using namespace**</code> nos permite n\u00e3o especificar o espa\u00e7o de nomes dos comandos abaixo da diretiva.</p> <p>Um espa\u00e7o de nomes \u00e9 an\u00e1logo ao sobrenome do comando, criado para n\u00e3o haver ambiguidade entre comandos de duas bibliotecas diferentes com mesmo nome. <code>**std**</code> \u00e9 o espa\u00e7o de nomes da biblioteca padr\u00e3o do C++. Caso a diretiva n\u00e3o fosse utilizada, o espa\u00e7o de nomes do <code>cout</code> deveria ser especificada com <code>::</code> <pre><code>#include &lt;iostream&gt;\n\nint main() {\n    std::cout &lt;&lt; \"Hello World!\" &lt;&lt; std::endl;\n}\n</code></pre></p> <p>O compilador n\u00e3o reconhece um comando da <code>std</code> sem seu espa\u00e7o de nomes ser identificado, seja pela diretiva <code>using namespace</code> ou pelo prefixo <code>std::</code>. A compila\u00e7\u00e3o falhar\u00e1 caso um comando n\u00e3o seja reconhecido pelo compilador.</p>"},{"location":"C%2B%2B/1_introducao/#indentacao","title":"Indenta\u00e7\u00e3o","text":"<p>Indenta\u00e7\u00e3o s\u00e3o espa\u00e7os em branco antes de comandos. Geralmente, s\u00e3o usados para facilitar a visualiza\u00e7\u00e3o de que um comando est\u00e1 dentro de um par de chaves, como na <code>main</code>.</p> <p>Em algumas linguagens, a indenta\u00e7\u00e3o \u00e9 obrigat\u00f3ria, fazendo parte das regras de sintaxe da linguagem. N\u00e3o \u00e9 o caso do C++, onde espa\u00e7os em branco adicionais n\u00e3o alteram o comportamento do programa. Os programas abaixo s\u00e3o todos iguais: <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main() {\n    cout &lt;&lt; \"Hello World!\" &lt;&lt; endl;\n}\n</code></pre></p>"},{"location":"C%2B%2B/1_introducao/#include-iostream-using-namespace-std-int-main-cout-hello-world-endl","title":"<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main() {cout &lt;&lt; \"Hello World!\" &lt;&lt; endl;}\n</code></pre>","text":"<pre><code>#include &lt;iostream&gt;\n\nusing namespace std; int main() {cout &lt;&lt; \"Hello World!\" &lt;&lt; endl;}\n</code></pre> <p>Note que a diretiva #include precisa de uma linha exclusiva, ela \u00e9 uma excess\u00e3o.</p>"},{"location":"C%2B%2B/1_introducao/#g","title":"g++","text":"<p>O g++ \u00e9 um dos compiladores de C++ mais utilizados. Seu uso b\u00e1sico no terminal ser\u00e1 observado para o arquivo \"hello-world.cpp\".</p> <p>Um programa pode ser compilado atrav\u00e9s do seguinte comando: <pre><code>g++ hello-world.cpp\n</code></pre></p> <p>Um execut\u00e1vel de nome a.exe(Windows) ou a.out(Linux e MacOS) em linguagem de m\u00e1quina ser\u00e1 criado na mesma pasta. Ele pode ser executado com os comandos:</p> <p>Windows: <pre><code>a.exe\n</code></pre></p> <p>Linux e MacOS: <pre><code>./a.out\n</code></pre></p> <p>Tamb\u00e9m \u00e9 poss\u00edvel especificar um nome personalizado para o execut\u00e1vel, basta utilizar a op\u00e7\u00e3o -o do compilador. <pre><code>g++ hello-world.cpp -o nome-personalizado.exe\n</code></pre></p> <p>Um execut\u00e1vel com o nome \"nome-personalizado.exe\" ser\u00e1 criado.</p>"},{"location":"C%2B%2B/1_introducao/#erros-de-compilacao","title":"Erros de compila\u00e7\u00e3o","text":"<p>Caso haja algum erro na sintaxe do c\u00f3digo, isto \u00e9, se o c\u00f3digo escrito pelo programador n\u00e3o est\u00e1 de acordo com as regras da linguagem, a compila\u00e7\u00e3o falhar\u00e1 e ser\u00e1 exibido um erro de compila\u00e7\u00e3o. Segue um exemplo: <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;  \n\nint main() {\n    cout &lt;&lt; \"Hello World!\" &lt;&lt; endl\n}\n</code></pre></p>"},{"location":"C%2B%2B/1_introducao/#mhjmbsmhjmbs-ubuntucodesexamples-g-hello-worldcpp-hello-worldcpp-in-function-int-main-hello-worldcpp635-error-expected-before-token-6-cout-hello-world-endl-7","title":"<pre><code>mhjmbs@mhjmbs-ubuntu:~/Codes/examples$ g++ hello-world.cpp \nhello-world.cpp: In function \u2018int main()\u2019:\nhello-world.cpp:6:35: error: expected \u2018;\u2019 before \u2018}\u2019 token\n    6 |     cout &lt;&lt; \"Hello World!\" &lt;&lt; endl\n      |                                   ^\n      |                                   ;\n    7 | }\n      | ~\n</code></pre>","text":"<p>O erro demonstra que na linha 6, na posi\u00e7\u00e3o 35, da esquerda para a direita, est\u00e1 faltando um <code>;</code> .</p>"},{"location":"C%2B%2B/1_introducao/#comentarios","title":"Coment\u00e1rios","text":"<p>Coment\u00e1rios s\u00e3o ignorados pelo compilador e podem servir para diferentes prop\u00f3sitos dentro de um c\u00f3digo. Dentre eles, est\u00e3o - Auxiliar na compreens\u00e3o do c\u00f3digo por um leitor terceiro. - Rapidamente remover parte do c\u00f3digo para fins de debugging</p> <pre><code>//Isso \u00e9 um coment\u00e1rio de uma linha\n\n/*\nIsso \u00e9\num coment\u00e1rio\nde m\u00faltiplas linhas\n*/\n</code></pre>"},{"location":"C%2B%2B/2_variaveis_e_tipos_de_dados/","title":"Vari\u00e1veis e Tipos de Dados","text":"<p>Armazenamento de informa\u00e7\u00f5es para uso do programa.</p>"},{"location":"C%2B%2B/2_variaveis_e_tipos_de_dados/#memoria","title":"Mem\u00f3ria","text":"<p>A mem\u00f3ria do computador \u00e9 uma sequ\u00eancia de bilh\u00f5es de espa\u00e7os para guardar informa\u00e7\u00e3o, cada um, necessariamente, preenchido ou com 0 ou com 1. N\u00fameros, palavras e at\u00e9 imagens podem ser armazenados apenas com sequ\u00eancias de 0's e 1's. Um valor bin\u00e1rio(0 ou 1) da mem\u00f3ria \u00e9 chamado de bit e 8 bits formam um byte.</p> Nome S\u00edmbolo Tamanho Bit b 1 bit Byte B 8b KiloByte KB 1024B MegaByte MB 1024KB GigaByte GB 1024MB TeraByte TB 1024GB <p>Uma das capacidades mais fundamentais de um programa \u00e9 reservar um espa\u00e7o da mem\u00f3ria para o programa usar.</p>"},{"location":"C%2B%2B/2_variaveis_e_tipos_de_dados/#variaveis","title":"Vari\u00e1veis","text":"<p>Uma vari\u00e1vel \u00e9 um espa\u00e7o de mem\u00f3ria que seu programa reserva e nomeia para uso. </p> <p>Em algumas linguagens, n\u00e3o \u00e9 preciso especificar o tipo de informa\u00e7\u00e3o que ser\u00e1 armazenada na vari\u00e1vel(n\u00famero, caractere, etc...). Por\u00e9m, o C++ \u00e9 uma linguagem fortemente tipada, isto \u00e9, os tipos das informa\u00e7\u00f5es armazenadas nas vari\u00e1veis deve ser conhecido em tempo de compila\u00e7\u00e3o.</p> <p>Portanto, uma vari\u00e1vel em C++ sempre tem um tipo, um nome e um valor.</p> <p>Criar uma vari\u00e1vel \u00e9 chamado de declarar uma vari\u00e1vel, e pode ser feito com um comando da forma <pre><code>&lt;tipo&gt; &lt;nome&gt; = &lt;valor&gt;;\n</code></pre></p> <p>Para armazenar o n\u00famero de estados brasileiros, por exemplo, pode-se escrever: <pre><code>int estados_brasileiros = 26;\n</code></pre></p> <p>Acima, declaramos uma vari\u00e1vel do tipo <code>int</code>, que armazena n\u00fameros inteiros, cujo nome \u00e9 \"estados_brasileiros\" e atribu\u00edmos um valor inicial de 26 a ela.</p> <p>Note que em momento algum temos de lidar com valores bin\u00e1rios. Os nomes e valores s\u00e3o todos traduzidos para linguagem de m\u00e1quina no momento da compila\u00e7\u00e3o. Essa \u00e9 a raz\u00e3o de exist\u00eancia das linguagens de programa\u00e7\u00e3o.</p> <p>Podemos, tamb\u00e9m, declarar m\u00faltiplas vari\u00e1veis do mesmo tipo. Seus nomes devem ser separados por v\u00edrgula, como abaixo:  <pre><code>int num1 = 1, num2 = 34, num3 = -50;\n</code></pre></p> <pre><code>int num1 = 1;\nint num2 = 34;\nint num3 = -50;\n</code></pre> <p>Os c\u00f3digos acima tem o mesmo efeito.</p>"},{"location":"C%2B%2B/2_variaveis_e_tipos_de_dados/#inicializacao","title":"Inicializa\u00e7\u00e3o","text":"<p>A inicializa\u00e7\u00e3o de uma vari\u00e1vel \u00e9 o armazenamento de um valor nela no momento de sua cria\u00e7\u00e3o.</p> <p>\u00c9 poss\u00edvel declarar uma vari\u00e1vel e n\u00e3o inicializ\u00e1-la: <pre><code>int estados_brasileiros;\n</code></pre></p> <p>Por\u00e9m, uma vari\u00e1vel sempre cont\u00e9m um valor. O valor armazenado na vari\u00e1vel, nesse caso, \u00e9 o valor que estava naquele espa\u00e7o da mem\u00f3ria antes de sua declara\u00e7\u00e3o. Esse valor pode ser diferente a cada execu\u00e7\u00e3o do programa, j\u00e1 que nem sempre o mesmo espa\u00e7o de mem\u00f3ria \u00e9 reservado.</p> <pre><code>int lixo;\ncout &lt;&lt; lixo &lt;&lt; endl;\n//pode imprimir valores diferentes a cada execu\u00e7\u00e3o\n</code></pre> <p>A valores obtidos dessa maneira damos o nome de lixo. Bugs cuja a causa s\u00e3o vari\u00e1veis n\u00e3o inicializadas podem ser dif\u00edceis de encontrar, deixar vari\u00e1veis n\u00e3o inicializadas \u00e9 uma m\u00e1 pr\u00e1tica de programa\u00e7\u00e3o.</p>"},{"location":"C%2B%2B/2_variaveis_e_tipos_de_dados/#nomes-de-variaveis","title":"Nomes de Vari\u00e1veis","text":"<p>Existem algumas restri\u00e7\u00f5es quanto a nomenclatura de vari\u00e1veis. Nomes de vari\u00e1veis: - devem conter apenas letras, n\u00fameros e <code>_</code>. - n\u00e3o podem come\u00e7ar com um n\u00famero. - n\u00e3o podem ser palavras reservadas da linguagem, como <code>if</code>, por exemplo.</p> <p>Duas vari\u00e1veis n\u00e3o podem ter o mesmo nome dentro do mesmo escopo. Por enquanto, o escopo \u00e9 tudo o que est\u00e1 dentro da <code>main</code>. Al\u00e9m disso, letras mai\u00fasculas e min\u00fasculas identificam vari\u00e1veis \u00fanicas, isto \u00e9, a vari\u00e1vel minha_variavel \u00e9 diferente da vari\u00e1vel Minha_variavel.</p> <p>Por conven\u00e7\u00e3o, nomes de vari\u00e1veis com mais de uma palavra s\u00e3o nomeadas, por todo o programa, com uma de duas formas: - snake_case: letras min\u00fasculas com palavras separadas por _ - camelCase: letras mai\u00fasculas no in\u00edcio de cada palavra exceto a primeira <pre><code>int snake_case;\nint camelCase;\n</code></pre></p>"},{"location":"C%2B%2B/2_variaveis_e_tipos_de_dados/#tipos-de-dados","title":"Tipos de dados","text":"<p>O tipo de uma vari\u00e1vel determina: - Quanta mem\u00f3ria \u00e9 reservada para a vari\u00e1vel - Quais opera\u00e7\u00f5es podem ser realizadas na vari\u00e1vel(soma, concatena\u00e7\u00e3o, etc...)</p> <p>Seguem os tipos de dados mais simples do C++, os tipos primitivos.</p>"},{"location":"C%2B%2B/2_variaveis_e_tipos_de_dados/#int","title":"<code>int</code>","text":"<p>O tipo <code>int</code> serve para o armazenamento de n\u00fameros inteiros. Segue alguns exemplos de declara\u00e7\u00f5es de int's. <pre><code>int x = 2;\nint y = 3, z = -10;\nint numero = 1000000;\n</code></pre></p>"},{"location":"C%2B%2B/2_variaveis_e_tipos_de_dados/#float-e-double","title":"<code>float</code> e <code>double</code>","text":"<p>Os tipos <code>float</code> e <code>double</code> servem para o armazenamento de n\u00fameros decimais. Segue alguns exemplos de declara\u00e7\u00f5es de float's e double's. <pre><code>float pi = 3.14;\ndouble altura = 1.7012345;\ndouble planetas = -8;\nfloat distancia = 2e9; //podem ser declarados em nota\u00e7\u00e3o cient\u00edfica\n</code></pre></p>"},{"location":"C%2B%2B/2_variaveis_e_tipos_de_dados/#char","title":"<code>char</code>","text":"<p>O tipo <code>char</code> serve para o armazenamento de caracteres. Segue alguns exemplos de declara\u00e7\u00f5es de char's. <pre><code>char c = 'a';\nchar caractere = 'c';\nchar quebra_de_linha = '\\n'; //caractere de quebra de linha\n</code></pre></p> <p>Note que caracteres s\u00e3o escritos entre aspas simples <code>**' '**</code>.</p> <p>Internamente, o tipo <code>char</code> \u00e9 armazenado similar a um <code>int</code>. Na pr\u00e1tica, um <code>char</code> \u00e9 um <code>int</code> que tem um s\u00edmbolo associado ao ser lido e escrito. Qual inteiro \u00e9 associado a qual caractere \u00e9 determinado pela tabela ASCII.</p> <p>Esse comportamento, dentre outras coisas, permite que se inicialize caracteres de acordo com seus respectivos n\u00fameros. <pre><code>char a = 65; //'A' na tabela ASCII\n</code></pre></p>"},{"location":"C%2B%2B/2_variaveis_e_tipos_de_dados/#bool","title":"<code>bool</code>","text":"<p>O tipo <code>bool</code> armazena um estado que pode ser <code>true</code>(verdadeiro) ou <code>false</code>(falso). <pre><code>bool b1 = true;\nbool b2 = false;\n</code></pre></p>"},{"location":"C%2B%2B/2_variaveis_e_tipos_de_dados/#void","title":"<code>void</code>","text":"<p>O tipo <code>void</code> indica a aus\u00eancia de tipo. Ele ser\u00e1 \u00fatil apenas na se\u00e7\u00e3o de fun\u00e7\u00f5es.</p>"},{"location":"C%2B%2B/2_variaveis_e_tipos_de_dados/#modificadores-de-sinal","title":"Modificadores de sinal","text":"<p>Os modificadores <code>signed</code> e <code>unsigned</code> se aplicam aos tipos <code>int</code> e <code>char</code> e servem para tirar ou manter o sinal dos n\u00fameros.</p> <p>Sua fun\u00e7\u00e3o \u00e9 estender um pouco o intervalo de n\u00fameros que pode ser armazenado por um tipo ao retirar a necessidade de armazenar um bit de sinal. Por\u00e9m, pode causar resultados inesperados com uso descuidado.</p> <p>Por padr\u00e3o, o modificador signed \u00e9 usado na omiss\u00e3o de modificador de sinal. <pre><code>signed int i = -2;\nunsigned int ui = 10;\nunsigned char c = 'a';\nunsigned char uc = '2';\n\nunsigned int cuidado = -10; // armazena 4294967286\n</code></pre></p>"},{"location":"C%2B%2B/2_variaveis_e_tipos_de_dados/#modificadores-de-tamanho","title":"Modificadores de tamanho","text":"<p>Como a mem\u00f3ria do computador n\u00e3o \u00e9 infinita, o espa\u00e7o reservado para guardar cada vari\u00e1vel tamb\u00e9m n\u00e3o \u00e9 infinito. Consequentemente, os tipos <code>int</code>, <code>double</code>, <code>char</code> e qualquer outro tipo que represente valores num\u00e9ricos n\u00e3o pode representar n\u00fameros infinitamente grandes, uma vez que n\u00e3o h\u00e1 espa\u00e7o para guardar infinitos d\u00edgitos.</p> <p>Afim de n\u00e3o usar mem\u00f3ria demais, mas tamb\u00e9m n\u00e3o impossibilitar a representa\u00e7\u00e3o de n\u00fameros maiores, foram criados modificadores para os tipos <code>int</code> e <code>char</code>, que modificam a quantidade de mem\u00f3ria reservada. Para n\u00fameros decimais, o tipo <code>double</code> foi criado com o mesmo prop\u00f3sito.</p> <p>Modificadores de tamanho do <code>int</code> podem ser omitidos: <pre><code>short x = 3; // mesmo que short int\nunsigned long long = 4; // mesmo que unsigned long long int\n</code></pre></p> <p>Segue uma tabela com os tipos primitivos e modificadores mais comuns, seus tamanhos e n\u00fameros que podem representar. Uma tabela completa pode ser encontrada aqui.</p> Tipo Tamanho em bits Intervalo(Aproximado) Intervalo(Exato) <code>char</code> 8 -128 to 127 <code>short int</code> 16 \u00b1 3 \u00d7 10\u2074 -32768 to 32767 <code>int</code> 32 \u00b1 2 \u00d7 10\u2079 -2,147,483,648 to 2,147,483,647 <code>long long int</code> 64 \u00b1 9 \u00d7 10\u00b9\u2078 -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 <code>double</code> 64 \u00b1 1.7 \u00d7 10\u207b\u00b3\u2070\u2078"},{"location":"C%2B%2B/2_variaveis_e_tipos_de_dados/#modificadores-de-mutabilidade","title":"Modificadores de mutabilidade","text":"<p>Toda vari\u00e1vel pode ter o modificador <code>const</code>, que impede que ela seja modificada no futuro. Naturalmente, vari\u00e1veis <code>const</code> necessariamente devem ser inicializadas. <pre><code>const int x = 3;\nconst char y; //erro de compila\u00e7\u00e3o\n</code></pre></p>"},{"location":"C%2B%2B/2_variaveis_e_tipos_de_dados/#string","title":"<code>string</code>","text":"<p>O tipo <code>string</code> \u00e9 o tipo do C++ dedicado ao tratamento de cadeias de caracteres. Ele j\u00e1 n\u00e3o \u00e9 um tipo primitivo, mas \u00e9 constru\u00eddo em cima do tipo <code>char</code>. Seguem exemplos de declara\u00e7\u00f5es de strings: <pre><code>string nome = \"Marcos\";\nstring vazio = \"\";\nstring louco = \"AA\\nBB\";\n</code></pre></p> <p>Note que o conte\u00fado de strings sempre est\u00e3o entre aspas duplas <code>\" \"</code>.</p> <p>O tamanho de uma <code>string</code> pode ser obtido com o comando <code>.size()</code>. <pre><code>string nome = \"Marcos\";\ncout &lt;&lt; nome.size() &lt;&lt; '\\n'; //Imprime 6 no terminal\n</code></pre></p> <p>Os caracteres de uma string s\u00e3o numerados, da esquerda para a direita, de 0 at\u00e9 <code>string.size()-1</code>. Pode-se acessar um caractere espec\u00edfico com colchetes <code>[]</code> indicando a posi\u00e7\u00e3o do caractere desejado. <pre><code>string nome = \"Marcos\";\ncout &lt;&lt; nome[2] &lt;&lt; '\\n'; //imprime 'r' no terminal\n</code></pre></p>"},{"location":"C%2B%2B/2_variaveis_e_tipos_de_dados/#literais","title":"Literais","text":"<p>Note que em diversos momentos escreve-se valores no c\u00f3digo. Esses valores recebem o nome de literais. <pre><code>short si = 1s; //literal de short\nint i = 2; //literal de int\nlong l = 3l; //literal de long\nlong long ll = 4ll; //literal de long long\nfloat f = 5f; //literal de float\ndouble d = 6.0; //literal de double\nchar c = 'b'; //literal de char\nstring s = \"Bla\"; //literal de string\n</code></pre></p> <p>Caso uma vari\u00e1vel seja inicializada com o literal de um tipo diferente, o compilador tentar\u00e1 converter de um tipo para outro. Tipos num\u00e9ricos podem ser convertidos entre si. <pre><code>int a = 1ll;\nint b = 1.4;\nint c = 'A'; //65\nint d = \"1.56\"; //ERRO DE COMPILA\u00c7\u00c3O\n</code></pre></p>"},{"location":"C%2B%2B/2_variaveis_e_tipos_de_dados/#conversoes-de-tipos","title":"Convers\u00f5es de tipos","text":"<p>Existem dois tipos de convers\u00f5es de tipos, expl\u00edcitas e impl\u00edcitas.</p>"},{"location":"C%2B%2B/2_variaveis_e_tipos_de_dados/#conversoes-implicitas","title":"Convers\u00f5es impl\u00edcitas","text":"<p>Convers\u00f5es impl\u00edcitas ocorrem na presen\u00e7a de um tipo onde deveria haver outro. O compilador converte o tipo para o adequado automaticamente. <pre><code>int x = 6.4;\n</code></pre></p> <p>Convers\u00f5es entre os tipos inteiros(<code>char</code>, <code>int</code> e seus modificadores) funcionam bem desde que o valor esteja dentro do limite que o novo tipo consegue armazenar.</p> <p>Convers\u00f5es de tipos inteiros para tipos decimais(<code>float</code> e <code>double</code>) sempre funcionam.</p> <p>Convers\u00f5es de tipos decimais para tipos inteiros podem perder informa\u00e7\u00e3o. <pre><code>int x = 6.4;\ncout &lt;&lt; x &lt;&lt; '\\n'; //Escreve 6 no terminal\n</code></pre> Os d\u00edgitos ap\u00f3s a v\u00edrgula s\u00e3o truncados.</p> <p>Convers\u00f5es de outros tipos para <code>bool</code> s\u00e3o <code>false</code> apenas se o valor for o valor nulo daquele tipo. <pre><code>bool int_to_bool = 0; //false\nbool char_to_bool = '\\0'; //false\nbool double_to_bool = 0.0; //false\n</code></pre></p>"},{"location":"C%2B%2B/2_variaveis_e_tipos_de_dados/#conversoes-explicitas","title":"Convers\u00f5es expl\u00edcitas","text":"<p>Convers\u00f5es expl\u00edcitas s\u00e3o convers\u00f5es solicitadas pelo programa explicitamente. <pre><code>int x = char(6.4);\ncout &lt;&lt; x &lt;&lt; '\\n'; //Escreve 6 no terminal\n</code></pre></p> <p>Para converter entre tipos primitivos, basta o comando: <pre><code>&lt;novo_tipo&gt;(valor)\n</code></pre></p> <p>J\u00e1 para converter tipos primitivos para strings, a fun\u00e7\u00e3o <code>to_string()</code> \u00e9 utilizada: <pre><code>double pi = 3.14;\nstring s_pi = to_string(3.14);\ncout &lt;&lt; s_pi[2] &lt;&lt; '\\n'; //imprime 4 no terminal\n</code></pre></p> <p>Para converter de <code>string</code> a tipos primitivos, uma vez que a string \u00e9 compat\u00edvel com o tipo a ser convertido, utiliza-se: <pre><code>int i = stoi(\"4\"); //string -&gt; int\nlong l = stol(\"5\"); //string -&gt; long\nlong long ll = stoll(\"1000000000000\"); //string -&gt; long long\nfloat f = stof(\"3.14\"); //string -&gt; float\ndouble d = stod(\"4.6565323\"); //string -&gt; double\n</code></pre></p> <p>Outras fun\u00e7\u00f5es de convers\u00f5es num\u00e9ricas de string menos comuns podem ser encontradas na documenta\u00e7\u00e3o de strings do C++.</p> <p>A convers\u00e3o de caracteres para <code>int</code> e vice-versa \u00e9 feita de acordo com o caractere na tabela ASCII. Mas isso pode n\u00e3o ser o desejado. <pre><code>char c = '3';\nint x = c; //51, o valor de '3' na tabela ASCII, mas pode-se desejar x = 3\n</code></pre></p> <p>Para obter o valor desejado, pode-se operar com os valores da tabela ASCII da seguinte maneira: <pre><code>char c = '3';\nint x = c - '0'; //51 - 48 = 3\n\nint i = 1;\nchar l = 'a' + i; //b, a segunda letra do alfabeto\n\nint k = 8;\nchar d = '0' + k; //'8', o caractere do digito k\n</code></pre></p>"},{"location":"C%2B%2B/3_entrada_e_saida/","title":"Entrada e Sa\u00edda","text":"<p>Troca de informa\u00e7\u00f5es entre programa e usu\u00e1rio.</p>"},{"location":"C%2B%2B/3_entrada_e_saida/#troca-de-dados","title":"Troca de dados","text":"<p>Programas podem permitir que usu\u00e1rios insiram informa\u00e7\u00f5es, como nome de usu\u00e1rio, senha e cliques. Al\u00e9m disso, programas podem exibir informa\u00e7\u00f5es, como sons, imagens e v\u00eddeos.</p> <p>S\u00e3o chamadas de</p> <ul> <li>Entrada: informa\u00e7\u00f5es que o usu\u00e1rio fornece ao programa.</li> <li>Sa\u00edda: informa\u00e7\u00f5es que o programa fornece ao usu\u00e1rio.</li> </ul>"},{"location":"C%2B%2B/3_entrada_e_saida/#entrada-e-saida-padrao","title":"Entrada e sa\u00edda padr\u00e3o","text":"<p>A entrada e sa\u00edda padr\u00e3o de um programa em C++ s\u00e3o, respectivamente, o arquivo de onde o programa obt\u00e9m entradas e o arquivo onde o programa escreve suas sa\u00eddas por padr\u00e3o. S\u00e3o eles o stdin e o stdout.</p> <p>Ambos est\u00e3o, por padr\u00e3o, associados ao terminal onde o programa for executado, isto \u00e9: o que for escrito no terminal \u00e9 escrito na entrada padr\u00e3o, e o que for escrito na sa\u00edda padr\u00e3o pode ser escrito no terminal e exibido ao usu\u00e1rio.</p>"},{"location":"C%2B%2B/3_entrada_e_saida/#entrada","title":"Entrada","text":"<p>O comando <code>cin</code> solicita uma escrita na entrada padr\u00e3o e o direciona para uma vari\u00e1vel atrav\u00e9s do operador <code>&gt;&gt;</code>. <pre><code>int numero;\ncin &gt;&gt; numero; // o que for lido da entrada padr\u00e3o \u00e9 armazenado em numero\n</code></pre></p> <p>O <code>cin</code> interpreta que espa\u00e7os em branco, isto \u00e9, quebras de linha e espa\u00e7os, separam duas entradas diferentes. Portanto, entradas lidas com o <code>cin</code> n\u00e3o devem conter espa\u00e7os, pois ser\u00e3o interpretadas como duas entradas diferentes.</p> <p>Para cada vari\u00e1vel lida pelo <code>cin</code>: 1. ser\u00e1 checado se h\u00e1 conte\u00fado em <code>stdin</code>.     1. se n\u00e3o houver, realiza uma leitura no terminal e escreve em <code>stdin</code>. 2. remove a primeira entrada de stdin e a armazena na vari\u00e1vel.</p> <p>Pode-se encadear <code>&gt;&gt;</code>'s para a obten\u00e7\u00e3o de diversas entradas. Os dois c\u00f3digos a seguir funcionam de maneira id\u00eantica.</p>"},{"location":"C%2B%2B/3_entrada_e_saida/#int-num1-num2-num3-cin-num1-num2-num3","title":"<pre><code>int num1, num2, num3;\ncin &gt;&gt; num1 &gt;&gt; num2 &gt;&gt; num3;\n</code></pre>","text":"<pre><code>int num1, num2, num3;\ncin &gt;&gt; num1;\ncin &gt;&gt; num2;\ncin &gt;&gt; num3;\n</code></pre> <p>Caso o <code>cin</code> tente armazenar uma valor em uma vari\u00e1vel de tipo incompat\u00edvel, ele entra em um estado de erro e quaisquer leituras dali em diante ser\u00e3o ignoradas.</p>"},{"location":"C%2B%2B/3_entrada_e_saida/#saida","title":"Sa\u00edda","text":"<p>O comando <code>**cout**</code> escreve na sa\u00edda padr\u00e3o e recebe valores atrav\u00e9s do operador <code>&lt;&lt;</code>: <pre><code>cout &lt;&lt; \"Hello World!\";\n</code></pre></p> <p>Tamb\u00e9m \u00e9 poss\u00edvel escrever o valor de vari\u00e1veis. <pre><code>int x = 5;\ncout &lt;&lt; x; //escreve 5 em stdout\n</code></pre></p> <p>Pode-se encadear <code>&lt;&lt;</code>'s para escrever diversas sa\u00eddas. Os comandos a seguir funcionam de maneira id\u00eantica.</p>"},{"location":"C%2B%2B/3_entrada_e_saida/#int-x-45-cout-hello-x-world","title":"<pre><code>int x = 45;\ncout &lt;&lt; \"Hello \" &lt;&lt; x &lt;&lt; \" World!\";\n</code></pre>","text":"<pre><code>int x = 45;\ncout &lt;&lt; \"Hello \";\ncout &lt;&lt; x;\ncout &lt;&lt; \" World!\";\n</code></pre>"},{"location":"C%2B%2B/3_entrada_e_saida/#quebras-de-linha","title":"Quebras de linha","text":"<p>Quebras de linha podem ser atingidas de duas maneiras: o caractere <code>\\n</code> e o manipulador <code>endl</code>. Os comandos abaixo escrevem o mesmo conte\u00fado \u00e0 sa\u00edda padr\u00e3o: <pre><code>cout &lt;&lt; \"Hello World!\\n\";\ncout &lt;&lt; \"Hello World!\" &lt;&lt; endl;\n</code></pre></p> <p>A diferen\u00e7a entre os dois m\u00e9todos \u00e9 significativa e est\u00e1 em um processo que chamamos de flush.</p> <p>O <code>cout</code> escreve as informa\u00e7\u00f5es na sa\u00edda padr\u00e3o, isto \u00e9, no arquivo <code>stdin</code>. A escrita das informa\u00e7\u00f5es que est\u00e3o em <code>stdin</code> para o terminal \u00e9 o que chamamos de flush.</p> <p>O caractere <code>\\n</code> apenas escreve uma quebra de linha no <code>stdin</code>. J\u00e1 o <code>endl</code>, al\u00e9m de escrever a quebra de linha, realiza um flush.</p> <p>O processo de flush \u00e9 bem lento e deve ser realizado apenas quando necess\u00e1rio. Ele \u00e9 realizado quando:</p> <ul> <li>um <code>endl</code> \u00e9 passado ao <code>cout</code>.</li> <li>o programa finaliza.</li> <li>um <code>cin</code> est\u00e1 prestes a realizar uma leitura.</li> <li>Outras maneiras de invocar um flush explicitamente s\u00e3o utilizadas.</li> </ul>"},{"location":"C%2B%2B/3_entrada_e_saida/#precisao-de-numeros-decimais","title":"Precis\u00e3o de n\u00fameros decimais","text":"<p>Pode-se decidir o n\u00famero de casas decimais de um n\u00famero a ser impressa com os seguintes manipuladores: <pre><code>cout &lt;&lt; fixed &lt;&lt; setprecision(5) &lt;&lt; 3.14 &lt;&lt; '\\n'; //imprime 3.14000 no terminal\n</code></pre></p>"},{"location":"C%2B%2B/4_operadores/","title":"Operadores","text":"<p>Introdu\u00e7\u00e3o ao uso de operadores e operadores aritm\u00e9ticos.</p>"},{"location":"C%2B%2B/4_operadores/#operacoes","title":"Opera\u00e7\u00f5es","text":"<p>Uma vez que sabe-se guardar informa\u00e7\u00f5es para o programa, tornam-se relevantes as opera\u00e7\u00f5es que podem ser realizadas sobre elas.</p> <p>Um s\u00edmbolo que representa uma opera\u00e7\u00e3o em um c\u00f3digo recebe o nome de operador.</p>"},{"location":"C%2B%2B/4_operadores/#operadores-aritmeticos","title":"Operadores Aritm\u00e9ticos","text":"<p>Operadores aritm\u00e9ticos realizam opera\u00e7\u00f5es aritm\u00e9ticas entre tipos num\u00e9ricos. S\u00e3o eles</p> Operador Descri\u00e7\u00e3o Exemplo <code>+</code> Adi\u00e7\u00e3o <code>a + b</code> <code>-</code> Subtra\u00e7\u00e3o <code>a - b</code> <code>*</code> Multiplica\u00e7\u00e3o <code>a * b</code> <code>/</code> Divis\u00e3o <code>a / b</code> <code>%</code> M\u00f3dulo (resto) <code>a % b</code> <code>++</code> Incremento <code>a++</code> ou <code>++a</code> <code>--</code> Decremento <code>a--</code> ou <code>--a</code> <p>Seguem alguns exemplos de uso</p>"},{"location":"C%2B%2B/4_operadores/#cout-54-n-imprime-9-no-terminal","title":"<pre><code>cout &lt;&lt; 5+4 &lt;&lt; '\\n'; //imprime 9 no terminal\n</code></pre>","text":""},{"location":"C%2B%2B/4_operadores/#int-x-52-y-10-cout-x4y-n-imprime-41-no-terminal","title":"<pre><code>int x = 5%2, y = 10;\ncout &lt;&lt; x+4*y &lt;&lt; '\\n'; //imprime 41 no terminal\n</code></pre>","text":""},{"location":"C%2B%2B/4_operadores/#cout-92-n-imprime-4-no-terminal-cout-902-n-imprime-45-no-terminal","title":"<pre><code>cout &lt;&lt; 9/2 &lt;&lt; '\\n'; //imprime 4 no terminal\ncout &lt;&lt; 9.0/2 &lt;&lt; '\\n'; //imprime 4.5 no terminal\n</code></pre>","text":""},{"location":"C%2B%2B/4_operadores/#int-x-5-y-5-cout-x-y-n-imprime-5-e-6-no-terminal-cout-x-y-n-imprime-6-e-6-no-terminal","title":"<pre><code>int x = 5, y = 5;\ncout &lt;&lt; x++ &lt;&lt; ' ' &lt;&lt; ++y &lt;&lt; '\\n'; //imprime 5 e 6 no terminal\ncout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; '\\n'; //imprime 6 e 6 no terminal\n</code></pre>","text":"<p>A divis\u00e3o entre inteiros sempre dar\u00e1 um resultado inteiro, desconsiderando o resto da divis\u00e3o.</p> <p>O operador m\u00f3dulo retorna o resto da divis\u00e3o de um n\u00famero pelo outro.</p> <p>Os operadores de incremento e decremento modificam o valor da vari\u00e1vel em 1 e podem vir antes ou depois da vari\u00e1vel a ser modificada. A diferen\u00e7a est\u00e1 no momento em que o incremento \u00e9 realizado. Caso o operador venha depois da vari\u00e1vel, \u00e9 como se ele fosse aplicado apenas ap\u00f3s a linha toda ser executada.</p>"},{"location":"C%2B%2B/4_operadores/#operacoes-em-tipos-diferentes","title":"Opera\u00e7\u00f5es em Tipos Diferentes","text":"<p>Sempre que uma opera\u00e7\u00e3o for realizada entre dois tipos primitivos diferentes, o compilador tentar\u00e1 converter o tipo mais \"simples\" para o tipo mais \"complexo\" para realizar a opera\u00e7\u00e3o <pre><code>4.5/3 // converte 3 para 3.0 e divide\n'A' + 4 // converte 'A' para 65 e soma\n</code></pre></p> <p>Os tipos, do mais simples para o mais complexo, s\u00e3o: <code>bool</code> -&gt;<code>char</code> -&gt; <code>int</code> -&gt; <code>double</code>.</p>"},{"location":"C%2B%2B/4_operadores/#operadores-de-atribuicao","title":"Operadores de Atribui\u00e7\u00e3o","text":"<p>O operador de atribui\u00e7\u00e3o <code>=</code> serve para alterar o valor de uma vari\u00e1vel ap\u00f3s sua cria\u00e7\u00e3o. <pre><code>int x = 10;\nx = 18;\nx = 9;\ncout &lt;&lt; x &lt;&lt; '\\n'; //imprime 9 no terminal\n</code></pre> Pode-se compor o operador de atribui\u00e7\u00e3o com os operadores aritm\u00e9ticos. Os c\u00f3digos abaixo funcionam de maneira id\u00eantica. <pre><code>int x = 5;\nx += 1; // x vira 6\nx -= 2; // x vira 4\nx *= 2; // x vira 8\nx /= 2; // x vira 4\nx %= 2; // x vira 0\n</code></pre></p> <pre><code>int x = 5;\nx = x + 1; // x vira 6\nx = x - 2; // x vira 4\nx = x * 2; // x vira 8\nx = x / 2; // x vira 4\nx = x % 2; // x vira 0\n</code></pre>"},{"location":"C%2B%2B/4_operadores/#precedencia-e-associatividade","title":"Preced\u00eancia e Associatividade","text":"<p>Se m\u00faltiplos operadores fazem parte de uma mesma express\u00e3o, a ordem em que as opera\u00e7\u00f5es s\u00e3o feitas pode alterar seu resultado.</p> <p>A preced\u00eancia \u00e9 o n\u00edvel de prioridade da opera\u00e7\u00e3o em uma linguagem de programa\u00e7\u00e3o. Operadores de maior preced\u00eancia s\u00e3o executados primeiro em uma express\u00e3o.</p> <p>A associatividade \u00e9 a ordem em que operadores de mesma preced\u00eancia s\u00e3o executados, podendo ser da esquerda para direita ou da direita para esquerda.</p> <p>No caso dos operadores aritm\u00e9ticos, a ordem de preced\u00eancia das opera\u00e7\u00f5es \u00e9 a mesma da matem\u00e1tica: multiplica\u00e7\u00f5es, divis\u00f5es e opera\u00e7\u00f5es de resto -&gt; somas e subtra\u00e7\u00f5es.</p> <p>Uma tabela completa da preced\u00eancia de operadores pode ser encontrada aqui.</p> <p>\u00c9 poss\u00edvel alterar a ordem de execu\u00e7\u00e3o das opera\u00e7\u00f5es ao envolv\u00ea-las em <code>()</code>: <pre><code>cout &lt;&lt; 2*5+11/4 &lt;&lt; '\\n'; // 12\ncout &lt;&lt; 2*((5+11)/4) &lt;&lt; '\\n'; // 8\n</code></pre></p>"},{"location":"C%2B%2B/5_operadores_relacionais/","title":"Operadores Relacionais","text":"<p>Operadores para a compara\u00e7\u00e3o de informa\u00e7\u00f5es</p>"},{"location":"C%2B%2B/5_operadores_relacionais/#comparacoes","title":"Compara\u00e7\u00f5es","text":"<p>Por vezes \u00e9 \u00fatil a compara\u00e7\u00e3o entre duas informa\u00e7\u00f5es armazenadas em um programa, seja para saber se um n\u00famero \u00e9 maior do que outro ou se um caractere vem antes no alfabeto que outro.</p> <p>Os operadores que realizam compara\u00e7\u00f5es embutidos no C++ s\u00e3o chamados de operadores relacionais</p>"},{"location":"C%2B%2B/5_operadores_relacionais/#operadores-relacionais_1","title":"Operadores Relacionais","text":"<p>Operadores relacionais realizam opera\u00e7\u00f5es de compara\u00e7\u00e3o. S\u00e3o eles:</p> Operador Descri\u00e7\u00e3o Exemplo <code>==</code> Igualdade <code>a == b</code> <code>!=</code> Diferen\u00e7a <code>a != b</code> <code>&gt;</code> Maior que <code>a &gt; b</code> <code>&lt;</code> Menor que <code>a &lt; b</code> <code>&gt;=</code> Maior ou igual que <code>a &gt;= b</code> <code>&lt;=</code> Menor ou igual que <code>a &lt;= b</code> <p>Todos retornam um <code>bool</code> com o resultado da compara\u00e7\u00e3o. Seguem alguns exemplos de uso: </p> <p><pre><code>cout &lt;&lt; (1 == 1) &lt;&lt; '\\n'; // 1\ncout &lt;&lt; (1 == 2) &lt;&lt; '\\n'; // 0\ncout &lt;&lt; (1 != 1) &lt;&lt; '\\n'; // 0\ncout &lt;&lt; (1 != 2) &lt;&lt; '\\n'; // 1\n</code></pre> A preced\u00eancia dos operadores relacionais \u00e9 inferior \u00e0 preced\u00eancia do <code>&lt;&lt;</code>. Por isso, \u00e9 necess\u00e1rio estarem entre par\u00eanteses para impress\u00e3o.</p>"},{"location":"C%2B%2B/5_operadores_relacionais/#cout-1-2-n-1-cout-1-2-n-0-cout-1-1-n-0-cout-1-2-n-1-cout-1-2-n-0-cout-1-1-n-1-cout-1-1-n-1","title":"<pre><code>cout &lt;&lt; (1 &lt; 2) &lt;&lt; '\\n'; // 1\ncout &lt;&lt; (1 &gt; 2) &lt;&lt; '\\n'; // 0\ncout &lt;&lt; (1 &lt; 1) &lt;&lt; '\\n'; // 0\ncout &lt;&lt; (1 &lt;= 2) &lt;&lt; '\\n'; // 1\ncout &lt;&lt; (1 &gt;= 2) &lt;&lt; '\\n'; // 0\ncout &lt;&lt; (1 &gt;= 1) &lt;&lt; '\\n'; // 1\ncout &lt;&lt; (1 &lt;= 1) &lt;&lt; '\\n'; // 1\n</code></pre>","text":"<p><pre><code>cout &lt;&lt; (1.0 &lt; 2.0) &lt;&lt; '\\n'; // 1\ncout &lt;&lt; (3.14 &gt; 3.15) &lt;&lt; '\\n'; // 0\n</code></pre> Funcionam com todos os tipos num\u00e9ricos.</p> <p><pre><code>cout &lt;&lt; ('a' &lt; 'z') &lt;&lt; '\\n'; // 1\ncout &lt;&lt; ('b' &lt; 'a') &lt;&lt; '\\n'; // 0\ncout &lt;&lt; ('@' &lt; 'g') &lt;&lt; '\\n'; // 1\n</code></pre> <code>char</code> tamb\u00e9m \u00e9 um tipo num\u00e9rico. A compara\u00e7\u00e3o compara seus respectivos n\u00fameros na tabela ASCII.</p> <p><pre><code>cout &lt;&lt; (1 + 2 &lt; 1 + 1) &lt;&lt; '\\n'; // 0\ncout &lt;&lt; (1.5 + 4.2 &gt; 4.3) &lt;&lt; '\\n'; // 1\n</code></pre>  Operadores aritm\u00e9ticos tem maior preced\u00eancia que operadores relacionais. </p> <p><pre><code>cout &lt;&lt; (1 &lt; 4 &lt; 2) &lt;&lt; '\\n'; // 1\n// 1 &lt; 4 &lt; 2\n// true &lt; 2\n// 1 &lt; 2\n// true\n</code></pre>  Os operadores <code>&gt;</code> e <code>&lt;</code> n\u00e3o funcionam em cadeia como na matem\u00e1tica. Para us\u00e1-los dessa maneira devemos combin\u00e1-los com os operadores l\u00f3gicos.</p>"},{"location":"C%2B%2B/5_operadores_relacionais/#comparacao-entre-floats-e-doubles","title":"Compara\u00e7\u00e3o entre <code>floats</code> e <code>doubles</code>","text":"<p>Devido ao modo como n\u00fameros decimais s\u00e3o armazenados internamente no computador, resultados de opera\u00e7\u00f5es frequentemente perdem precis\u00e3o.</p> <pre><code>cout &lt;&lt; fixed &lt;&lt; setprecision(17) &lt;&lt; 0.3 &lt;&lt; '\\n'; // 0.29999999999999999\ncout &lt;&lt; fixed &lt;&lt; setprecision(17) &lt;&lt; 0.1 + 0.2 &lt;&lt; '\\n'; // 0.30000000000000004\n</code></pre> <p>Por isso, compara\u00e7\u00f5es entre eles n\u00e3o s\u00e3o seguras e podem obter resultados inesperados e n\u00e3o devem ser realizadas. </p> <pre><code>double a = 0.1 + 0.2;\ndouble b = 0.3;\n\ncout &lt;&lt; fixed &lt;&lt; setprecision(17) &lt;&lt; a &lt;&lt; '\\n'; // 0.29999999999999999\ncout &lt;&lt; fixed &lt;&lt; setprecision(17) &lt;&lt; b &lt;&lt; '\\n'; // 0.30000000000000004\n\ncout &lt;&lt; (a == b) &lt;&lt; '\\n'; // 0\ncout &lt;&lt; (a != b) &lt;&lt; '\\n'; // 1\ncout &lt;&lt; (a &lt; b) &lt;&lt; '\\n'; // 0\ncout &lt;&lt; (a &gt; b) &lt;&lt; '\\n'; // 1\n</code></pre>"},{"location":"C%2B%2B/5_operadores_relacionais/#intervalo-de-confianca","title":"Intervalo de confian\u00e7a","text":"<p>Para comparar decimais de forma segura, considera-se um intervalo de confian\u00e7a. Isto \u00e9, se dois n\u00fameros s\u00e3o suficientemente pr\u00f3ximos, considera-se que s\u00e3o iguais. \u00c9 conveniente escolher um n\u00famero bem pequeno.</p> <pre><code>double a = 0.1 + 0.2;\ndouble b = 0.3;\n\ncout &lt;&lt; fixed &lt;&lt; setprecision(17) &lt;&lt; a &lt;&lt; '\\n'; // 0.29999999999999999\ncout &lt;&lt; fixed &lt;&lt; setprecision(17) &lt;&lt; b &lt;&lt; '\\n'; // 0.30000000000000004\n\ndouble eps = 1e-9;\n\ncout &lt;&lt; (abs(a - b) &lt; eps) &lt;&lt; '\\n'; // 1\ncout &lt;&lt; (abs(a-b) &gt; eps) &lt;&lt; '\\n'; // 0\ncout &lt;&lt; (b - a &gt; eps) &lt;&lt; '\\n'; // 0\ncout &lt;&lt; (a - b &gt; eps) &lt;&lt; '\\n'; // 0\n</code></pre> <p><code>abs(x)</code> \u00e9 o valor absoluto de <code>x</code>.</p>"},{"location":"C%2B%2B/5_operadores_relacionais/#operadores-relacionais-e-strings","title":"Operadores relacionais e <code>strings</code>","text":"<p>Os operadores <code>==</code> e <code>!=</code> comparam strings caractere a caractere.</p> <pre><code>cout &lt;&lt; (\"abc\" == \"abc\") &lt;&lt; '\\n'; // 1\ncout &lt;&lt; (\"bca\" == \"abc\") &lt;&lt; '\\n'; // 0\ncout &lt;&lt; (\"abc \" != \"abc\") &lt;&lt; '\\n'; // 1\n</code></pre> <p>Os operadores <code>&gt;</code> e <code>&lt;</code> comparam as string em ordem lexicogr\u00e1fica: uma string <code>a</code> \u00e9 menor que uma string <code>b</code> se no primeiro \u00edndice <code>i</code>em que  <code>a[i] != b[i]</code>, <code>a[i] &lt; b[i]</code>. Caso sejam iguais at\u00e9 o comprimento da menor string, a string de menor tamanho \u00e9 menor(como se, ao final da menor string, fosse adicionado um caractere menor que qualquer outro).</p> <pre><code>string a = \"aaa\";\nstring b = \"aab\";\ncout &lt;&lt; (a &lt; b) &lt;&lt; '\\n'; // 1, a \u00e9 menor que b\n\nstring c = \"baa\";\nstring d = \"acc\";\ncout &lt;&lt; (c &lt; d) &lt;&lt; '\\n'; // 0, b \u00e9 maior que a\n\nstring e = \"abc\";\nstring f = \"abcd\";\n// 1, iguais nos caracteres comparados, mas a primeira string \u00e9 menor\ncout &lt;&lt; (e &lt; f) &lt;&lt; '\\n'; // 1\n\nstring g = \"abc \";\nstring h = \"abc\";\n// 0, iguais nos caracteres comparados, mas a primeira string \u00e9 maior\ncout &lt;&lt; (g &lt; h) &lt;&lt; '\\n'; // 0\n</code></pre>"},{"location":"C%2B%2B/5_operadores_relacionais/#comparacao-entre-literais-de-string","title":"Compara\u00e7\u00e3o entre literais de string","text":"<p>A compara\u00e7\u00e3o entre literais de string \u00e9 comportamento indefinido, isto \u00e9, as regras do C++ n\u00e3o definem o comportamento dessa compara\u00e7\u00e3o. Isso ocorre porque literais de string n\u00e3o s\u00e3o do tipo <code>string</code>, mas sim do tipo <code>const char*</code>. Ela nunca deve ser realizada, apesar de n\u00e3o gerar erro de compila\u00e7\u00e3o.</p> <pre><code>cout &lt;&lt; (\"aaa\" &lt; \"bbb\") &lt;&lt; '\\n'; // undefined behavior\ncout &lt;&lt; (string(\"aaa\") &lt; string(\"bbb\")) &lt;&lt; '\\n'; // 1\ncout &lt;&lt; (string(\"aaa\") &lt; \"bbb\") &lt;&lt; '\\n'; // 1, convers\u00e3o impl\u00edcita para string\n</code></pre>"},{"location":"C%2B%2B/6_operadores_logicos/","title":"Operadores L\u00f3gicos","text":"<p>Operadores para operar sobre <code>bool</code>'s.</p>"},{"location":"C%2B%2B/6_operadores_logicos/#proposicoes","title":"Proposi\u00e7\u00f5es","text":"<p>Uma proposi\u00e7\u00e3o \u00e9 uma afirma\u00e7\u00e3o que pode ter valor verdadeiro ou falso. Por exemplo:</p> <p>$$ A := \\text{A primeira letra de Brasil \u00e9 B.}$$ $$B := \\text{A primeira letra de Brasil \u00e9 Z}$$ Acima, claramente, $A$ \u00e9 verdadeiro e $B$ \u00e9 falso.</p> <p>\u00c9 poss\u00edvel operar com as proposi\u00e7\u00f5es com as opera\u00e7\u00f5es E, OU e N\u00c3O, gerando novas proposi\u00e7\u00f5es:</p> <p>$$ C := A \\text{ \\textbf{e} } B \\text{ s\u00e3o verdadeiros} $$ $$ D := A \\text{ \\textbf{ou} } B \\text{ s\u00e3o verdadeiros} $$ $$ E := A \\text{ \\textbf{n\u00e3o} \u00e9 verdadeiro} $$ Em C++, naturalmente, guardamos o resultado de proposi\u00e7\u00f5es em <code>bool</code>'s. Os operadores que utilizamos para operar sobre <code>bool</code>'s como operamos em proposi\u00e7\u00f5es s\u00e3o os operadores l\u00f3gicos.</p>"},{"location":"C%2B%2B/6_operadores_logicos/#operadores-logicos_1","title":"Operadores L\u00f3gicos","text":"<p>Operadores l\u00f3gicos operam sobre bools. S\u00e3o eles <code>&amp;&amp;</code>, <code>||</code> e o <code>!</code>, respectivamente o E, OU e N\u00c3O.</p> a b a &amp;&amp; b a || b !a <code>true</code> <code>true</code> <code>true</code> <code>true</code> <code>false</code> <code>true</code> <code>false</code> <code>false</code> <code>true</code> <code>false</code> <code>true</code> <code>false</code> <code>true</code> <code>true</code> <code>false</code> <code>false</code> <code>false</code> <code>false</code> <p>Note que - Enquanto <code>&amp;&amp;</code> e <code>||</code> s\u00e3o operadores bin\u00e1rios, recebendo dois operandos, <code>!</code> \u00e9 um operador un\u00e1rio, agindo apenas sobre um operando. - O <code>||</code> \u00e9 um OU inclusivo, ou seja, basta que um dos operandos seja verdadeiro para o resultado ser verdadeiro.</p> <p>Desses operadores, <code>!</code> tem a maior preced\u00eancia, seguido por <code>&amp;&amp;</code> e <code>||</code>.</p> <p>Caso operadores l\u00f3gicos sejam utilizados em outros tipos, eles ser\u00e3o implicitamente convertidos para <code>bool</code>. Seguem exemplos de uso dos operadores l\u00f3gicos:</p>"},{"location":"C%2B%2B/6_operadores_logicos/#cout-true-true-n-1-cout-true-false-n-0-cout-false-true-n-0-cout-false-false-n-0-cout-true-true-n-1-cout-true-false-n-1-cout-false-true-n-1-cout-false-false-n-0-cout-true-n-0-cout-false-n-1","title":"<pre><code>cout &lt;&lt; (true &amp;&amp; true) &lt;&lt; '\\n'; // 1\ncout &lt;&lt; (true &amp;&amp; false) &lt;&lt; '\\n'; // 0\ncout &lt;&lt; (false &amp;&amp; true) &lt;&lt; '\\n'; // 0\ncout &lt;&lt; (false &amp;&amp; false) &lt;&lt; '\\n'; // 0\n\ncout &lt;&lt; (true || true) &lt;&lt; '\\n'; // 1\ncout &lt;&lt; (true || false) &lt;&lt; '\\n'; // 1\ncout &lt;&lt; (false || true) &lt;&lt; '\\n'; // 1\ncout &lt;&lt; (false || false) &lt;&lt; '\\n'; // 0\n\ncout &lt;&lt; (!true) &lt;&lt; '\\n'; // 0;\ncout &lt;&lt; (!false) &lt;&lt; '\\n'; // 1;\n</code></pre>","text":""},{"location":"C%2B%2B/6_operadores_logicos/#cout-1-2-n-1-cout-1-0-n-0-cout-15-c-n-1","title":"<pre><code>cout &lt;&lt; (1 &amp;&amp; 2) &lt;&lt; '\\n'; // 1\ncout &lt;&lt; (1 &amp;&amp; 0) &lt;&lt; '\\n'; // 0\ncout &lt;&lt; (1.5 &amp;&amp; 'c') &lt;&lt; '\\n'; // 1\n</code></pre>","text":""},{"location":"C%2B%2B/6_operadores_logicos/#bool-a-b-cout-a-b-b-a-n-ou-exclusivo","title":"<pre><code>bool a, b;\ncout &lt;&lt; (a &amp;&amp; !b || b &amp;&amp; !a) &lt;&lt; '\\n'; //OU exclusivo\n</code></pre>","text":"<pre><code>cout &lt;&lt; (1 &lt; 4 &lt; 2) &lt;&lt; '\\n'; // 1, ERRADO\ncout &lt;&lt; (1 &lt; 4 &amp;&amp; 4 &lt; 2) &lt;&lt; '\\n'; // 0\n</code></pre>"},{"location":"C%2B%2B/6_operadores_logicos/#curto-circuito","title":"Curto-circuito","text":"<p>Em alguns casos, uma opera\u00e7\u00e3o com um operador l\u00f3gico n\u00e3o precisa avaliar todos os seus operandos para seu resultado ser conhecido. Chamamos esse fen\u00f4meno de curto-circuito.</p> <p>Ocorre curto-circuito quando - O primeiro operando do <code>&amp;&amp;</code> \u00e9 falso. O resultado j\u00e1 \u00e9 determinado falso e o segundo operando n\u00e3o \u00e9 avaliado.  - O primeiro operando do <code>||</code> \u00e9 verdadeiro. O resultado j\u00e1 \u00e9 determinado verdadeiro e o segundo operando n\u00e3o \u00e9 avaliado.</p> <p>O uso inteligente do curto-circuito \u00e9 muito \u00fatil em dois casos - Uma dos operandos \u00e9 muito mais custoso que o outro e, portanto, deve ser avaliado apenas se for necess\u00e1rio. - Um dos operandos s\u00f3 pode ser avaliado se o resultado do outro for determinado.</p> <p><pre><code>    int x;\n    cin &gt;&gt; x;\n    bool b = x &lt; 100 || x/2 == 100;\n</code></pre> Quando <code>x</code> for menor que 100, o programa nem avalia o lado direito do <code>&amp;&amp;</code>, evitando de fazer a opera\u00e7\u00e3o custosa da divis\u00e3o.</p> <p><pre><code>string s;\ncin &gt;&gt; s;\nbool b = s.size() &gt;= 3 &amp;&amp; s[2] == 'z';\n</code></pre> O programa apenas acessa o terceiro caractere da <code>string</code> se j\u00e1 souber que seu tamanho \u00e9 ao menos 3, ou seja, que o caractere existe.</p>"},{"location":"C%2B%2B/7_fluxo_de_controle_1_condicionais/","title":"Fluxo de Controle 1 - Condicionais","text":"<p>Introdu\u00e7\u00e3o ao fluxo de controle e condicionais.</p>"},{"location":"C%2B%2B/7_fluxo_de_controle_1_condicionais/#fluxo-de-controle","title":"Fluxo de Controle","text":"<p>Fluxo de controle \u00e9 a ordem em que comandos s\u00e3o executados em um programa. Com as ferramentas apresentadas at\u00e9 o momento, um programa sempre executa, linha a linha, todos os seus comandos de cima para baixo. Por\u00e9m, existem ferramentas em linguagens de programa\u00e7\u00e3o para modificar o fluxo de controle.</p> <p>As duas categorias de comandos de fluxo de controle mais comuns nas linguagens de programa\u00e7\u00e3o s\u00e3o condicionais e loops.</p>"},{"location":"C%2B%2B/7_fluxo_de_controle_1_condicionais/#condicionais","title":"Condicionais","text":"<p>Condicionais permitem que comandos sejam executados se, e somente se, determinada condi\u00e7\u00e3o for verdadeira. S\u00e3o exemplos de uso da execu\u00e7\u00e3o condicional de comandos: - Logar um usu\u00e1rio somente se a senha inserida estiver correta. - Desligar o computador somente se n\u00e3o houver programas abertos. - Atualizar o computador somente se estiver carregando.</p> <p>Os condicionais mais comuns no C++ s\u00e3o o <code>if</code>, o <code>else</code> e o <code>else if</code>.</p>"},{"location":"C%2B%2B/7_fluxo_de_controle_1_condicionais/#if","title":"<code>if</code>","text":"<p>O <code>if</code> permite a execu\u00e7\u00e3o de um comando se, e somente se, uma condi\u00e7\u00e3o for verdadeira. Ele \u00e9 sempre \u00e9 da forma <pre><code>if(condi\u00e7\u00e3o) comando\n</code></pre></p> <p>A condi\u00e7\u00e3o \u00e9 uma express\u00e3o que deve retornar um <code>bool</code>, cujo valor ditar\u00e1 a execu\u00e7\u00e3o do comando. Seguem exemplos de uso do if.</p>"},{"location":"C%2B%2B/7_fluxo_de_controle_1_condicionais/#if1-5-cout-1-n-1-if1-5-cout-1-n-nao-executa-if1-5-2-3-cout-aquin-aqui-iftrue-cout-blan-bla-iffalse-cout-blen-nao-executa","title":"<pre><code>if(1 &lt; 5) cout &lt;&lt; 1 &lt;&lt; '\\n'; // 1\nif(1 &gt; 5) cout &lt;&lt; 1 &lt;&lt; '\\n'; // n\u00e3o executa\nif(1 &lt; 5 &amp;&amp; 2 &lt; 3) cout &lt;&lt; \"aqui\\n\"; // aqui\nif(true) cout &lt;&lt; \"bla\\n\"; //bla\nif(false) cout &lt;&lt; \"ble\\n\"; //n\u00e3o executa\n</code></pre>","text":"<p><pre><code>string senha = \"12345\";\nstring input;\ncin &gt;&gt; input;\nif(input == senha)\n    cout &lt;&lt; \"Logado!\\n\";\n</code></pre> \u00c9 uma boa pr\u00e1tica indentar os comandos para explicitar sua associa\u00e7\u00e3o a um <code>if</code>.</p> <p>Tamb\u00e9m \u00e9 poss\u00edvel associar m\u00faltiplos comandos a um if com o uso de <code>{}</code>. Isso \u00e9 feito na grande maioria dos casos.</p>"},{"location":"C%2B%2B/7_fluxo_de_controle_1_condicionais/#string-senha-12345-string-input-cin-input-ifinput-senha-cout-logadon-int-x-y-cin-x-y-cout-x-y-n","title":"<pre><code>string senha = \"12345\";\nstring input;\ncin &gt;&gt; input;\nif(input == senha) {\n    cout &lt;&lt; \"Logado!\\n\";\n    int x, y;\n    cin &gt;&gt; x &gt;&gt; y;\n    cout &lt;&lt; x + y &lt;&lt; '\\n';\n}\n</code></pre>","text":"<pre><code>int x, y;\nchar op;\ncin &gt;&gt; x &gt;&gt; y &gt;&gt; op;\n\nif(op == '+') {\n    cout &lt;&lt; x + y &lt;&lt; '\\n';\n}\nif(op == '-') {\n    cout &lt;&lt; x - y &lt;&lt; '\\n';\n}\nif(op == '*') {\n    cout &lt;&lt; x * y &lt;&lt; '\\n';\n}\nif(op == '/') {\n    cout &lt;&lt; x / y &lt;&lt; '\\n';\n}\n</code></pre> <p>Alguns consideram uma boa pr\u00e1tica o uso de <code>{}</code> mesmo que o <code>if</code> contenha apenas um comando, afim de melhorar a legibilidade do c\u00f3digo.</p>"},{"location":"C%2B%2B/7_fluxo_de_controle_1_condicionais/#else","title":"<code>else</code>","text":"<p>Um <code>else</code> pode acompanhar um <code>if</code> para ser executado caso sua condi\u00e7\u00e3o seja falsa. Nesse caso, todos os comandos no bloco do <code>if</code> ser\u00e3o pulados e o programa passar\u00e1 a executar os comandos no bloco do <code>else</code>. Se um <code>if</code> \u00e9 um \"se\", o <code>else</code> \u00e9 um \"sen\u00e3o\".</p>"},{"location":"C%2B%2B/7_fluxo_de_controle_1_condicionais/#string-nome-cin-nome-ifnomesize-10-cout-okn-else-cout-grande-demaisn","title":"<pre><code>string nome;\ncin &gt;&gt; nome;\nif(nome.size() &lt;= 10) {\n    cout &lt;&lt; \"OK!\\n\";\n}else {\n    cout &lt;&lt; \"Grande demais!\\n\";\n}\n</code></pre>","text":"<pre><code>if(true) {\n    cout &lt;&lt; \"Sempre executa!\\n\";\n}else {\n    cout &lt;&lt; \"Nunca executa!\\n\";\n}\n</code></pre>"},{"location":"C%2B%2B/7_fluxo_de_controle_1_condicionais/#else-if","title":"<code>else if</code>","text":"<p>Um <code>else if</code> \u00e9 uma condi\u00e7\u00e3o que pode seguir de um <code>if</code> e deve ser avaliada apenas se a condi\u00e7\u00e3o do <code>if</code> for falsa. Se o <code>if</code> \u00e9 um \"se\", o <code>else if</code> \u00e9 um \"sen\u00e3o, se\".</p>"},{"location":"C%2B%2B/7_fluxo_de_controle_1_condicionais/#string-usuario-cin-usuario-ifusuario-wylson789-cout-bem-vindon-else-ifusuario-mhjmbs-cout-ewn","title":"<pre><code>string usuario;\ncin &gt;&gt; usuario;\n\nif(usuario == \"wylson789\") {\n    cout &lt;&lt; \"Bem Vindo!\\n\";\n}else if(usuario == \"mhjmbs\") {\n    cout &lt;&lt; \"Ew...\\n\";\n}\n</code></pre>","text":"<p><pre><code>int idade;\nstring olhos;\ncin &gt;&gt; idade &gt;&gt; olhos;\n\nif(40 &lt;= idade &amp;&amp; idade &lt;= 55) {\n    cout &lt;&lt; \"Voc\u00ea est\u00e1 na meia-idade\\n\";\n}else if(olhos == \"verdes\") {\n    cout &lt;&lt; \"Voc\u00ea tem olhos verdes\\n\";\n}\n</code></pre> Note que se a pessoa est\u00e1 na meia-idade e tem olhos verdes, o programa apenas dir\u00e1 que ela est\u00e1 na meia-idade!</p> <p>M\u00faltiplos <code>else if</code>'s podem ser encadeados. Al\u00e9m disso, pode-se sempre adicionar um <code>else</code> ao final da cadeia de <code>else if</code>'s para ser executado caso nenhuma condi\u00e7\u00e3o avaliada seja verdadeira.</p> <p><pre><code>double altura;\ncin &gt;&gt; altura;\n\nif(altura &lt; 1.90) {\n    cout &lt;&lt; \"Voc\u00ea \u00e9 normal\\n\";\n}else if(altura &lt; 2.00) {\n    cout &lt;&lt; \"Voc\u00ea \u00e9 muito alto\\n\";\n}else if(altura &lt; 2.10) {\n    cout &lt;&lt; \"Voc\u00ea \u00e9 alto demais\\n\";\n}else {\n    cout &lt;&lt; \"?????\\n\";\n}\n</code></pre> Note que ao avaliar <code>altura &lt; 2.00</code>, j\u00e1 sabemos <code>altura</code> \u00e9 ao menos <code>1.90</code>. Caso contr\u00e1rio, o programa teria executado o bloco do <code>if</code> e pulado para ap\u00f3s o <code>else</code> para continuar sua execu\u00e7\u00e3o.</p>"},{"location":"C%2B%2B/8_fluxo_de_controle_2_loops/","title":"Fluxo de Controle 2 - Loops","text":"<p>Uso de estruturas de repeti\u00e7\u00e3o</p>"},{"location":"C%2B%2B/8_fluxo_de_controle_2_loops/#loops","title":"Loops","text":"<p>Uma loop ou uma estrutura de repeti\u00e7\u00e3o \u00e9 um comando de uma linguagem de programa\u00e7\u00e3o que permite a execu\u00e7\u00e3o das mesmas linhas de c\u00f3digo repetidas vezes.</p> <p>As estruturas de repeti\u00e7\u00e3o mais comuns em linguagens de programa\u00e7\u00e3o s\u00e3o o <code>while</code> e o <code>for</code>.</p>"},{"location":"C%2B%2B/8_fluxo_de_controle_2_loops/#while","title":"<code>while</code>","text":"<p>O while executa o mesmo comando enquanto sua condi\u00e7\u00e3o for verdadeira. Ele sempre \u00e9 da forma.</p> <p><code>while(condi\u00e7\u00e3o) comando</code></p> <p>Assim como o <code>if</code>, o comando pode ser substitu\u00eddo por uma sequ\u00eancia de comandos com o uso de <code>{}</code>. Seguem alguns exemplos do uso do <code>while</code>. <pre><code>int x = 0;\nwhile(x &lt; 5) {\n    cout &lt;&lt; x &lt;&lt; ' ';\n    x++;\n}\ncout &lt;&lt; '\\n';\n//0 1 2 3 4\n</code></pre></p>"},{"location":"C%2B%2B/8_fluxo_de_controle_2_loops/#int-x-8-whilex-1-cout-x-x-2-cout-n-8-4-2","title":"<pre><code>int x = 8;\nwhile(x != 1) {\n    cout &lt;&lt; x &lt;&lt; ' ';\n    x /= 2;\n}\ncout &lt;&lt; '\\n';\n//8 4 2\n</code></pre>","text":""},{"location":"C%2B%2B/8_fluxo_de_controle_2_loops/#int-x-2-whilex-1000-cout-x-x-x-cout-n-2-4-16-256","title":"<pre><code>int x = 2;\nwhile(x &lt; 1000) {\n    cout &lt;&lt; x &lt;&lt; ' ';\n    x *= x;\n}\ncout &lt;&lt; '\\n';\n//2 4 16 256\n</code></pre>","text":"<p><pre><code>while(true) {\n    cout &lt;&lt; a;\n}\n//aaaa...\n</code></pre> Loops podem executar infinitamente, caso a condi\u00e7\u00e3o permita.</p> <p><pre><code>while(false) {\n    cout &lt;&lt; a;\n}\n//\n</code></pre> Loops podem nunca executar, caso a condi\u00e7\u00e3o permita.</p> <pre><code>int x = 5;\nwhile(x) {\n    cout &lt;&lt; x &lt;&lt; ' ';\n    x--;\n}\ncout &lt;&lt; '\\n';\n//5 4 3 2 1\n</code></pre>"},{"location":"C%2B%2B/8_fluxo_de_controle_2_loops/#for","title":"<code>for</code>","text":"<p>O <code>for</code> faz o mesmo que o <code>while</code>, mas sua estrutura permite a declara\u00e7\u00e3o de uma ou mais vari\u00e1veis do mesmo tipo e um comando para a altera\u00e7\u00e3o de valores de itera\u00e7\u00e3o em itera\u00e7\u00e3o. Ele sempre \u00e9 da forma.</p> <p><code>for(declara\u00e7\u00e3o; condi\u00e7\u00e3o; altera\u00e7\u00e3o) comando</code></p> <p>Quando o programa chega ao <code>for</code>, s\u00e3o executadas a declara\u00e7\u00e3o e a condi\u00e7\u00e3o. Caso a condi\u00e7\u00e3o seja verdadeira, o comando \u00e9 executado. Ap\u00f3s o comando, o comando de altera\u00e7\u00e3o \u00e9 executado e \u00e9 checada novamente a condi\u00e7\u00e3o para adentrar o loop. Uma vez que a condi\u00e7\u00e3o for avaliada falsa, o programa continua a execu\u00e7\u00e3o ap\u00f3s o <code>for</code>.</p> <p>Seguem exemplos de seu uso.</p>"},{"location":"C%2B%2B/8_fluxo_de_controle_2_loops/#forint-i-0-i-5-i-cout-i-cout-n-0-1-2-3-4","title":"<pre><code>for(int i = 0; i &lt; 5; i++) {\n    cout &lt;&lt; i &lt;&lt; ' ';\n}\ncout &lt;&lt; '\\n';\n//0 1 2 3 4\n</code></pre>","text":"<pre><code>for(int i = 0, j = 10; i != j; i++, j--) {\n    cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; j &lt;&lt; '\\n';\n}\n//1 9\n//2 8\n//3 7\n//4 6\n</code></pre>"},{"location":"C%2B%2B/8_fluxo_de_controle_2_loops/#loops-aninhados","title":"Loops Aninhados","text":"<p>\u00c9 poss\u00edvel aninhar loops dentro de outros loops</p> <pre><code>for(int i = 0; i &lt; 5; i++) {\n    cout &lt;&lt; i &lt;&lt; '\\n';\n    for(int j = 0; j &lt; 3; j++) {\n        cout &lt;&lt; \"    \" &lt;&lt; j &lt;&lt; '\\n';\n    }\n}\n//0\n//  0\n//  1\n//  2\n//1\n//  0\n//  1\n//  2\n//2\n//  0\n//  1\n//  2\n//3\n//  0\n//  1\n//  2\n//4\n//  0\n//  1\n//  2\n</code></pre>"},{"location":"C%2B%2B/8_fluxo_de_controle_2_loops/#break","title":"<code>break</code>","text":"<p>O comando <code>break</code> pode for\u00e7adamente finalizar a execu\u00e7\u00e3o de um loop:</p>"},{"location":"C%2B%2B/8_fluxo_de_controle_2_loops/#forint-i-0-i-5-i-ifi-3-break-cout-x-cout-n-0-1-2","title":"<pre><code>for(int i = 0; i &lt; 5; i++) {\n    if(i == 3) break;\n    cout &lt;&lt; x &lt;&lt; ' ';\n}\ncout &lt;&lt; '\\n';\n//0 1 2\n</code></pre>","text":"<pre><code>while(true) {\n    string entrada;\n    cin &gt;&gt; entrada;\n    if(entrada == \"PARE!\") break;\n}\n</code></pre>"},{"location":"C%2B%2B/8_fluxo_de_controle_2_loops/#continue","title":"<code>continue</code>","text":"<p>O comando <code>continue</code> pode for\u00e7adamente pular a execu\u00e7\u00e3o de uma itera\u00e7\u00e3o de um loop:</p> <pre><code>for(int i = 0; i &lt; 5; i++) {\n    if(i == 3) continue;\n    cout &lt;&lt; i &lt;&lt; ' ';\n}\ncout &lt;&lt; '\\n';\n//0 1 2 4\n</code></pre>"},{"location":"Fortran/Fortran_77/","title":"Fortran 77","text":"<p>Aqui vamos abordar v\u00e1rias particularidades da vers\u00e3o 77. Sua leitura fica a crit\u00e9rio da curiosidade ou da necessidade do leitor.</p> <p>Este material foi fortemente inspirado no guia de Stanford para F77, dispon\u00edvel em Stanford ME200C Tutorial.</p>"},{"location":"Fortran/Fortran_77/#basico","title":"B\u00e1sico","text":"<p>A estrutura principal do c\u00f3digo F77 \u00e9 da forma:</p> <pre><code>c234567 \n      program *nome*\n\n      *declara\u00e7\u00f5es de vari\u00e1veis*\n\n      *comandos*\n\n      stop\n      end\n</code></pre> <p>A formata\u00e7\u00e3o da vers\u00e3o 77 \u00e9 r\u00edgida, seguindo um padr\u00e3o ditado pelo n\u00famero referente \u00e0 coluna no editor de texto, da seguinte forma:</p> <ul> <li>Coluna 1: Vazia ou preencha com \"c\" ou \"*\" para usar a linha como coment\u00e1rio.</li> <li>Colunas 1-5: Categoria da declara\u00e7\u00e3o da linha.</li> <li>Coluna 6: Indica a continua\u00e7\u00e3o da linha pr\u00e9via (opcional).</li> <li>Colunas 7-72: Comando.</li> <li>Colunas 73-80: N\u00famero de sequ\u00eancia (uso incomum).</li> </ul> <p>Importante salientar que n\u00e3o podemos ter uma vari\u00e1vel com o mesmo nome que o programa.</p> <p><pre><code>c234567\n      PROGRAM HELLO\n      WRITE(UNIT=*, FMT=*) 'Hello World'\n      STOP\n      END\n</code></pre> exemplo 1: Hello World. Note que os comandos come\u00e7am a partir da coluna 7</p> <p>Note que no c\u00f3digo acima o comando <code>write(UNIT=*, FMT=*)</code> tamb\u00e9m poder\u00e1 ser escrito como <code>write(*,*)</code>, o que \u00e9 uma simplifica\u00e7\u00e3o usual na atribui\u00e7\u00e3o desses argumentos compuls\u00f3rios.</p>"},{"location":"Fortran/Fortran_77/#variaveis-tipos-e-declaracoes","title":"Vari\u00e1veis, Tipos e Declara\u00e7\u00f5es","text":"<p>Vari\u00e1veis em Fortran consistem em no m\u00e1ximo 6 caracteres alfanum\u00e9ricos, iniciando com uma letra, sem diferenciar mai\u00fasculas e min\u00fasculas. Palavras reservadas como <code>program</code>, <code>real</code>, <code>stop</code> e <code>end</code> n\u00e3o podem ser usadas como nomes de vari\u00e1veis.</p> <p>Toda vari\u00e1vel deve ser definida em uma declara\u00e7\u00e3o que estabelece seu tipo, como:</p> <ul> <li>integer</li> <li>real</li> <li>double precision</li> <li>complex</li> <li>logical</li> <li>character</li> </ul> <p>Embora o Fortran utilize regras impl\u00edcitas se a vari\u00e1vel n\u00e3o for declarada, \u00e9 boa pr\u00e1tica usar <code>implicit none</code> para evitar ambiguidades e for\u00e7ar a declara\u00e7\u00e3o de todas as vari\u00e1veis.</p> <ul> <li>O tipo integer geralmente tem 32 bits, com limite aproximado de \u00b12\u00d710\u2079.</li> <li>Existem dois tipos de float: real (4 bytes) e double precision (8 bytes).</li> </ul> <p>Para definir constantes, declara-se um par\u00e2metro na sintaxe:</p> <pre><code>      parameter (name = constant, ..., name = constant)\n</code></pre> <p>O par\u00e2metro deve ser definido antes da primeira execu\u00e7\u00e3o do c\u00f3digo.</p> <p><pre><code>c234567\n      PROGRAM TYPES\n      IMPLICIT NONE\n\n      ! Determina a declara\u00e7\u00e3o do tipo de vari\u00e1veis\n      INTEGER alfa, beta, delta\n\n      PARAMETER (alfa = 5, beta = 10)\n\n      delta = alfa + beta\n      write (*,*) 'Resulta em', delta\n\n      STOP\n      END\n</code></pre> exemplo 2: tipagem</p>"},{"location":"Fortran/Fortran_77/#expressoes-e-atribuicoes","title":"Express\u00f5es e Atribui\u00e7\u00f5es","text":""},{"location":"Fortran/Fortran_77/#expressoes","title":"Express\u00f5es","text":"<p>Uma express\u00e3o \u00e9 uma combina\u00e7\u00e3o de operandos e operadores, como em <code>x + y</code> (onde <code>x</code> e <code>y</code> s\u00e3o operandos e <code>+</code> \u00e9 o operador). O resultado de uma express\u00e3o torna-se um novo operando, permitindo nesting (express\u00f5es aninhadas).</p> <p>Existem constantes de seis tipos: integer, real, double precision, complex, logical e character. - O uso de <code>E</code> em um valor, como <code>2.0E6</code>, implica que o valor anterior \u00e0 <code>E</code> deve ser multiplicado por 10 elevado ao n\u00famero \u00e0 direita de <code>E</code> (ou seja, <code>2.0E6 = 2 * 10^6</code>). - Valores complexos s\u00e3o expressos como um par de constantes (por exemplo, <code>(2, -3)</code> ou <code>(1., 9.9E-1)</code>), onde o primeiro \u00e9 a parte real e o segundo a parte imagin\u00e1ria. - Constantes l\u00f3gicas s\u00e3o expressas como <code>.True.</code> ou <code>.False.</code> (os pontos s\u00e3o obrigat\u00f3rios). - Constantes de caractere, ou strings, s\u00e3o delimitadas por aspas simples (ex.: <code>'ABC'</code>, <code>'potato potato'</code>) e s\u00e3o sens\u00edveis a mai\u00fasculas e min\u00fasculas.</p>"},{"location":"Fortran/Fortran_77/#atribuicoes","title":"Atribui\u00e7\u00f5es","text":"<p>A sintaxe para atribui\u00e7\u00f5es \u00e9:</p> <pre><code>nome_da_variavel = express\u00e3o\n</code></pre> <p>O valor da express\u00e3o \u00e0 direita \u00e9 avaliado e atribu\u00eddo \u00e0 vari\u00e1vel \u00e0 esquerda.</p>"},{"location":"Fortran/Fortran_77/#conversao-de-tipos","title":"Convers\u00e3o de Tipos","text":"<p>Quando diferentes tipos de dados s\u00e3o usados em uma express\u00e3o, pode ocorrer convers\u00e3o impl\u00edcita ou \u00e9 necess\u00e1rio for\u00e7ar a convers\u00e3o usando fun\u00e7\u00f5es como: - <code>int</code> (para converter para integer) - <code>real</code> (para converter para real) - <code>dble</code> (para converter para double precision) - <code>ichar</code> (converte caractere em inteiro) - <code>char</code> (converte inteiro em caractere)</p> <p>Note que <code>w = dble(x) * dble(y)</code> difere de <code>w = dble(x*y)</code> para vari\u00e1veis reais <code>x</code> e <code>y</code>.</p>"},{"location":"Fortran/Fortran_77/#operadores-logicos-e-condicionais","title":"Operadores L\u00f3gicos e Condicionais","text":""},{"location":"Fortran/Fortran_77/#operadores-logicos","title":"Operadores L\u00f3gicos","text":"<p>Para comparar express\u00f5es, utilizamos operadores relacionais que avaliam como <code>.True.</code> ou <code>.False.</code>:</p> <ul> <li><code>.LT.</code> : \"menor que\" (equivalente a <code>&lt;</code>)</li> <li><code>.GT.</code> : \"maior que\" (equivalente a <code>&gt;</code>)</li> <li><code>.LE.</code> : \"menor ou igual\" (equivalente a <code>&lt;=</code>)</li> <li><code>.GE.</code> : \"maior ou igual\" (equivalente a <code>&gt;=</code>)</li> <li><code>.EQ.</code> : \"igual\" (equivalente a <code>=</code>)</li> <li><code>.NQ.</code> : \"diferente\" (equivalente a <code>!=</code>)</li> </ul> <p>Outros termos \u00fateis s\u00e3o: - <code>.AND.</code> - <code>.OR.</code> - <code>.NOT.</code></p>"},{"location":"Fortran/Fortran_77/#condicionais","title":"Condicionais","text":"<p>Condi\u00e7\u00f5es s\u00e3o estruturadas de tr\u00eas maneiras:</p> <ol> <li> <p>Condi\u00e7\u00e3o em linha \u00fanica:    Se a condi\u00e7\u00e3o l\u00f3gica for verdadeira, execute o comando.    <pre><code>      if (x .LT. 0) x = -x\n</code></pre></p> </li> <li> <p>Condi\u00e7\u00e3o com m\u00faltiplos comandos: <pre><code>      if (condi\u00e7\u00e3o l\u00f3gica) then\n          comandos\n      endif\n</code></pre></p> </li> <li> <p>Condi\u00e7\u00e3o com alternativas: <pre><code>      if (condi\u00e7\u00e3o l\u00f3gica) then\n          comandos\n      elseif (outra condi\u00e7\u00e3o l\u00f3gica) then\n          comandos\n      else\n          comandos\n      endif\n</code></pre></p> </li> </ol>"},{"location":"Fortran/Fortran_77/#exemplo-cadastro-de-numeros-telefonicos-com-ddd","title":"Exemplo: Cadastro de N\u00fameros Telef\u00f4nicos com DDD","text":"<p><pre><code>c234567\n      PROGRAM CONDITIONALS\n      IMPLICIT NONE\n      CHARACTER*11 NUMBER\n      CHARACTER*9 REST\n      INTEGER LEN\n\n      write (*,*) 'Input Number:'\n      read (*,*) NUMBER\n\n      LEN = LEN_TRIM(NUMBER)\n\n      IF (LEN .GT. 3) THEN\n          REST = NUMBER(3:LEN)\n      ELSE\n          REST = ''\n      END IF\n\n      IF (LEN .LT. 8 .OR. LEN .GT. 11) then\n          write(*,*) 'Invalid Number'\n      ELSE IF (LEN .EQ. 8 .OR. LEN .EQ. 9) then\n          write(*,*) NUMBER\n      ELSE IF (LEN .EQ. 10 .OR. LEN .EQ. 11) then         \n          write(*,*) 'DDD and number are ', NUMBER(1:2) // ' ' // REST\n      END IF\n\n      STOP\n      END\n</code></pre> exemplo 3: cadastro de telefone</p> <p>Funcionamento do Programa: - Solicita ao usu\u00e1rio um n\u00famero de telefone (string). - Calcula o comprimento real da string com <code>LEN_TRIM</code>. - Se o comprimento for menor que 8 ou maior que 11, imprime \"Invalid Number\". - Se for 8 ou 9, imprime o n\u00famero diretamente. - Se for entre 10 e 11, imprime o DDD (dois primeiros caracteres), um espa\u00e7o e o restante do n\u00famero.</p>"},{"location":"Fortran/Fortran_77/#loops","title":"Loops","text":""},{"location":"Fortran/Fortran_77/#do-loops","title":"Do Loops","text":"<p>A sintaxe geral \u00e9:</p> <pre><code>c234567\n      do label var = expr1, expr2, expr3\n          statements\n      label continue\n</code></pre> <ul> <li>var: vari\u00e1vel do loop (deve ser inteiro)</li> <li>expr1: valor inicial</li> <li>expr2: valor limitante</li> <li>expr3: incremento</li> </ul> <p><pre><code>c234567\n      PROGRAM SHOW\n      IMPLICIT NONE\n\n      INTEGER a(10), I\n\n      DATA a /1, 2, 3, 4, 5, 6, 7, 8, 9, 10/\n\n      DO 10 I = 1, 10\n          PRINT *, 'Elemento', I, ':', a(I)\n10    CONTINUE\n\n      END\n</code></pre> exemplo 4.1: loop simples</p>"},{"location":"Fortran/Fortran_77/#while-loops-condicao-de-progresso","title":"While Loops (Condi\u00e7\u00e3o de Progresso)","text":"<p>O programador atual est\u00e1 acostumado com o formato:</p> <pre><code>c234567\n      while (logical expr) do\n        statements\n      enddo\n</code></pre> <p>Mas ele n\u00e3o \u00e9 ANSI Fortran 77. O adequado \u00e9:</p> <pre><code>c234567\n      label if (logical expr) then\n          statements\n          goto label\n      end if\n</code></pre> <p><pre><code>c234567\n      PROGRAM WOW\n      IMPLICIT NONE\n\n      INTEGER a(10), I\n\n      DATA a /1, 2, 3, 4, 5, 6, 7, 8, 9, 10/\n\n      I = 1\n\n10    IF (a(I) /= 5) THEN\n          PRINT *, 'Elemento', I, ':', a(I)\n          I = I + 1\n          GOTO 10\n      END IF\n\n      END\n</code></pre> exemplo 4.2: While do</p>"},{"location":"Fortran/Fortran_77/#until-loops-condicao-de-parada","title":"Until Loops (Condi\u00e7\u00e3o de Parada)","text":"<p>Um exemplo de loop \"until\" usando <code>goto</code>:</p> <p><pre><code>c234567\n10    CONTINUE\n      PRINT *, 'Elemento', I, ':', a(I)\n      I = I + 1\n      IF (a(I) /= 9) THEN       \n          GOTO 10\n      END IF\n      END\n</code></pre> exemplo 4.3: Until do</p>"},{"location":"Fortran/Fortran_77/#subprogramas","title":"Subprogramas","text":"<p>Subprogramas s\u00e3o blocos de c\u00f3digo que resolvem tarefas espec\u00edficas, podendo ser fun\u00e7\u00f5es ou subrotinas.</p>"},{"location":"Fortran/Fortran_77/#funcoes","title":"Fun\u00e7\u00f5es","text":"<p>Fun\u00e7\u00f5es recebem um ou mais argumentos e retornam um valor. A maioria das fun\u00e7\u00f5es inatas (como <code>abs</code>, <code>min</code>, <code>max</code>, <code>sqrt</code>) s\u00e3o gen\u00e9ricas, mas fun\u00e7\u00f5es definidas pelo usu\u00e1rio geralmente precisam especificar o tipo de retorno. O valor de retorno \u00e9 atribu\u00eddo \u00e0 vari\u00e1vel com o mesmo nome da fun\u00e7\u00e3o e o bloco termina com <code>RETURN</code>.</p> <p><pre><code>c234567\n      PROGRAM CHOOSE\n      IMPLICIT NONE\n\n      INTEGER P, R, QUADRADO\n\n      WRITE(*,*) 'CHOOSE A NUMBER 1 TO 10'\n      READ (*,*) P\n\n      R = QUADRADO(P)\n\n      WRITE(*,*) 'O RESULTADO \u00c9', R\n\n      END\n\n      INTEGER FUNCTION QUADRADO(X)\n      IMPLICIT NONE\n      INTEGER X\n\n      QUADRADO = X * X\n\n      RETURN\n      END\n</code></pre> exemplo 5.1: Quadrado</p>"},{"location":"Fortran/Fortran_77/#subrotinas","title":"Subrotinas","text":"<p>Subrotinas podem retornar mais de um valor e s\u00e3o invocadas com <code>CALL</code>. Elas n\u00e3o possuem tipo.</p> <p><pre><code>c234567\n      PROGRAM CHAMA_SUBROTINA\n      IMPLICIT NONE\n\n      INTEGER N, QUADRADO, CUBO\n\n      PRINT *, 'Digite um n\u00famero:'\n      READ *, N\n\n      CALL CALCULA_QUADRADO_E_CUBO(N, QUADRADO, CUBO)\n\n      PRINT *, 'O quadrado de', N, '\u00e9', QUADRADO\n      PRINT *, 'O cubo de', N, '\u00e9', CUBO\n\n      END\n\n      SUBROUTINE CALCULA_QUADRADO_E_CUBO(X, QUAD, CUB)\n      IMPLICIT NONE\n      INTEGER X, QUAD, CUB\n\n      QUAD = X * X\n      CUB = X * X * X\n\n      RETURN\n      END\n</code></pre> exemplo 5.2: Quadrado e Cubo</p>"},{"location":"Fortran/Fortran_77/#arrays","title":"Arrays","text":"<p>Para declarar vetores e matrizes:</p> <pre><code>c234567\n      real a(20)\n      ! Declara um vetor com 20 componentes reais, indexados de 1 a 20\n\n      real A(3,5)\n      ! Declara uma matriz 3x5\n\n      logical B(20,5,39,29152)\n      ! Declara um array 20x5x39x2\n</code></pre> <p>Fortran 77 permite arrays de at\u00e9 7 dimens\u00f5es.</p>"},{"location":"Fortran/Fortran_77/#manipulacao-de-arrays","title":"Manipula\u00e7\u00e3o de Arrays","text":""},{"location":"Fortran/Fortran_77/#inicializacao-em-loop","title":"Inicializa\u00e7\u00e3o em Loop","text":"<p><pre><code>c234567\n      PROGRAM EXEMPLO_ARRAY\n      IMPLICIT NONE\n\n      INTEGER :: N = 5\n      INTEGER :: A(N)\n      INTEGER :: I\n\n      DO I = 1, N\n          A(I) = I * 2   \n      END DO\n\n      PRINT *, 'Elementos do array A:'\n      DO I = 1, N\n          PRINT *, 'A(', I, ') = ', A(I)\n      END DO\n\n      END\n</code></pre> exemplo 6.1: Array b\u00e1sico</p>"},{"location":"Fortran/Fortran_77/#soma-de-elementos","title":"Soma de Elementos","text":"<p><pre><code>c234567\n      PROGRAM SOMA_ARRAY\n      IMPLICIT NONE\n\n      INTEGER :: N = 5\n      INTEGER :: A(N) = (/1, 2, 3, 4, 5/)\n      INTEGER :: SUM\n      INTEGER :: I\n\n      SUM = 0\n\n      DO I = 1, N\n          SUM = SUM + A(I)\n      END DO\n\n      PRINT *, 'Soma dos elementos de A:', SUM\n\n      END\n</code></pre> exemplo 6.2: Array Soma</p>"},{"location":"Fortran/Fortran_77/#produto-de-elementos","title":"Produto de Elementos","text":"<p><pre><code>c234567\n      PROGRAM MULTIPLICACAO_ARRAY\n      IMPLICIT NONE\n\n      INTEGER :: N = 5\n      INTEGER :: A(N) = (/1, 2, 3, 4, 5/)\n      INTEGER :: PRODUTO\n      INTEGER :: I\n\n      PRODUTO = 1\n\n      DO I = 1, N\n          PRODUTO = PRODUTO * A(I)\n      END DO\n\n      PRINT *, 'Produto dos elementos de A:', PRODUTO\n\n      END\n</code></pre> exemplo 6.3: Array Produto</p>"},{"location":"Fortran/Fortran_77/#common-blocks","title":"Common Blocks","text":"<p>Common blocks permitem compartilhar vari\u00e1veis entre subprogramas. O bloco comum deve ser declarado antes das execu\u00e7\u00f5es.</p> <pre><code>      program main\n      ! Declara\u00e7\u00f5es\n      real alpha, beta\n      common /coeff/ alpha, beta\n\n      ! Statements\n      stop\n      end\n\n      subroutine sub1(...)\n      real alpha, beta\n      common /coeff/ alpha, beta\n\n      ! Statements\n      return\n      end\n\n      subroutine sub2(...)\n      real alpha, beta\n      common /coeff/ alpha, beta\n\n      ! Statements\n      return\n      end\n</code></pre> <p>Regras importantes: - O bloco comum deve ser declarado antes da execu\u00e7\u00e3o do c\u00f3digo. - Blocos comuns distintos devem ter nomes distintos. - Uma vari\u00e1vel n\u00e3o pode aparecer em dois blocos comuns diferentes. - Vari\u00e1veis devem ser listadas na mesma ordem, com o mesmo tipo e tamanho em todas as rotinas que utilizam o mesmo bloco comum. - Arrays com dimens\u00f5es vari\u00e1veis n\u00e3o devem constar em blocos comuns.</p>"},{"location":"Fortran/Fortran_77/#data-e-block-statements","title":"Data e Block Statements","text":"<p>O <code>data</code> statement \u00e9 usado para inicializar vari\u00e1veis antes da execu\u00e7\u00e3o do programa.</p> <p><pre><code>c234567\n      program main\n      data m/10/, n/20/, x/2.5/, y/2.5/\n      real m, n, x, y\n\n      write (*,*) m\n      write (*,*) n \n      write (*,*) x\n      write (*,*) y\n      STOP\n      END\n</code></pre> exemplo 7.1: inicializa\u00e7\u00e3o</p> <p>Outra forma:</p> <p><pre><code>c234567\n      program main\n      data m,n/10,20/, x,y/2*2.5/\n      real m, n, x, y\n\n      write (*,*) m\n      write (*,*) n\n      write (*,*) x\n      write (*,*) y\n      STOP\n      END\n</code></pre> exemplo 7.2: inicializa\u00e7\u00e3o alt Com matrizes:</p> <p><pre><code>c234567\n      program main\n      real A(10,20)\n      data A/ 200 * 0.0/\n      ...\n</code></pre> exemplo 7.3: inicializa\u00e7\u00e3o matricial</p> <p>O exemplo acima inicializa uma matriz 10x20 com todos os 200 valores iguais a zero.</p>"},{"location":"Fortran/Fortran_77/#file-io","title":"File I.O.","text":"<p>O comando principal para acessar um arquivo \u00e9:</p> <pre><code>      open ([UNIT=]u [, IOSTAT=ios, ERR=err, STATUS=sta])\n</code></pre> <p>Especificadores comuns: - unidade (\"u\"): valor inteiro \u00fanico de 1 a 99 que identifica o arquivo. - status (\"ios\"): vari\u00e1vel inteira que retorna zero se a opera\u00e7\u00e3o for bem-sucedida. - error (\"err\"): determina para qual comando o programa deve saltar em caso de erro. - nome (\"fname\"): nome do arquivo a ser acessado (string). - status (\"sta\"): deve ser NEW, OLD ou SCRATCH; define se o arquivo j\u00e1 existe ou se deve ser criado e se ser\u00e1 deletado ap\u00f3s o fechamento. - final (\"end\"): determina para qual comando o programa deve saltar ao chegar ao fim do arquivo (usado em <code>read</code> ou <code>write</code>).</p> <p>Para fechar o arquivo, usa-se:</p> <pre><code>      close ([UNIT=]u [, IOSTAT=ios, ERR=err, STATUS=sta])\n</code></pre> <p>Os comandos <code>read</code> e <code>write</code> s\u00e3o usados com o especificador de unidade obrigat\u00f3rio.</p> <p><pre><code>c234567\n      program inpdat\n      ! Este programa l\u00ea n pontos de um arquivo e os armazena em 3 arrays: x, y, z.\n\n      integer nmax, u\n      parameter (nmax=1000, u=20)\n      real x(nmax), y(nmax), z(nmax)\n\n      ! Abre o arquivo de dados\n      open (u, FILE='points.dat', STATUS='OLD')\n\n      ! L\u00ea o n\u00famero de pontos\n      read(u,*) n\n      if (n.GT.nmax) then\n          write(*,*) 'Error: n = ', n, 'is larger than nmax =', nmax\n          goto 9999\n      endif\n\n      ! Loop sobre os pontos\n      do 10 i= 1, n\n          read(u,100) x(i), y(i), z(i)\n10    enddo\n100   format (3(F10.4))\n\n      ! Fecha o arquivo\n      close (u)\n\n      ! (Parte faltante para processar os dados)\n\n9999  stop\n      end\n</code></pre> exemplo 8: Leitura e escrita (IO)</p>"},{"location":"Fortran/Fortran_77/#format","title":"Format","text":"<p>A formata\u00e7\u00e3o \u00e9 definida com o comando <code>write</code> seguido de um label que especifica o formato.</p> <pre><code>c234567\n      program main\n      data m/10/, n/20/, x/2.5/, y/2.5/\n      real m, n, x, y\n\n      write (*,*) m\n      write (*,*) n\n      write (*,*) x\n      write (*,*) y\n      STOP\n      END\n</code></pre> <p>A sa\u00edda deste c\u00f3digo seria algo como:</p> <pre><code>10.0000000\n20.0000000\n2.50000000\n2.50000000\n</code></pre> <p>A formata\u00e7\u00e3o pode ser alterada seguindo o padr\u00e3o:</p> <pre><code>c234567      \n      write(*,label) lista_de_variaveis\n      label format-code \n</code></pre> <p>C\u00f3digos comuns de formata\u00e7\u00e3o: - A: string de texto - D: n\u00fameros em double precision, nota\u00e7\u00e3o exponencial - E: n\u00fameros reais, nota\u00e7\u00e3o exponencial - F: n\u00fameros reais, formato fixo - I: inteiro - X: espa\u00e7o horizontal - /: salto de linha</p> <p>Exemplo:</p> <p><pre><code>c234567\n      program main\n      data m/10/, n/20/, x/2.5/, y/2.5/\n\n      ! Escreve m com formato I2\n      write (*,100) m\n100   format (I2)\n\n      ! Escreve n com formato inline\n      write (*,'(I2)') n  \n\n      ! Escreve x com formato F4.1\n      write (*,300) x\n300   format (F4.1)\n\n      ! Escreve y com formato E8.2\n      write (*,400) y\n400   format (E8.2)\n\n      STOP\n      END\n</code></pre> exemplo 9: format Sa\u00edda esperada:</p> <pre><code>10\n20\n2.5\n0.25E+01\n</code></pre>"},{"location":"Fortran/Fortran_77/#bibliotecas","title":"Bibliotecas","text":"<p>Como em qualquer outra linguagem, \u00e9 poss\u00edvel utilizar pacotes j\u00e1 criados (muitos gratuitos) para resolver problemas comuns. Para problemas num\u00e9ricos, por exemplo, a plataforma Netlib disponibiliza softwares e databases de interesse cient\u00edfico, como os pacotes BLAS e LAPACK.</p>"},{"location":"Fortran/Fortran_77/#blas","title":"BLAS","text":"<ul> <li>Acr\u00f4nimo de Basic Linear Algebra Subroutines.</li> <li>Cont\u00e9m subprogramas para opera\u00e7\u00f5es com vetores e matrizes.</li> <li>Suas rotinas s\u00e3o organizadas em tr\u00eas n\u00edveis:</li> <li>N\u00edvel 1: Opera\u00e7\u00f5es vetor x vetor.</li> <li>N\u00edvel 2: Opera\u00e7\u00f5es matriz x vetor.</li> <li>N\u00edvel 3: Opera\u00e7\u00f5es matriz x matriz.</li> <li>A primeira letra dos nomes dos subprogramas indica a precis\u00e3o:</li> <li>S: Real precis\u00e3o \u00fanica.</li> <li>D: Real precis\u00e3o dupla.</li> <li>C: Complexo precis\u00e3o \u00fanica.</li> <li>Z: Complexo precis\u00e3o dupla.</li> </ul>"},{"location":"Fortran/Fortran_77/#lapack","title":"LAPACK","text":"<ul> <li>Constru\u00eddo sobre BLAS, \u00e9 uma cole\u00e7\u00e3o para problemas avan\u00e7ados de \u00e1lgebra linear.</li> <li>Documenta\u00e7\u00e3o dispon\u00edvel em:</li> <li>LAPACK Home</li> <li>LAPACK User's Guide</li> <li>Ao instalar, coloque os arquivos <code>.lib</code> (no Windows) ou <code>.a</code> (no Linux) em um diret\u00f3rio apropriado. Certifique-se de ajustar os caminhos de compila\u00e7\u00e3o conforme necess\u00e1rio. O BLAS deve ser especificado por \u00faltimo no comando de compila\u00e7\u00e3o.</li> </ul> <p><pre><code>c234567\n      PROGRAM SolveLinearSystem\n      IMPLICIT NONE\n\n      INTEGER :: n, nrhs, lda, ldb, info\n      PARAMETER (n = 3, nrhs = 1, lda = n, ldb = n)\n\n      REAL :: A(lda, n), B(ldb, nrhs)\n      INTEGER :: ipiv(n)\n\n      EXTERNAL SGESV\n\n      DATA A / 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 10.0 /\n      DATA B / 6.0, 15.0, 25.0 /\n\n      PRINT *, 'Starting the linear system solver...'\n\n      CALL SGESV(n, nrhs, A, lda, ipiv, B, ldb, info)\n\n      PRINT *, 'SGESV call completed.'\n\n      IF (info .EQ. 0) THEN\n          PRINT *, 'The solution is:'\n          PRINT *, B\n      ELSE\n          PRINT *, 'An error occurred: info =', info\n      END IF\n\n      PRINT *, 'Program finished.'\n\n      STOP      \n      END\n</code></pre> Exemplo 10: Solu\u00e7\u00e3o de Sistema Linear</p> <p>Para compilar:</p> <p><pre><code>$ gfortran 10.solucao_linear.f -o 10.solucao_linear -LC:/msys64/mingw64/lib -llapack -lblas\n</code></pre> ou para openblas <pre><code>$ gfortran 10.solucao_linear.f -o 10.solucao_linear -LC:/msys64/mingw64/lib -lopenblas\n</code></pre></p> <p>Observa\u00e7\u00e3o: O diret\u00f3rio especificado ap\u00f3s <code>-LC:</code> deve conter as bibliotecas necess\u00e1rias. Lembre-se que se voc\u00ea for usar LAPACK, ele depende do BLAS, o qual deve ser listado por \u00faltimo no comando. No meu caso, optei por usar o Open_Blas porque as instala\u00e7\u00f5es dessas bibliotecas podem conflitar entre o uso no Microsoft Visual Studio e no MSYS2 caso esteja no Windows, esteja atento \u00e0 extens\u00e3o instalada na sua m\u00e1quina - Microsoft Studio usa .lib enquanto MinGW/gfortran usam .a / .dll.a.</p> <p>A maior complica\u00e7\u00e3o pode estar na depura\u00e7\u00e3o de erros relacionados a vers\u00f5es de DLLs e compatibilidade com a arquitetura da CPU. Em edi\u00e7\u00f5es futuras, abordaremos a constru\u00e7\u00e3o de pacotes e a compila\u00e7\u00e3o de vers\u00f5es espec\u00edficas da BLAS ou LAPACK para sua m\u00e1quina.</p>"},{"location":"Fortran/Fortran_90/","title":"Fortran 90","text":""},{"location":"Fortran/Fortran_90/#capitulo-1-introducao","title":"Cap\u00edtulo 1 - Introdu\u00e7\u00e3o","text":"<p>Texto introdut\u00f3rio: Neste cap\u00edtulo visamos apresentar a linguagem Fortran (na vers\u00e3o Fortran 90) do zero, supondo pouca familiaridade com programa\u00e7\u00e3o, mas algum conhecimento de m\u00e9todos num\u00e9ricos (n\u00e3o s\u00e3o obrigat\u00f3rios, mas ser\u00e3o de grande ajuda para a compreens\u00e3o de algumas motiva\u00e7\u00f5es e m\u00e9todos). Ao longo deste cap\u00edtulo vamos introduzir os conhecimentos necess\u00e1rios para construirmos um dos m\u00e9todos num\u00e9ricos mais simples e cl\u00e1ssicos: o M\u00e9todo da Bisse\u00e7\u00e3o. E, para al\u00e9m de introduzirmos o ferramental, vamos construir um c\u00f3digo para este m\u00e9todo ao longo das se\u00e7\u00f5es, de forma que ao final do cap\u00edtulo teremos uma implementa\u00e7\u00e3o funcional do m\u00e9todo em Fortran.</p>"},{"location":"Fortran/Fortran_90/#topico-0-caracteristicas-da-linguagem","title":"T\u00f3pico 0: Caracter\u00edsticas da linguagem","text":"<p>Diferen\u00e7as para o Fortran 77 (fixed-form vs free-form), vantagens e desvantagens para algumas aplica\u00e7\u00f5es</p>"},{"location":"Fortran/Fortran_90/#topico-1-compilacao-arquivo-fonte-e-arquivo-executavel","title":"T\u00f3pico 1: Compila\u00e7\u00e3o, arquivo fonte e arquivo execut\u00e1vel","text":"<p>Antes de come\u00e7armos a programar, vamos aprender a como fazer um programa em Fortran ser executado. Vamos come\u00e7ar definindo alguns termos:</p> <ul> <li>C\u00f3digo-fonte: O c\u00f3digo fonte \u00e9 o arquivo escrito na linguagem de   programa\u00e7\u00e3o (no nosso cado, em Fortran). Ele cont\u00e9m as instru\u00e7\u00f5es   do programa, por\u00e9m o computador n\u00e3o sabe executar estes aquivos.   Utilizaremos a extens\u00e3o \".f90\" nos nossos arquivos.</li> </ul> <p>Imagem de c\u00f3digo fonte - Compilador: O compilador \u00e9 o programa respons\u00e1vel por traduzir   as instru\u00e7\u00f5es do nosso c\u00f3digo-fonte para instru\u00e7\u00f5es que o   computador sabe executar. Este programa recebe como entrada o   c\u00f3digo-fonte, e gera um arquivo execut\u00e1vel como sa\u00edda. Utilizaremos   o compilador \"gfortran\".</p> <ul> <li>Arquivo execut\u00e1vel: O arquivo execut\u00e1vel \u00e9 o arquivo que,   efetivamente, ir\u00e1 rodar no computador, executando nosso programa.   Este arquivo n\u00e3o \u00e9 leg\u00edvel para n\u00f3s, humanos, e por isso usamos as   abstra\u00e7\u00f5es de uma linguagem de programa\u00e7\u00e3o.</li> </ul> <p>Imagem de um execut\u00e1vel aberto em um editor de texto</p> <p>Como instalar um compilador (gfortran)</p> <p>Como compilar um c\u00f3digo-fonte utilizando o compilador</p> <p>Executando o arquivo execut\u00e1vel gerado pela compila\u00e7\u00e3o</p>"},{"location":"Fortran/Fortran_90/#topico-2-estrutura-basica-de-um-programa-print-simples-variaveis-e-operacoes-basicas","title":"T\u00f3pico 2: Estrutura b\u00e1sica de um programa, print simples, vari\u00e1veis e opera\u00e7\u00f5es b\u00e1sicas.","text":"<p>Para come\u00e7armos a escrever um programa em Fortran, basta criarmos um arquivo novo em branco, e salv\u00e1-lo com a extens\u00e3o \".f90\".</p> <p>Todo programa v\u00e1lido em Fortran precisa ter um bloco \"program\", com o nome do programa. Dentro deste bloco, temos nosso c\u00f3digo principal a ser executado. Vamos iniciar fazendo um programa cl\u00e1ssico ao come\u00e7armos a aprender uma nova linguagem de programa\u00e7\u00e3o: Um programa que mostra \"Ol\u00e1 mundo!\" (ou \"Hello world!\") na tela e termina sua execu\u00e7\u00e3o.</p> <pre><code>    program exemplo\n        print *, 'Ol\u00e1 mundo!'\n    end program exemplo\n</code></pre> <p>Compilando e executando este programa, o programa imprime na tela \"Ol\u00e1 mundo\" e termina. O nome que segue a palavra chave <code>program</code> \u00e9 o nome do programa, e o bloco \u00e9 terminado por <code>end program</code>.</p> <p>O comando <code>print</code> utiliza um primeiro argumento, que \u00e9 a formata\u00e7\u00e3o, e em seguidas as informa\u00e7\u00f5es a serem mostradas. Como n\u00e3o queremos nenhuma formata\u00e7\u00e3o espec\u00edfica para nossos dados, usamos <code>*</code> como primeiro argumento, e em seguida a string <code>\"Ol\u00e1 mundo!\"</code>.</p>"},{"location":"Fortran/Fortran_90/#topico-21-variaveis","title":"T\u00f3pico 2.1: Vari\u00e1veis","text":"<p>Um dos conceitos mais b\u00e1sicos de programa\u00e7\u00e3o s\u00e3o as vari\u00e1veis. Elas s\u00e3o \u00e1reas de mem\u00f3ria que guardam algum valor. Fortran \u00e9 uma linguagem fortemente tipada, ou seja, para declaramos e usarmos uma vari\u00e1vel precisamos, primeiro, indicar qual o tipo dessa vari\u00e1vel (diferente de Python, por exemplo, que \u00e9 fracamente tipada). Nativamente, existem 5 tipos de vari\u00e1veis em Fortran:</p> <ul> <li><code>integer</code> - para valores inteiros, positivos ou   negativos</li> <li><code>real</code> - para valores em ponto-flutuante (n\u00fameros   fracion\u00e1rios)</li> <li><code>complex</code> - para valores complexos, consistindo de   uma parte real e uma parte imagin\u00e1ria</li> <li><code>character</code> - para texto em geral</li> <li><code>logical</code> - para valores verdade (verdadeiro ou   falso)</li> </ul> <p>Para declaramos uma vari\u00e1vel usamos a sintaxe <code>tipo :: nome</code> , onde <code>tipo</code> \u00e9 o tipo da vari\u00e1vel e <code>nome</code> \u00e9 o nome da vari\u00e1vel. Por exemplo, se quisermos declarar 2 vari\u00e1veis reais <code>x</code> e <code>y</code>, fazemos:</p> <pre><code>    real :: x\n    real :: y\n</code></pre> <p>Nomes de vari\u00e1vel precisam come\u00e7ar por uma letra, e podem ter letras, n\u00fameros e underscores \" <code>_</code>\". N\u00e3o s\u00e3o aceitos caracteres pontuados como \"\u00e9\", \"\u00e3\", \"\u00f3\", etc.</p> <p>Vari\u00e1veis do tipo <code>logical</code> trabalham com os valores <code>.true.</code> e <code>.false.</code> . Alguns compiladores podem permitir convers\u00e3o impl\u00edcita de valores inteiros para l\u00f3gico (i.e. assumir que 0 \u00e9 falso e qualquer n\u00famero inteiro diferente de 0 \u00e9 verdadeiro), mas esse comportamento n\u00e3o \u00e9 o padr\u00e3o da linguagem, n\u00e3o conte sempre com ele, e evite sempre que poss\u00edvel.</p> <p>Exemplos de declara\u00e7\u00e3o de vari\u00e1veis para cada tipo:</p> <pre><code>    program variaveis\n        implicit none\n\n        integer :: i\n        real :: distancia\n        complex :: frequencia\n        character :: inicial\n        logical :: eh_primo\n\n        i = 1\n        distancia = 1.41421356\n        frequencia = (1.0, -0.5)\n        inicial = \"f\"\n        eh_primo = .false.\n    end program variaveis\n</code></pre> <p>Por padr\u00e3o, utilizamos letras min\u00fasculas ao programar, mas a linguagem n\u00e3o \u00e9 sens\u00edvel a CaPiTaLiZa\u00c7\u00e3O, ent\u00e3o mai\u00fasculas e min\u00fasculas podem ser usadas para os tipos e nomes. Por\u00e9m, por quest\u00f5es de organiza\u00e7\u00e3o do c\u00f3digo, seja consistente quanto a isso ao longo do programa.</p> <p>Perceba que a primeira instru\u00e7\u00e3o do nosso programa \u00e9 um <code>implicit none</code>, e \u00e9 por um bom motivo: Devido a influ\u00eancia e heran\u00e7a do Fortran 77, por padr\u00e3o, vari\u00e1veis que come\u00e7am pelas letras I,J,K,L,M,N s\u00e3o do tipo <code>integer</code>, e vari\u00e1veis come\u00e7ando pelas outras letras restantes do alfabeto s\u00e3o do tipo <code>real</code>. Hoje em dia, n\u00e3o se \u00e9 mais recomendado usar essa tipagem impl\u00edcita, que permaneceu apenas por motivos de retrocompatibilidade (ser poss\u00edvel executar c\u00f3digos-fonte antigos utilizando compiladores mais novos, sem ter que alterar o c\u00f3digo). Para indicarmos que n\u00e3o utilizaremos este padr\u00e3o de tipagem impl\u00edcita, inclu\u00edmos a instru\u00e7\u00e3o <code>implicit none</code> no come\u00e7o do programa.</p>"},{"location":"Fortran/Fortran_90/#precisao-de-variaveis","title":"Precis\u00e3o de Vari\u00e1veis","text":"<p>A representa\u00e7\u00e3o de valores reais, em Fortran, \u00e9 feita utilizando ponto flutuante. Nesta forma de representa\u00e7\u00e3o, os n\u00fameros possuem sua parte fracion\u00e1ria armazenada em um tamanho finito de mem\u00f3ria. Por\u00e9m, existem diferentes padr\u00f5es de armazenamento destes n\u00fameros, mas n\u00e3o iremos nos aprofundar neste assunto e abordaremos apenas 2 casos de nosso interesse: Float32 e Float64 - definidos no padr\u00e3o IEE 754. Float32 \u00e9 o padr\u00e3o que reserva 32 bits para armazenamento de um n\u00famero, e possui uma precis\u00e3o de 6 a 9 d\u00edgitos decimais. J\u00e1 o padr\u00e3o Float64 \u00e9 o padr\u00e3o que reserva 64 bits para armazenamento do n\u00famero, possuindo uma precis\u00e3o maior: de 15 a 17 d\u00edgitos decimais.</p> <p>Por padr\u00e3o, Fortran utiliza Float32 para armazenar os n\u00fameros reais no tipo de vari\u00e1vel <code>real</code>. Caso queiramos armazenar valores com maior precis\u00e3o, usando o padr\u00e3o Float64, podemos utilizar um m\u00f3dulo disponibilizado pelos compiladores mais recentes de Fortran (2003/2008 em diante): o <code>iso_fortran_env</code>. Neste m\u00f3dulo, temos a defini\u00e7\u00e3o de v\u00e1rias constantes, sendo algumas delas as de defini\u00e7\u00e3o de precis\u00e3o - conhecidas como \"<code>kind</code> parameters\".</p> <p>Para declararmos uma vari\u00e1vel real com 64 bits de precis\u00e3o, importamos o m\u00f3dulo e declaramos a vari\u00e1vel como <code>real(real64)</code> :</p> <pre><code>    use, intrinsic :: iso_fortran_env\n    implicit none\n\n    real(real64) :: valor\n</code></pre> <p>Essa informa\u00e7\u00e3o \u00e9 expressamente relevante para computa\u00e7\u00f5es de alta precis\u00e3o. Se quisermos representar valores literais em Float64, colocamos \"_real64\" no final do valor. Veja a diferen\u00e7a na precis\u00e3o de representa\u00e7\u00e3o do n\u00famero de Euler:</p> <pre><code>    program euler\n            use, intrinsic :: iso_fortran_env\n            implicit none\n\n            real :: v1\n            real(real64) :: v2\n\n            v1 = exp(1.0)\n            v2 = exp(1.0_real64)\n\n            print *, v1\n            print *, v2\n\n    end program euler\n</code></pre> <p>E temos <code>v1 = 2.71828175</code> e <code>v2 = 2.7182818284590451</code>. No primeiro caso, temos erro no 7\u00ba d\u00edgito, e no segundo apenas no 16\u00ba d\u00edgito. Note que foi preciso chamar a fun\u00e7\u00e3o <code>exp(x)</code> (que retorna $e^x$) passando como argumento um valor de 64 bits, para que ele calculasse uma resposta com 64 bits de precis\u00e3o. Lembre-se disso e tome cuidado para n\u00e3o acabar armazenando, por engano, um resultado gerado por precis\u00e3o simples em uma vari\u00e1vel de precis\u00e3o dupla. No mesmo exemplo:</p> <pre><code>    program euler\n            use, intrinsic :: iso_fortran_env\n            implicit none\n\n            real(real64) :: v3\n            v3 = exp(1.0)\n\n            print *, v3\n\n    end program euler\n</code></pre> <p>Onde <code>v3 = 2.7182817459106445</code> parece ser um valor com precis\u00e3o maior, por estar em uma vari\u00e1vel que \u00e9 capaz de representar n\u00fameros com mais precis\u00e3o, mas cujo o conte\u00fado \u00e9 resultado de uma opera\u00e7\u00e3o em precis\u00e3o simples (ainda h\u00e1 erro no 7\u00ba d\u00edgito da constante).</p>"},{"location":"Fortran/Fortran_90/#topico-22-operacoes-basicas","title":"T\u00f3pico 2.2: Opera\u00e7\u00f5es B\u00e1sicas","text":"<p>Assim como muitas outras linguagens, Fortran vem com alguns operadores aritm\u00e9ticos b\u00e1sicos, tabelados abaixo em ordem de preced\u00eancia:</p> Operador Opera\u00e7\u00e3o ** Exponencia\u00e7\u00e3o * Multiplica\u00e7\u00e3o / Divis\u00e3o + Adi\u00e7\u00e3o - Subtra\u00e7\u00e3o <p>Muito cuidado com a preced\u00eancia dos operadores ao colocar express\u00f5es matem\u00e1ticas grandes no seu c\u00f3digo! Principalmente se elas envolvem fra\u00e7\u00f5es: a express\u00e3o pode acabar calculando uma express\u00e3o diferente da pretendida. Por exemplo, se quisermos calcular uma m\u00e9dia simples entre 3 n\u00fameros, ao escrever:</p> <pre><code>    program media\n        print *, 3 + 4 + 5 / 2\n    end program media\n</code></pre> <p>Temos como resultado <code>9</code>, e n\u00e3o <code>6</code>, pois quem tem a preced\u00eancia maior \u00e9 a divis\u00e3o, ent\u00e3o primeiro \u00e9 avaliado <code>5 / 2</code> e depois s\u00e3o feitas as somas. Para alterar preced\u00eancia de opera\u00e7\u00f5es, envolvemos a express\u00e3o com par\u00eanteses - que possuem a maior preced\u00eancia entre os operadores:</p> <pre><code>    program media\n        print *, (3 + 4 + 5) / 2\n    end program media\n</code></pre> <p>E agora temos o comportamento esperado. Outro detalhe curioso no trecho de c\u00f3digo anterior \u00e9 que a express\u00e3o foi avaliada como igual a <code>9</code>, e n\u00e3o <code>9.5</code> como esperar\u00edamos da aritm\u00e9tica usual. Isto ocorre por outra caracter\u00edstica importante da linguagem: opera\u00e7\u00f5es entre inteiros geram inteiros, opera\u00e7\u00f5es com reais geram reais. N\u00fameros reais s\u00e3o representados com ponto decimal, ainda que sua parte decimal seja toda zero. Essa regra explica o porqu\u00ea de</p> <pre><code>    program divisao\n        print *, 5 / 2\n    end program divisao\n</code></pre> <p>ser avaliado como <code>2</code> , e</p> <pre><code>    program divisao\n        print *, 5.0 / 2\n    end program divisao\n</code></pre> <p>ser avaliado como <code>2.50000000</code> . Portanto, cuidado tamb\u00e9m com os tipos das vari\u00e1veis que voc\u00ea estiver operando e com a formata\u00e7\u00e3o dos n\u00fameros.</p>"},{"location":"Fortran/Fortran_90/#comentarios","title":"Coment\u00e1rios","text":"<p>Apesar de n\u00e3o ser um operador, vamos aproveitar o final desta se\u00e7\u00e3o para falar de coment\u00e1rios. Linhas de coment\u00e1rios s\u00e3o iniciadas por <code>!</code>, e servem para escrever texto que n\u00e3o ser\u00e1 interpretado pelo programa. Coment\u00e1rios s\u00e3o \u00fateis para documentar o que est\u00e1 sendo feito no programa e para guiar as pessoas que forem ler o c\u00f3digo-fonte.</p> <pre><code>    program comentarios\n        implicit none\n        ! Esta linha ser\u00e1 ignorada pelo compilador, escreva o que quiser\n\n        real :: alpha  ! Coeficiente do termo linear\n        real :: beta   ! Coeficiente do termo n\u00e3o-linear\n        real :: x      ! Vari\u00e1vel de entrada\n        real :: y\n\n        alpha = 3.0\n        beta = 1.0\n        x = 1\n\n        ! Calculando a rela\u00e7\u00e3o y(x)\n        y = (alpha * x) + (beta * x * x)\n\n        print *, y\n\n    end program comentarios\n</code></pre> <p>N\u00e3o fa\u00e7a coment\u00e1rios em excesso, pois coment\u00e1rios demais podem prejudicar a legibilidade do c\u00f3digo, mas tamb\u00e9m evite deixar c\u00f3digos totalmente n\u00e3o comentados, j\u00e1 que voc\u00ea pode n\u00e3o se lembrar o que cada linha faz ao revisitar o c\u00f3digo no futuro. Uma dica para achar esse equil\u00edbrio \u00e9 escrever bons nomes de vari\u00e1veis e fun\u00e7\u00f5es, que sejam autodescritivos e dispensem coment\u00e1rios, quando poss\u00edvel. Caso voc\u00ea queira adaptar uma f\u00f3rmula diretamente, querendo manter a nota\u00e7\u00e3o original, voc\u00ea pode comentar as vari\u00e1veis ou a f\u00f3rmula referenciada por exemplo.</p>"},{"location":"Fortran/Fortran_90/#topico-3-funcoes-e-modulos","title":"T\u00f3pico 3: Fun\u00e7\u00f5es e M\u00f3dulos","text":"<p>Este \u00e9 um dos t\u00f3picos mais complexos, mas tamb\u00e9m um dos mais relevantes. Leia com calma e, se preciso, pare, rode e mude o c\u00f3digo. Leia mais de uma vez. {Fazer a introdu\u00e7\u00e3o do T\u00f3pico 3}</p>"},{"location":"Fortran/Fortran_90/#topico-31-funcoes","title":"T\u00f3pico 3.1: Fun\u00e7\u00f5es","text":"<p>Fun\u00e7\u00f5es s\u00e3o um dos objetos mais explorados e utilizados na matem\u00e1tica, e n\u00e3o ser\u00e1 diferente para n\u00f3s. No contexto de programa\u00e7\u00e3o, fun\u00e7\u00f5es trazem modularidade e organiza\u00e7\u00e3o ao c\u00f3digo, permitindo que um trecho de c\u00f3digo possa ser reutilizado em diferentes locais do programa, ou at\u00e9 exportado para outros programas que venhamos futuramente desenvolver.</p> <p>A sintaxe para declara\u00e7\u00e3o de uma fun\u00e7\u00e3o em Fortran segue um padr\u00e3o como o seguinte:</p> <pre><code>    function nome_funcao(arg1, arg2) result(var_result)\n        implicit none\n\n        tipo1, intent(in) :: arg1\n        tipo2, intent(in) :: arg2\n        tipo3 :: var_result\n\n        ! Corpo da fun\u00e7\u00e3o\n\n        return\n\n    end funtion nome_funcao\n</code></pre> <p>Vamos destrinchar cada parte. A declara\u00e7\u00e3o \u00e9 feita em bloco, assim como vimos anteriormente ao criarmos o programa principal com <code>program</code>. Ou seja, come\u00e7amos a declara\u00e7\u00e3o com <code>function nome_funcao</code> e terminamos com <code>end function nome_funcao</code>. Na frente do nome da fun\u00e7\u00e3o, entre par\u00eanteses, listamos os argumentos (ou vari\u00e1veis, no jarg\u00e3o matem\u00e1tico) da fun\u00e7\u00e3o. Podemos colocar quantos argumentos quisermos (at\u00e9 mesmo nenhum). Nesse nosso exemplo, temos 2 argumentos: <code>arg1</code> e <code>arg2</code>. Imediatamente ap\u00f3s, colocamos a palavra reservada <code>result</code> e, em seguida e entre par\u00eanteses, o nome da vari\u00e1vel que ter\u00e1 o valor a ser retornado no final da fun\u00e7\u00e3o, no caso do exemplo, <code>var_result</code>. Um ponto a ser ressaltado: fun\u00e7\u00f5es retornam um, e apenas um, resultado. Mas n\u00e3o se desespere. \u00c9 poss\u00edvel organizar as informa\u00e7\u00f5es de formar a fazer uma fun\u00e7\u00e3o retornar mais de 1 valor, por\u00e9m abordaremos este t\u00f3pico em outro momento. Por enquanto, trabalharemos com estruturas mais simples.</p> <p>Ao analisarmos o corpo da fun\u00e7\u00e3o notamos, inicialmente, temos uma linha <code>implicit none</code>, que tem o comportamento descrito ao final do t\u00f3pico 2.1, e em seguida duas linhas de declara\u00e7\u00e3o de vari\u00e1veis. Estas vari\u00e1veis s\u00e3o os argumentos da fun\u00e7\u00e3o. Por\u00e9m, diferente da declara\u00e7\u00e3o usual vista no t\u00f3pico 2.1, temos um trecho <code>intent(in)</code> no meio da declara\u00e7\u00e3o. A instru\u00e7\u00e3o <code>intent</code> declara quais opera\u00e7\u00f5es (escrita e leitura) ser\u00e3o feitas em uma vari\u00e1vel. Quando colocamos <code>intent(in)</code> na declara\u00e7\u00e3o da vari\u00e1vel, estamos dizendo que esta vari\u00e1vel ser\u00e1 apenas lida, mas n\u00e3o poder\u00e1 ter seu valor sobrescrito pela fun\u00e7\u00e3o. Essa instru\u00e7\u00e3o est\u00e1 certificando mais um padr\u00e3o de fun\u00e7\u00f5es em Fortran: fun\u00e7\u00f5es n\u00e3o devem alterar os argumentos de entrada. Esse padr\u00e3o previne comportamentos inesperados (side effects) e facilita interpreta\u00e7\u00e3o de resultados.</p> <p>Para vermos um exemplo que ilustra a import\u00e2ncia da declara\u00e7\u00e3o de inten\u00e7\u00e3o das vari\u00e1veis, vamos abordar apenas mais um conceito e estudar um caso. Para conseguirmos incorporar uma fun\u00e7\u00e3o em um programa, podemos utilizar, ao final do programa, uma instru\u00e7\u00e3o <code>contains</code> seguida da declara\u00e7\u00e3o da fun\u00e7\u00e3o. Sabendo disso, vejamos um exemplo: Suponha que temos um vetor v = (v1, v2) em R\u00b2, e queremos calcular a norma do dobro desse vetor. Ou seja, se temos o vetor (1, 1), queremos a norma de (2, 2). Vamos construir uma primeira fun\u00e7\u00e3o para isso, n\u00e3o seguindo o padr\u00e3o com <code>intent</code>:</p> <pre><code>    function norma_dobro(v1, v2) result(norma)\n        real :: v1\n        real :: v2\n        real :: norma\n\n        v1 = 2*v1\n        v2 = 2*v2\n\n        norma = ((v1**2) + (v2**2))**(1.0/2.0)\n\n        return\n\n    end function norma_dobro\n</code></pre> <p>Agora, vamos criar um programa e testar nossa fun\u00e7\u00e3o:</p> <pre><code>    program calcula_norma\n        implicit none\n        real :: norma_calculada\n        real :: vec1 !1\u00aa coordenada do vetor\n        real :: vec2 !2\u00aa coordenada do vetor\n\n        vec1 = 1\n        vec2 = 1\n\n        norma_calculada = norma_dobro(vec1, vec2)\n        print *, norma_calculada\n\n        contains\n            function norma_dobro(v1, v2) result(norma)\n                real :: v1\n                real :: v2\n                real :: norma\n\n                v1 = 2*v1\n                v2 = 2*v2\n\n                norma = ((v1**2) + (v2**2))**(1.0/2.0)\n\n                return\n\n            end function norma_dobro\n\n    end program calcula_norma\n</code></pre> <p>Ao executarmos o nosso programa, temos como sa\u00edda:</p> <pre><code>    2.82842708\n</code></pre> <p>Que \u00e9 a norma do vetor (2, 2). A princ\u00edpio, parece que est\u00e1 tudo bem, mas nossa fun\u00e7\u00e3o gerou um efeito colateral e n\u00e3o percebemos isso. Podemos verificar o que aconteceu printando as coordenadas v1, v2 antes e depois da chamada da fun\u00e7\u00e3o:</p> <pre><code>    program calcula_norma\n        implicit none\n        real :: norma_calculada\n        real :: vec1 !1\u00aa coordenada do vetor\n        real :: vec2 !2\u00aa coordenada do vetor\n\n        vec1 = 1\n        vec2 = 1\n\n        print *, vec1\n        print *, vec2\n\n        norma_calculada = norma_dobro(vec1, vec2)\n        print *, norma_calculada\n\n        print *, vec1\n        print *, vec2\n\n        contains\n            function norma_dobro(v1, v2) result(norma)\n                real :: v1\n                real :: v2\n                real :: norma\n\n                v1 = 2*v1\n                v2 = 2*v2\n\n                norma = ((v1**2) + (v2**2))**(1.0/2.0)\n\n                return\n\n            end function norma_dobro\n\n    end program calcula_norma\n</code></pre> <p>E no resultado desse programa:</p> <pre><code>    1.00000000\n    1.00000000\n    2.82842708\n    2.00000000\n    2.00000000\n</code></pre> <p>Podemos perceber que nossa fun\u00e7\u00e3o de c\u00e1lculo de norma mudou os valores do nosso vetor original, que n\u00e3o era nossa inten\u00e7\u00e3o inicial. Isso ocorre pois altera\u00e7\u00f5es em vari\u00e1veis passadas como argumentos em fun\u00e7\u00f5es refletem as altera\u00e7\u00f5es externamente. Vejamos agora o que acontece quando declaramos a fun\u00e7\u00e3o usando <code>intent</code>:</p> <pre><code>    program calcula_norma\n        implicit none\n        real :: norma_calculada\n        real :: vec1 !1\u00aa coordenada do vetor\n        real :: vec2 !2\u00aa coordenada do vetor\n\n        vec1 = 1\n        vec2 = 1\n\n        print *, vec1\n        print *, vec2\n\n        norma_calculada = norma_dobro(vec1, vec2)\n        print *, norma_calculada\n\n        print *, vec1\n        print *, vec2\n\n        contains\n            function norma_dobro(v1, v2) result(norma)\n                real, intent(in) :: v1\n                real, intent(in) :: v2\n                real :: norma\n\n                v1 = 2*v1\n                v2 = 2*v2\n\n                norma = ((v1**2) + (v2**2))**(1.0/2.0)\n\n                return\n\n            end function norma_dobro\n\n    end program calcula_norma\n</code></pre> <p>E ao tentarmos compilar e executar este programa:</p> <pre><code>    ./main.f95:27:3:\n\n             27 |    v1 = 2*v1\n    Error: Dummy argument \u2018v1\u2019 with INTENT(IN) in variable definition\n    context (assignment) at (1)\n    ./main.f95:28:3:\n\n             28 |    v2 = 2*v2\n    Error: Dummy argument \u2018v2\u2019 with INTENT(IN) in variable definition\n    context (assignment) at (1)\n</code></pre> <p>Nosso compilador n\u00e3o finalizou a compila\u00e7\u00e3o pois detectou uma inconsist\u00eancia: Declaramos que v1 e v2 s\u00e3o apenas argumentos de entrada, mas em seguida tentamos modificar o valor dessas vari\u00e1veis. A\u00ed est\u00e1 a import\u00e2ncia do uso do <code>intent</code>: caso n\u00f3s, programadores, acidentalmente fa\u00e7amos uma atribui\u00e7\u00e3o indevida, seremos alertados pelo compilador de que estamos fazendo algo que provavelmente n\u00e3o dever\u00edamos estar fazendo.</p> <p>Para contornar nosso problema da fun\u00e7\u00e3o <code>calcula_norma</code>, podemos:</p> <ol> <li>Criar novas vari\u00e1veis internas da fun\u00e7\u00e3o, que essas sim poder\u00e3o    ser modificadas, copiar o valor dos argumentos originais nestas    vari\u00e1veis e operar com ela; ou</li> <li>Usar os valores originais diretamente no c\u00e1lculo da norma</li> </ol> <p>Na primeira proposta, nossa fun\u00e7\u00e3o ficaria com a seguinte cara:</p> <pre><code>    function norma_dobro(v1, v2) result(norma)\n        real, intent(in) :: v1\n        real, intent(in) :: v2\n\n        real :: coord1\n        real :: coord2\n        real :: norma\n\n        coord1 = v1\n        coord2 = v2\n\n        coord1 = 2*coord1\n        coord2 = 2*coord2\n\n        norma = ((coord1**2) + (coord2**2))**(1.0/2.0)\n\n        return\n\n    end function norma_dobro\n</code></pre> <p>Com a segunda proposta:</p> <pre><code>    function norma_dobro(v1, v2) result(norma)\n        real, intent(in) :: v1\n        real, intent(in) :: v2\n        real :: norma\n\n        norma = (((2*v1)**2) + ((2*v2)**2))**(1.0/2.0)\n\n        return\n\n    end function norma_dobro\n</code></pre> <p>E, com qualquer uma dessas vers\u00f5es, nosso resultado final ao executar o programa ser\u00e1:</p> <pre><code>    1.00000000\n    1.00000000\n    2.82842708\n    1.00000000\n    1.00000000\n</code></pre> <p>Evitamos, assim, altera\u00e7\u00f5es nos dados originais. Dois coment\u00e1rios valem ser feitos: Apesar de ter menos c\u00f3digo, a segunda implementa\u00e7\u00e3o da fun\u00e7\u00e3o \u00e9 bem mais dif\u00edcil de ser entendida do que a primeira implementa\u00e7\u00e3o. Em programas mais complexos, isso pode vir a ser um problema para outros programadores que tentem entender o comportamento da fun\u00e7\u00e3o, e at\u00e9 mesmo para quem escreveu a fun\u00e7\u00e3o ao ler o pr\u00f3prio c\u00f3digo futuramente. Procure fazer c\u00f3digos compreens\u00edveis e, quando preciso, comente linhas mais dif\u00edceis ou relevantes. Segundo ponto: colocar o bloco de fun\u00e7\u00f5es abaixo do programa principal n\u00e3o \u00e9 melhor maneira de organizar o seu c\u00f3digo. A maneira ideal de se fazer esta organiza\u00e7\u00e3o \u00e9 utilizando M\u00f3dulos, que ser\u00e1 nosso pr\u00f3ximo assunto, no t\u00f3pico 3.3.</p>"},{"location":"Fortran/Fortran_90/#topico-32-funcoes-intrinsecas","title":"T\u00f3pico 3.2: Fun\u00e7\u00f5es Intr\u00ednsecas","text":"<p>Fortran j\u00e1 existe a muito tempo, e \u00e9 utilizado para diversos fins. Por\u00e9m, como v\u00e1rias delas acabaram por precisar de fun\u00e7\u00f5es comuns entre elas, a linguagem j\u00e1 implementa algumas destas fun\u00e7\u00f5es para nos poupar de ter que defini-las n\u00f3s mesmos. Buscando por \"Intrinsic functions in Fortran 90\" na internet, voc\u00ea vai encontrar algumas rela\u00e7\u00f5es/listas destas fun\u00e7\u00f5es. Alguns dos exemplos de fun\u00e7\u00f5es ofertadas s\u00e3o:</p> <ul> <li>Valor Absoluto - <code>ABS</code></li> <li>M\u00e1ximo - <code>MAX</code></li> <li>Logaritmo Natural - <code>LOG</code></li> <li>Exponencial - <code>EXP</code></li> <li>Raiz Quadrada - <code>SQRT</code></li> <li>Cosseno - <code>COS</code></li> <li>Arco tangente - <code>ATAN</code></li> <li>Conjugado Complexo - <code>CONJG</code>, etc</li> </ul> <p>Normalmente, as implementa\u00e7\u00f5es destas fun\u00e7\u00f5es s\u00e3o uma das melhores poss\u00edveis (geralmente s\u00e3o r\u00e1pidas!). Ent\u00e3o, quando for criar uma fun\u00e7\u00e3o simples pro seu c\u00f3digo, veja se ela j\u00e1 \u00e9 oferecida nativamente pela linguagem. Se sim, d\u00ea prioridade a implementa\u00e7\u00e3o nativa.</p>"},{"location":"Fortran/Fortran_90/#topico-33-modulos","title":"T\u00f3pico 3.3: M\u00f3dulos","text":"<p>M\u00f3dulos, como o pr\u00f3prio nome sugere, trazem modularidade ao programa. Ao subdividirmos um grande programa em componentes menores, facilitamos a manuten\u00e7\u00e3o e a eventual reutiliza\u00e7\u00e3o desses componentes em outros programas. Dessa forma, fun\u00e7\u00f5es que s\u00e3o utilizadas em v\u00e1rios programas diferentes s\u00f3 precisar\u00e3o ser escritas uma vez e reutilizadas sempre que poss\u00edvel. Al\u00e9m disso, voc\u00ea s\u00f3 precisar\u00e1 alterar 1 trecho que c\u00f3digo para aplicar a mudan\u00e7a em v\u00e1rios programas de uma s\u00f3 vez (em vez de fazer a altera\u00e7\u00e3o programa a programa).</p> <p>A sintaxe da declara\u00e7\u00e3o de um m\u00f3dulo segue um padr\u00e3o como o seguinte:</p> <pre><code>    module nome_do_modulo\n        implicit none\n\n    contains\n        ! Aqui come\u00e7a o bloco de declara\u00e7\u00e3o de\n        ! fun\u00e7\u00f5es, vari\u00e1veis, e o que mais quisermos\n\n    end module nome_do_modulo\n</code></pre> <p>E, para usarmos um m\u00f3dulo em um programa, inclu\u00edmos uma linha <code>use nome_do_modulo</code> logo abaixo da primeira linha do programa. Para o nosso exemplo do t\u00f3pico anterior, podemos criar um m\u00f3dulo de normas, e teremos um programa reestruturado da seguinte forma:</p> <pre><code>    module normas\n        implicit none\n\n    contains\n        function norma_do_dobro(v1, v2) result(norma)\n                real, intent(in) :: v1\n                real, intent(in) :: v2\n\n                real :: coord1\n                real :: coord2\n                real :: norma\n\n                coord1 = v1\n                coord2 = v2\n\n                coord1 = 2*coord1\n                coord2 = 2*coord2\n\n                norma = sqrt((coord1**2) + (coord2**2))\n\n                return\n\n        end function norma_do_dobro\n    end module funcs\n\n    program calcula_norma\n        use normas\n        implicit none\n        real :: norma_calculada\n        real :: vec1 !1\u00aa coordenada do vetor\n        real :: vec2 !2\u00aa coordenada do vetor\n\n        vec1 = 1\n        vec2 = 1\n\n        print *, vec1\n        print *, vec2\n\n        norma_calculada = norma_do_dobro(vec1, vec2)\n        print *, norma_calculada\n\n        print *, vec1\n        print *, vec2\n\n    end program calcula_norma\n</code></pre> <p>Desta forma, agrupamos fun\u00e7\u00f5es parecidas, ou de mesmo contexto, sem mistur\u00e1-las com todas as outras fun\u00e7\u00f5es do c\u00f3digo. Al\u00e9m disso, veremos posteriormente como m\u00f3dulos podem ser importados e exportados entre diferentes programas, ao declar\u00e1-los em arquivos separados e us\u00e1-los em nossos programas.</p>"},{"location":"Fortran/Fortran_90/#topico-4-estruturas-condicionais-if-then-else","title":"T\u00f3pico 4: Estruturas Condicionais: IF - THEN - ELSE","text":"<p>J\u00e1 sabemos como montar um programa que executa do come\u00e7o ao fim de acordo com um procedimento inicialmente bem determinado. Mas e se o comportamento do programa puder variar no meio da execu\u00e7\u00e3o, dependendo da entrada fornecida? N\u00e3o saberemos de antem\u00e3o como o programa ir\u00e1 executar, mas podemos preparar o c\u00f3digo para fazer as decis\u00f5es em tempo de execu\u00e7\u00e3o. Para fazermos isso, vamos ver como funcionam os desvios condicionais.</p>"},{"location":"Fortran/Fortran_90/#topico-41-operadores-logicos","title":"T\u00f3pico 4.1: Operadores L\u00f3gicos","text":"<p>Vimos anteriormente operadores aritm\u00e9ticos (+, -, *, etc) e como operam valores num\u00e9ricos. Mas, quando a \u00e1lgebra em quest\u00e3o \u00e9 a \u00e1lgebra de Boole, precisamos de novos operadores que lidam com os valores verdade <code>.true.</code> e <code>.false.</code>.</p> <p>Para formarmos express\u00f5es l\u00f3gicas, podemos utilizar os operadores:</p> Operador Opera\u00e7\u00e3o == Verifica se os 2 operandos s\u00e3o iguais /= Verifica se os 2 operandos s\u00e3o diferentes &gt; Verifica se o operando \u00e0 esquerda \u00e9 maior que o da direita &lt; Verifica se o operando \u00e0 esquerda \u00e9 menor que o da direita &gt;= Verifica se o operando \u00e0 esquerda \u00e9 maior ou igual ao da &lt;= Verifica se o operando \u00e0 esquerda \u00e9 menor ou igual ao dadireita <p>Estes operadores ir\u00e3o retornar valores <code>.true.</code> ou <code>.false.</code>, e podemos operar estes valores com os operadores booleanos:</p> Operador Opera\u00e7\u00e3o .and. Realiza um \"E\" l\u00f3gico .or. Realiza um \"OU\" l\u00f3gico .not. Realiza um \"N\u00c3O\" l\u00f3gico <p>Com isso, podemos fazer alguns testes como: Se um certo valor \u00e9 maior que 0, se 2 valores s\u00e3o iguais, etc.</p>"},{"location":"Fortran/Fortran_90/#topico-42-comando-if-then-else","title":"T\u00f3pico 4.2: Comando IF-THEN-ELSE","text":"<p>Agora que sabemos como montar e comparar express\u00f5es l\u00f3gicas, vamos us\u00e1-las com o comando IF-THEN-ELSE. A sintaxe do comando \u00e9:</p> <pre><code>    if (expressao_logica) then\n        ! C\u00f3digo a ser executado se a express\u00e3o for verdadeira\n    else\n        ! C\u00f3digo a ser executado se a express\u00e3o for falsa\n    end if\n</code></pre> <p>O trecho <code>else</code> pode ser omitido, caso n\u00e3o haja nenhum caso expl\u00edcito para a condi\u00e7\u00e3o falsa. E com isso, conseguimos implementar v\u00e1rias fun\u00e7\u00f5es que s\u00e3o definidas por parte, como:</p> <p>Fun\u00e7\u00e3o Valor Absoluto</p> <pre><code>    function absoluto(x) result(y)\n        real, intent(in) :: x\n        real :: y\n\n        y = x\n\n        if (x &lt; 0) then\n                y = -y\n        end if\n\n        return\n\n    end function absoluto\n</code></pre> <p>Fun\u00e7\u00e3o de Heaviside</p> <pre><code>    function heaviside(x) result(y)\n        real, intent(in) :: x\n        real :: y\n\n        if (x &gt;= 0) then\n                y = 1\n        else\n                y = 0\n        end if\n\n        return\n\n    end function heaviside\n</code></pre> <p>E assim por diante. Dica de programa\u00e7\u00e3o: evite colocar muitos IF's aninhados uns dentro dos outros, pois isso costuma dificultar a leitura do c\u00f3digo. Evite tamb\u00e9m colocar express\u00f5es muito longas no teste do IF, e tome cuidado com a preced\u00eancia das opera\u00e7\u00f5es (use par\u00eanteses, na d\u00favida). Aqui um exemplo de um bloco dif\u00edcil de entender devido a IF's aninhados:</p> <pre><code>    real, intent(in):: a\n    real, intent(in):: b\n    real, intent(in):: p\n\n    if (p &gt;= a) then\n        if (p &lt;= b) then\n            if (p == (a+b)/2 ) then\n                print *, \"p est\u00e1 no intervalo e \u00e9 ponto medio\"\n            else\n                if (p &gt; (a+b)/2) then\n                    print *, \"p est\u00e1 no intervalo, e est\u00e1 mais pr\u00f3ximo de\", b\n                else\n                    print *, \"p est\u00e1 no intervalo, e est\u00e1 mais pr\u00f3ximo de\", a\n                end if\n            end if\n        else\n            print *, \"p est\u00e1 fora do intervalo, e depois de\", b\n        end if\n    else\n        print *, \"p est\u00e1 fora do intervalo, e antes de\", a\n    end if\n</code></pre> <p>Perceba que voc\u00ea precisa manter os estados l\u00f3gicos na sua cabe\u00e7a para acompanhar a execu\u00e7\u00e3o. Para resolver estes problemas, geralmente aplicamos uma de duas t\u00e9cnicas: Invers\u00e3o L\u00f3gica ou Extra\u00e7\u00e3o em Fun\u00e7\u00e3o. Na primeira, usamos o teste l\u00f3gico inverso combinados com <code>return</code>, de forma que daquele trecho em diante, sabemos que n\u00e3o estamos mais naquele caso. O segundo m\u00e9todo consiste em extrair subtestes em fun\u00e7\u00f5es separadas, que realizam a l\u00f3gica internamente, e apenas chamar estas fun\u00e7\u00f5es no nosso bloco de IF. Veja como fica o c\u00f3digo acima utilizando a primeira t\u00e9cnica:</p> <pre><code>    real, intent(in):: a\n    real, intent(in):: b\n    real, intent(in):: p\n\n    if (p &lt; a) then\n        print *, \"p est\u00e1 fora do intervalo, e antes de\", a\n        return\n    end if\n\n    if (p &gt; b) then\n        print *, \"p est\u00e1 fora do intervalo, e depois de\", b\n        return\n    end if\n\n    if (p == (a+b)/2 ) then\n        print *, \"p est\u00e1 no intervalo e \u00e9 ponto medio\"\n        return\n    end if\n\n    ! Neste ponto, sabemos que p est\u00e1 no intervalo e n\u00e3o \u00e9 ponto m\u00e9dio\n    if (p &gt; (a+b)/2) then\n        print *, \"p est\u00e1 no intervalo, e est\u00e1 mais pr\u00f3ximo de\", b\n    else\n        print *, \"p est\u00e1 no intervalo, e est\u00e1 mais pr\u00f3ximo de\", a\n    end if\n\n    return\n</code></pre> <p>Bem melhor de acompanhar, n\u00e3o \u00e9? Usando a segunda t\u00e9cnica poder\u00edamos, por exemplo, extrair o bloco que testa se <code>p</code> est\u00e1 dentro do intervalo [a, b] em uma fun\u00e7\u00e3o, e verificar as outras propriedades no nosso IF ap\u00f3s chamar esta fun\u00e7\u00e3o. Caso queira, fa\u00e7a este segundo caso como exerc\u00edcio. Em alguns outros cen\u00e1rios, esta segunda t\u00e9cnica pode fazer mais sentido que a primeira, e vice versa.</p>"},{"location":"Fortran/Fortran_90/#topico-5-repeticao-comando-do","title":"T\u00f3pico 5: Repeti\u00e7\u00e3o - Comando DO","text":"<p>Uma das maiores vantagens de se utilizar um computador para fazer contas, al\u00e9m da velocidade, \u00e9 que, diferente de n\u00f3s seres humanos, m\u00e1quinas podem fazer tarefas repetitivas por longas horas sem enjoarem. Portanto, deixemos essas tarefas para o computador sempre que poss\u00edvel, poupando a n\u00f3s, programadores humanos, dessa tarefa. E, para isso, podemos utilizar o comando DO.</p> <p>A sintaxe do comando \u00e9:</p> <pre><code>    do iterador = valor_inicial, valor_final, passo\n        ! C\u00f3digo a ser repetido\n    end do\n</code></pre> <p>Onde: <code>iterador</code> \u00e9 a vari\u00e1vel de itera\u00e7\u00e3o da repeti\u00e7\u00e3o, <code>valor_inicial</code> \u00e9 o primeiro valor que o iterador assumir\u00e1, <code>valor_final</code> \u00e9 o \u00faltimo valor que a vari\u00e1vel pode assumir e <code>passo</code> \u00e9 o incremento que ser\u00e1 feito a cada rodada de repeti\u00e7\u00e3o. O exemplo mais comum na matem\u00e1tica? Somat\u00f3rios. Digamos que queremos fazer um somat\u00f3rio de 1 at\u00e9 n da express\u00e3o $1/k^2$, como far\u00edamos? Desta forma:</p> <pre><code>    implicit none\n\n    real :: valor\n    integer :: k\n    integer :: n\n\n    valor = 0.0\n    n = 100\n    do k = 1, n, 1\n        valor = valor + 1.0/(k*k)\n    end do\n\n    print *, valor\n</code></pre> <p>E com 3 linhas fizemos 100 opera\u00e7\u00f5es (o valor de <code>n</code> neste exemplo), tal qual uma nota\u00e7\u00e3o de somat\u00f3rio dispensa escrevermos 100 somas por extenso. Algumas observa\u00e7\u00f5es sobre este trecho de c\u00f3digo:</p> <ul> <li>Come\u00e7amos iniciando a vari\u00e1vel <code>valor</code> com 0.0, para   garantir que n\u00e3o havia nenhum lixo de mem\u00f3ria da vari\u00e1vel   rec\u00e9m-criada. Crie o h\u00e1bito de inicializar vari\u00e1veis antes de   us\u00e1-las, especialmente em situa\u00e7\u00f5es onde ser\u00e3o utilizadas para   ac\u00famulos.</li> <li>O passo de itera\u00e7\u00e3o padr\u00e3o do comando <code>do</code> \u00e9 1.   Logo, \u00e9 equivalente escrever <code>do k = 1, n, 1</code> ou   <code>do k = 1, n</code></li> <li>Por fim, cuidado com a precis\u00e3o das vari\u00e1veis e seus tamanhos   m\u00e1ximos e m\u00ednimos ao fazer muitas opera\u00e7\u00f5es com elas, ou que   envolvam n\u00fameros muito grandes, ou muito pequenos. Pode ser que   voc\u00ea se depare com um resultado estranho mesmo com um c\u00f3digo que   deveria funcionar, devido ao fato dos n\u00fameros terem ficado grandes   demais ou pequenos demais para o tamanho de representa\u00e7\u00e3o suportado   pelas vari\u00e1veis</li> </ul> <p>Para este \u00faltimo ponto, podemos utilizar o pr\u00f3prio trecho de c\u00f3digo acima para nos deparamos com problemas do tipo. O somat\u00f3rio expresso neste trecho converge para \u03c0\u00b2/6, que \u00e9 aproximadamente igual a 1,6449340668482264. Vamos testar diferentes valores de <code>n</code> no c\u00f3digo, para ver a converg\u00eancia:</p> <ul> <li>Para n = $10^2$ temos valor = 1.63498402</li> <li>Para n = $10^3$ temos valor = 1.64393485</li> <li>Para n = $10^4$ temos valor = 1.64472532</li> <li>Para n = $10^5$ temos valor = Infinity</li> </ul> <p>A soma divergiu! Ora, mas nosso c\u00f3digo estava coerente at\u00e9 $10^4$ e a teoria diz que a soma converge. Qual foi o problema? as vari\u00e1veis <code>k</code> e <code>valor</code> s\u00e3o dos tipos <code>integer</code> e <code>real</code> que, por padr\u00e3o (em FORTRAN 90), s\u00e3o de 32 bits! Quando <code>k</code> assume valores pr\u00f3ximos de $10^5$, temos do denominador $10^5 \\times 10^5 = 10^{10} \u2248 2^{33}$, que \u00e9 um n\u00famero maior do que os $2^{32}$ represent\u00e1veis em uma vari\u00e1vel do tipo Float32 (vide T\u00f3pico 2.1). Se representarmos nossas vari\u00e1veis com mais precis\u00e3o (64 bits):</p> <pre><code>    use, intrinsic :: iso_fortran_env\n    implicit none\n\n    real(real64) :: valor\n    integer(int64) :: k\n    integer(int64) :: n\n\n    valor = 0.0\n    n = 10**5_int64\n    do k = 1, n\n            valor = valor + 1.0_real64/(k*k)\n    end do\n\n    print *, valor\n</code></pre> <p>E agora sim temos sa\u00eddas que continuam convergindo:</p> <ul> <li>Para n = $10^5$ temos valor = 1.6449240668982423</li> <li>Para n = $10^6$ temos valor = 1.6449330668487701</li> <li>Para n = $10^7$ temos valor = 1.6449339668472596</li> <li>Para n = $10^8$ temos valor = 1.6449340578345750</li> </ul> <p>Detalhe: n\u00e3o \u00e9 permitido andar com passos fracion\u00e1rios, como 0.5, apenas passos inteiros. Caso deseja iterar desta forma, \u00e9 preciso construir uma itera\u00e7\u00e3o inteira que nos permita, internamente, representar a itera\u00e7\u00e3o fracion\u00e1ria. Por exemplo, se queremos avaliar uma express\u00e3o de 0 at\u00e9 1 com passo 0.1, n\u00e3o \u00e9 poss\u00edvel fazer</p> <pre><code>    do k = 0, 1, 0.1\n            print *, k\n    end do\n</code></pre> <p>Mas podemos fazer:</p> <pre><code>    do k = 0, 10, 1\n            print *, k/10.0\n    end do\n</code></pre> <p>Uma outra dica \u00fatil e que reflete nas possibilidades de uso do comando <code>do</code> \u00e9 que voc\u00ea pode andar com passos negativos, como -1, desde que tamb\u00e9m sejam inteiros. No caso da nossa soma que $1/k^2$, pode ser \u00fatil que somemos dos menores n\u00fameros para os maiores, com o objetivo de somar as contribui\u00e7\u00f5es das menores parcelas da soma primeiro, e as maiores depois. Esta t\u00e9cnica pode aumentar a precis\u00e3o dos c\u00e1lculos devido o n\u00e3o-desperd\u00edcio de precis\u00e3o.</p> <p>Desta forma, o mais adequado, para o nosso exemplo seria somarmos come\u00e7ando de <code>n</code> e terminando em 1, j\u00e1 que $1/n^2$ \u00e9 o menor n\u00famero da soma, e cada um anterior \u00e9 ligeiramente maior. Sendo assim, nosso somat\u00f3rio ficaria de tr\u00e1s pra frente:</p> <pre><code>    use, intrinsic :: iso_fortran_env\n    implicit none\n\n    real(real64) :: valor\n    integer(int64) :: k\n    integer(int64) :: n\n\n    valor = 0.0\n    n = 10**5_int64\n    do k = n, 1, -1\n            valor = valor + 1.0_real64/(k*k)\n    end do\n\n    print *, valor\n</code></pre> <p>E conseguimos ver o impacto na precis\u00e3o ao comparamos os casos de 10\u2078 e 10\u2079 em ambas as abordagens:</p> <p>Primeira abordagem:</p> <ul> <li>Para n = $10^8$ temos valor = 1.6449340578345750, erro absoluto   da aproxima\u00e7\u00e3o = 9.0136513808403151E-009</li> <li>Para n = $10^9$ temos valor = 1.6449340578345750, erro absoluto   da aproxima\u00e7\u00e3o = 9.0136513808403151E-009</li> </ul> <p>Segunda abordagem:</p> <ul> <li>Para n = $10^8$ temos valor = 1.6449340568482265, erro absoluto   da aproxima\u00e7\u00e3o = 9.9999999392252903E-009</li> <li>Para n = $10^9$ temos valor = 1.6449340658482263, erro absoluta   do aproxima\u00e7\u00e3o = 1.0000000827403710E-009</li> </ul> <p>E observamos que n\u00e3o continuamos convergindo utilizando a primeira abordagem, enquanto na segunda sim.</p> <p>OBS: Existem formas muito mais eficientes de se aproximar $\\pi^2/6$, o exemplo acima \u00e9 meramente did\u00e1tico.</p>"},{"location":"Fortran/Fortran_90/#topico-6-subrotinas","title":"T\u00f3pico 6: Subrotinas","text":"<p>Neste t\u00f3pico abordaremos o \u00faltimo assunto antes de partirmos para nossa constru\u00e7\u00e3o e implementa\u00e7\u00e3o do M\u00e9todo da Bisse\u00e7\u00e3o. No t\u00f3pico 3 abordamos fun\u00e7\u00f5es e m\u00f3dulos, e vimos que uma das caracter\u00edsticas padronizadas das fun\u00e7\u00f5es \u00e9 que elas n\u00e3o alteram os argumentos de entrada. E para usar livremente os valores dos argumentos de entrada, criamos vari\u00e1veis auxiliares dentro do corpo da fun\u00e7\u00e3o para armazenarem c\u00e1lculos intermedi\u00e1rios. Por\u00e9m nem sempre isso \u00e9 vi\u00e1vel ou desejado, e gostar\u00edamos de alterar os valores passados como argumento. Vale lembrar tamb\u00e9m que fun\u00e7\u00f5es retornam apenas 1 \u00fanico valor. Para contornar estas limita\u00e7\u00f5es de uso, temos as Subrotinas.</p> <p>Subrotinas possuem comportamento e estrutura muito parecidos com fun\u00e7\u00f5es. A sintaxe para declara\u00e7\u00e3o de uma subrotina \u00e9:</p> <pre><code>    subroutine nome_subrotina(arg1, arg2, arg3)\n        implicit none\n\n        tipo1, intent(in) :: arg1\n        tipo2, intent(inout) :: arg2\n        tipo3, intent(out) :: arg3\n\n        ! Corpo da subrotina\n\n        return\n    end subroutine\n</code></pre> <p>Que \u00e9 muito semelhante a declara\u00e7\u00e3o de uma fun\u00e7\u00e3o, mas com algumas diferen\u00e7as:</p> <ol> <li>N\u00e3o h\u00e1 <code>result</code> no cabe\u00e7alho, pois subrotinas n\u00e3o    retornam valores. Neste caso, \u00e9 preciso passar como argumento a(s)    vari\u00e1vel(eis) onde ser\u00e3o escritos os valores de retorno</li> <li>Os argumentos n\u00e3o necessariamente s\u00e3o apenas para leitura    ( <code>intent(in)</code>), mas podem ser pra leitura e escrita (    <code>intent(inout)</code>) ou apenas escrita    ( <code>intent(out)</code>)</li> <li>Subrotinas s\u00e3o chamadas por <code>call nome_subrotina</code>, e    n\u00e3o apenas o nome do procedimento, como \u00e9 o caso das fun\u00e7\u00f5es</li> </ol> <p>Tal qual nas fun\u00e7\u00f5es, podemos ter quantos argumentos quisermos. No exemplo, temos 3 argumentos na rotina. Para exemplificar os conceitos acima, vamos estruturar uma subrotina que resolva o seguinte problema: dado dois n\u00fameros consecutivos da sequ\u00eancia de fibonacci  $F(n)$ e $F(n+1)$, retornamos $F(n+1)$ e $F(n+2)$.</p> <pre><code>    subroutine fib(f1, f2)\n        integer, intent(inout):: f1\n        integer, intent(inout):: f2\n        integer :: prox\n\n        prox = f1 + f2\n\n        f1 = f2\n        f2 = prox\n\n    end subroutine fib\n</code></pre> <p>Destrinchando o c\u00f3digo:</p> <ol> <li>Come\u00e7amos definindo que nossos par\u00e2metros da subrotina ser\u00e3o    utilizados tanto para leitura quanto para escrita, al\u00e9m de    definirmos todas as outras vari\u00e1veis intermedi\u00e1rias que    utilizaremos na subrotina.</li> <li>Calculamos $F(n+2)$ utilizando $F(n+1)$ e $F(n)$, e guardamos o    resultado numa vari\u00e1vel intermedi\u00e1ria</li> <li>Atualizamos os valores de <code>f1</code> e <code>f2</code>, e terminamos a    subrotina</li> </ol> <p>Perceba que, diferente das fun\u00e7\u00f5es, n\u00e3o h\u00e1 <code>return</code> e os par\u00e2metros passados sofrem altera\u00e7\u00e3o. Podemos testar o c\u00f3digo chamando a subrotina m\u00faltiplas vezes e exibindo a sequ\u00eancia gerada:</p> <pre><code>    module funcs\n        implicit none\n\n    contains\n        subroutine fib(f1, f2)\n            integer, intent(inout):: f1\n            integer, intent(inout):: f2\n            integer ::      prox\n\n            prox = f1 + f2\n\n            f1 = f2\n            f2 = prox\n\n        end subroutine fib\n    end module funcs\n\n    program test\n        use funcs\n        implicit none\n\n        integer :: f1\n        integer :: f2\n        integer :: i\n\n        f1 = 1\n        f2 = 1\n\n        do i = 1, 10\n            print *, f1, f2\n\n            call fib(f1, f2)\n        end do\n    end program test\n</code></pre> <p>E temos como sa\u00edda:</p> <pre><code>     1           1\n     1           2\n     2           3\n     3           5\n     5           8\n     8          13\n    13          21\n    21          34\n    34          55\n    55          89\n</code></pre> <p>E notamos que a cada chamada da subrotina as vari\u00e1veis <code>f1</code> e <code>f2</code> v\u00e3o tendo seus valores alterados e utilizados nas chamadas seguintes.</p>"},{"location":"Fortran/Fortran_90/#topico-7-construindo-o-metodo-da-bissecao","title":"T\u00f3pico 7: Construindo o M\u00e9todo da Bisse\u00e7\u00e3o","text":"<p>Com as t\u00e9cnincas e estruturas apresentadas nos t\u00f3picos anteriores, agora temos o que precisamos para constru\u00edrmos nossa primeira vers\u00e3o do M\u00e9todo da Bisse\u00e7\u00e3o. Esta primeira vers\u00e3o ser\u00e1 melhorada/modificada nos t\u00f3picos seguintes, por motivos que abordaremos ao final desta sess\u00e3o. Vamos come\u00e7ar relembrando/definindo a ideia algor\u00edtmica do m\u00e9todo em alto n\u00edvel de abstra\u00e7\u00e3o. Em suma, o m\u00e9todo da bisse\u00e7\u00e3o segue os seguintes passos:</p> <ol> <li>Come\u00e7amos informando a fun\u00e7\u00e3o que queremos encontrar o 0, e o    intervalo onde iremos come\u00e7ar a busca</li> <li>Calculamos o ponto m\u00e9dio do intervalo</li> <li>Verificamos se a fun\u00e7\u00e3o neste ponto \u00e9 0</li> <li>Se sim, retornamos este ponto e terminamos</li> <li>Se n\u00e3o, analisamos o sinal da fun\u00e7\u00e3o neste ponto e determinamos    um novo intervalo</li> <li>Repetimos, a partir do passo 2, at\u00e9 um crit\u00e9rio de parada (como    um n\u00famero m\u00e1ximo de passos), para evitarmos um loop infinito.</li> </ol> <p>Vamos contruir este programa utilizando a seguinte abordagem: come\u00e7amos escrevendo as partes centrais do c\u00f3digo primeiro, supondo que dispomos de todas as estruturas intermedi\u00e1rias e fun\u00e7\u00f5es necess\u00e1rias. Ou seja, vamos escrever o c\u00f3digo usando, por exemplo, uma fun\u00e7\u00e3o \"<code>abc(x)</code>\"  sem termos definido \"<code>abc</code>\" ainda, e tendo conclu\u00eddo o c\u00f3digo principal  definimos \"<code>abc</code>\" (pois se n\u00e3o o c\u00f3digo n\u00e3o funcionar\u00e1).</p>"},{"location":"Fortran/Fortran_90/#topico-71-arquitetando-o-codigo","title":"T\u00f3pico 7.1: Arquitetando o c\u00f3digo","text":"<p>Vamos pensar nas estruturas a serem utilizadas em cada passo.</p>"},{"location":"Fortran/Fortran_90/#1-comecamos-informando-a-funcao-que-queremos-encontrar-o-0-e-o-intervalo-onde-iremos-comecar-a-busca","title":"1. Come\u00e7amos informando a fun\u00e7\u00e3o que queremos encontrar o 0, e o intervalo onde iremos come\u00e7ar a busca","text":"<ul> <li>Neste primeiro passo, precisamos pensar em como forneceremos os   dados de entrada. N\u00e3o queremos que nosso programa seja espec\u00edfico   para uma fun\u00e7\u00e3o, mas sim para um grande conjunto de fun\u00e7\u00f5es. Vamos,   portanto, fazer um m\u00f3dulo a parte do programa principal, que seja   importado pelo programa e disponibilize essas fun\u00e7\u00f5es quando   necess\u00e1rias. Para fins de teste, vamos declarar um polin\u00f4mio  $f(x) =  x^3 - x - 2$ como fun\u00e7\u00e3o neste m\u00f3dulo.</li> </ul> <pre><code>    module funcoes\n        implicit none\n\n    contains\n        ! Polin\u00f4mio: x^3 - x - 2\n        function f(x) result(y)\n            real, intent(in) :: x\n            real :: y\n\n            y = x**3 - x - 2\n        end function f\n    end module funcoes\n</code></pre> <ul> <li>J\u00e1 o intervalo gostar\u00edamos de ter maior liberdade de escolha,   pois podemos fazer v\u00e1rias escolhas de onde come\u00e7ar a busca. Vamos,   ent\u00e3o, definir no programa as vari\u00e1veis a serem utilizadas,   que nomearemos <code>a</code> e <code>b</code>.</li> </ul> <pre><code>    program main\n        use funcoes\n\n        use, intrinsic :: iso_fortran_env\n        implicit none\n\n        real(real64) :: resultado\n        real(real64) :: a = 1\n        real(real64) :: b = 2\n\n\n    end program main\n</code></pre> <ul> <li>Por fim, percebendo que o m\u00e9todo recebe como entrada um conjunto de valores   e retorna como resultado um \u00fanico valor (um $x$ tal que $f(x) = 0$), podemos modelar o   m\u00e9todo como uma fun\u00e7\u00e3o. Por quest\u00e3o de organiza\u00e7\u00e3o, vamos colocar o   m\u00e9todo num m\u00f3dulo pr\u00f3prio e us\u00e1-lo no programa principal. Vamos   escolher, por conveni\u00eancia, trabalhar com precis\u00e3o dupla.</li> </ul> <pre><code>    module metodos\n        use funcoes\n        implicit none\n\n    contains\n        function bissecao(a, b) result(raiz)\n              ! Limite inferior do intervalo\n              real(real64), intent(in) :: a\n\n              ! Limite superior do intervalo\n              real(real64), intent(in) :: b\n\n              ! Valor de x tal que f(x) = 0\n              real(real64) :: raiz\n\n        end function bissecao\n    end module metodos\n\n    program main\n        use funcoes\n        use metodos\n        use, intrinsic :: iso_fortran_env\n        implicit none\n\n        real(real64) :: resultado\n        real(real64) :: a = 1\n        real(real64) :: b = 2\n\n        resultado = bissecao(a, b)\n    end program main\n</code></pre>"},{"location":"Fortran/Fortran_90/#2-calculamos-o-ponto-medio-do-intervalo","title":"2. Calculamos o ponto m\u00e9dio do intervalo","text":"<p>Aqui criamos uma vari\u00e1vel a mais em nossa fun\u00e7\u00e3o da bisse\u00e7\u00e3o e realizamos a m\u00e9dia simples dos limites do intervalo para calcular o ponto m\u00e9dio.  Para evitar reexibir todo o c\u00f3digo, vamos mostrar apenas a fun\u00e7\u00e3o de bissecao, que ser\u00e1 alterada:</p> <pre><code>    function bissecao(a, b) result(raiz)\n        ! Limite inferior do intervalo\n        real(real64), intent(in) :: a\n\n        ! Limite superior do intervalo\n        real(real64), intent(in) :: b\n\n        ! Valor de x tal que f(x) = 0\n        real(real64) :: raiz\n\n        ! Ponto m\u00e9dio\n        real(real64) :: p_medio\n\n        p_medio = (a+b)/2\n\n    end function bissecao\n</code></pre>"},{"location":"Fortran/Fortran_90/#3-verificamos-se-a-funcao-neste-ponto-e-0","title":"3. Verificamos se a fun\u00e7\u00e3o neste ponto \u00e9 0.","text":""},{"location":"Fortran/Fortran_90/#4-se-sim-retornamos-este-ponto-e-terminamos","title":"4. Se sim, retornamos este ponto e terminamos","text":"<p>Estes 2 passos podem ser feitos por um teste condicional</p> <pre><code>    function bissecao(a, b) result(raiz)\n        ! Limite inferior do intervalo\n        real(real64), intent(in) :: a\n\n        ! Limite superior do intervalo\n        real(real64), intent(in) :: b\n\n        ! Valor de x tal que f(x) = 0\n        real(real64) :: raiz\n\n        ! Ponto m\u00e9dio\n        real(real64) :: p_medio\n\n        p_medio = (a+b)/2\n\n        if (f(p_medio) == 0) then\n            raiz = p_medio\n            return\n        end if\n\n    end function bissecao\n</code></pre>"},{"location":"Fortran/Fortran_90/#5-se-nao-analisamos-o-sinal-da-funcao-neste-ponto-e-determinamos-um-novo-intervalo","title":"5. Se n\u00e3o, analisamos o sinal da fun\u00e7\u00e3o neste ponto e determinamos um novo intervalo","text":"<p>Diferente dos passos anteriores, \"fazer a an\u00e1lise de sinal da fun\u00e7\u00e3o e determinar um novo intervalo\" n\u00e3o \u00e9 uma tarefa de poucas instru\u00e7\u00f5es. Por\u00e9m, como o pr\u00f3prio algoritmo nos mostra, tamb\u00e9m n\u00e3o queremos colocar todo o trecho de c\u00f3digo diretamente na fun\u00e7\u00e3o pois isso n\u00e3o deixa claro o que este grande conjunto de instru\u00e7\u00f5es faz. Para manter uma boa legibilidade e modularidade de c\u00f3digo, vamos colocar esta etapa em uma subrotina. Faremos a especifica\u00e7\u00e3o e ajustes referentes \u00e0 subrotina ap\u00f3s terminamos a constru\u00e7\u00e3o da fun\u00e7\u00e3o principal.</p> <pre><code>    function bissecao(a, b) result(raiz)\n        ! Limite inferior do intervalo\n        real(real64), intent(in) :: a\n\n        ! Limite superior do intervalo\n        real(real64), intent(in) :: b\n\n        ! Valor de x tal que f(x) = 0\n        real(real64) :: raiz\n\n        ! Ponto m\u00e9dio\n        real(real64) :: p_medio\n\n        p_medio = (a+b)/2\n\n        if (f(p_medio) == 0) then\n            raiz = p_medio\n            return\n        else\n            call novo_intervalo(a, b)\n        end if\n    end function bissecao\n</code></pre>"},{"location":"Fortran/Fortran_90/#6-repetimos-a-partir-do-passo-2-ate-um-criterio-de-parada-como-um-numero-maximo-de-passos-para-evitarmos-um-loop-infinito","title":"6. Repetimos, a partir do passo 2, at\u00e9 um crit\u00e9rio de parada (como um n\u00famero m\u00e1ximo de passos), para evitarmos um loop infinito.","text":"<p>Para repetir estes passos, envolvemos o trecho do programa em um la\u00e7o <code>do</code>, criando uma vari\u00e1vel de itera\u00e7\u00e3o. Quanto ao crit\u00e9rio de parada, \u00e9 de bom tom que seja um par\u00e2metro que possa ser escolhido por execu\u00e7\u00e3o. Logo, receberemos esta informa\u00e7\u00e3o como argumento de chamada da fun\u00e7\u00e3o.</p> <pre><code>    function bissecao(a, b, n_passos) result(raiz)\n        ! Limite inferior do intervalo\n        real(real64), intent(in) :: a\n\n        ! Limite superior do intervalo\n        real(real64), intent(in) :: b\n\n        ! N\u00ba m\u00e1ximo de passos\n        integer, intent(in) :: n_passos\n\n        ! Valor de x tal que f(x) = 0\n        real(real64) :: raiz\n\n        ! Ponto m\u00e9dio\n        real(real64) :: p_medio\n\n        ! Vari\u00e1vel do loop\n        integer :: i\n\n        do i = 1, n_passos\n            p_medio = (a+b)/2\n            if (f(p_medio) == 0) then\n                raiz = p_medio\n                return\n            else\n                call novo_intervalo(a, b)\n            end if\n        end do\n    end function bissecao\n</code></pre> <p>E nossa implementa\u00e7\u00e3o est\u00e1 quase pronta, a menos da especifica\u00e7\u00e3o da subrotina <code>novo_intervalo</code>.</p>"},{"location":"Fortran/Fortran_90/#especificacao-do-item-5","title":"Especifica\u00e7\u00e3o do item 5","text":"<p>Nossa subrotina ir\u00e1 receber um par $(a, b)$ que representa o intervalo atual da busca e retornar\u00e1 um novo par $(a^\\star, b^\\star)$. Portanto, note que a maneira como estamos chamando a subrotina em nossa fun\u00e7\u00e3o de bisse\u00e7\u00e3o n\u00e3o \u00e9 boa, pois <code>a, b</code> s\u00e3o par\u00e2metros da fun\u00e7\u00e3o <code>bissecao</code>. E como vimos na Se\u00e7\u00e3o 3, n\u00e3o devemos alterar par\u00e2metros passados para uma fun\u00e7\u00e3o. Vamos come\u00e7ar, portanto, mudando nossa fun\u00e7\u00e3o de bisse\u00e7\u00e3o para trabalhar com vari\u00e1veis c\u00f3pias dos par\u00e2metros originais</p> <pre><code>    function bissecao(a, b, n_passos) result(raiz)\n        ! Limite inferior do intervalo\n        real(real64), intent(in) :: a\n\n        ! Limite superior do intervalo\n        real(real64), intent(in) :: b\n\n        ! Vari\u00e1vel LOCAL do limite inferior do intervalo\n        real(real64) :: inf\n\n        ! Vari\u00e1vel LOCAL do limite superior do intervalo\n        real(real64) :: sup\n\n        ! N\u00ba m\u00e1ximo de passos\n        integer, intent(in) :: n_passos\n\n        ! Valor de x tal que f(x) = 0\n        real(real64) :: raiz\n\n        ! Ponto m\u00e9dio\n        real(real64) :: p_medio\n\n        ! Vari\u00e1vel do loop\n        integer :: i\n\n        inf = a\n        sup = b\n\n        do i = 1, n_passos\n            p_medio = (inf+sup)/2\n            if (f(p_medio) == 0) then\n                raiz = p_medio\n                return\n            else\n                call novo_intervalo(inf, sup)\n            end if\n        end do\n    end function bissecao\n</code></pre> <p>Agora que estamos chamando a subrotina propriamente, vamos definir melhor sua l\u00f3gica interna.</p> <ol> <li>Primeiro calculamos o ponto m\u00e9dio do intervalo (<code>c</code>)</li> <li>Calculamos <code>f</code> aplicada no ponto m\u00e9dio e <code>f</code> aplicada no limite inferior do intervalo (<code>inf</code>)</li> <li>Se <code>f</code> aplicada em <code>c</code> tiver o mesmo sinal de <code>f</code> aplicada em <code>inf</code>, o novo intervalo \u00e9 (<code>c, sup</code>)</li> <li>Caso contr\u00e1rio, ent\u00e3o sabemos que <code>f</code> aplicada em <code>c</code> tem o mesmo sinal que <code>f</code> aplicada em <code>sup</code>, e o novo intervalo \u00e9 (<code>inf, c</code>)</li> </ol>"},{"location":"Fortran/Fortran_90/#51-calcular-o-ponto-medio-do-intervalo","title":"5.1 Calcular o ponto m\u00e9dio do intervalo","text":"<pre><code>    subroutine novo_intervalo(inf, sup)\n        real(real64), intent(inout) :: inf\n        real(real64), intent(inout) :: sup\n        real(real64) :: c\n\n        c = (inf+sup)/2\n    end subroutine novo_intervalo\n</code></pre>"},{"location":"Fortran/Fortran_90/#52-calcular-finf-e-fc","title":"5.2 Calcular <code>f(inf)</code> e <code>f(c)</code>","text":"<pre><code>    subroutine novo_intervalo(inf, sup)\n        real(real64), intent(inout) :: inf\n        real(real64), intent(inout) :: sup\n        real(real64) :: c\n        real(real64) :: sinal_f_inf\n        real(real64) :: sinal_f_c\n        real(real64) :: novo_inf\n        real(real64) :: novo_sup\n\n        c = (inf+sup)/2\n\n        f_em_inf = f(inf)\n        f_em_c = f(c)\n    end subroutine novo_intervalo\n</code></pre>"},{"location":"Fortran/Fortran_90/#53-testar-sinal-e-determinar-um-novo-intervalo","title":"5.3 Testar sinal e determinar um novo intervalo","text":"<pre><code>    subroutine novo_intervalo(inf, sup)\n        real(real64), intent(inout) :: inf\n        real(real64), intent(inout) :: sup\n        real(real64) :: c\n        real(real64) :: sinal_f_inf\n        real(real64) :: sinal_f_c\n        real(real64) :: novo_inf\n        real(real64) :: novo_sup\n\n        c = (inf+sup)/2\n\n        f_em_inf = f(inf)\n        f_em_c = f(c)\n\n        sinal_f_inf = sign(1.0_real64, f_em_inf)\n        sinal_f_c = sign(1.0_real64, f_em_c)\n\n        if (sinal_f_inf == sinal_f_c) then\n            novo_inf = c\n            novo_sup = sup\n        end if\n\n        inf = novo_inf\n        sup = novo_sup\n    end subroutine novo_intervalo\n</code></pre>"},{"location":"Fortran/Fortran_90/#54-determinar-outro-novo-intervalo-caso-o-primeiro-teste-tenha-falhado","title":"5.4 Determinar outro novo intervalo caso o primeiro teste tenha falhado","text":"<pre><code>    subroutine novo_intervalo(inf, sup)\n        real(real64), intent(inout) :: inf\n        real(real64), intent(inout) :: sup\n        real(real64) :: c\n        real(real64) :: sinal_f_inf\n        real(real64) :: sinal_f_c\n        real(real64) :: novo_inf\n        real(real64) :: novo_sup\n\n        c = (inf+sup)/2\n\n        f_em_inf = f(inf)\n        f_em_c = f(c)\n\n        sinal_f_inf = sign(1.0_real64, f_em_inf)\n        sinal_f_c = sign(1.0_real64, f_em_c)\n\n        if (sinal_f_inf == sinal_f_c) then\n            novo_inf = c\n            novo_sup = sup  \n        else\n            novo_inf = inf\n            novo_sup = c\n        end if\n\n        inf = novo_inf\n        sup = novo_sup\n    end subroutine novo_intervalo\n</code></pre>"},{"location":"Fortran/Fortran_90/#topico-72-codigo-final","title":"T\u00f3pico 7.2: C\u00f3digo Final","text":"<p>Juntando os trechos finais de c\u00f3digo desenvolvidos acima temos a nossa primeira vers\u00e3o do programa:</p> <pre><code>    module funcoes\n        use, intrinsic :: iso_fortran_env\n        implicit none\n\n    contains    \n        ! Polin\u00f4mio: x^3 - x - 2\n        function f(x) result(y)\n            real(real64), intent(in) :: x\n            real(real64) :: y\n\n            y = x**3 - x - 2\n        end function f\n    end module funcoes\n\n    module metodos\n        use funcoes\n        implicit none\n\n    contains\n        subroutine novo_intervalo(inf, sup)\n            real(real64), intent(inout) :: inf\n            real(real64), intent(inout) :: sup\n            real(real64) :: c\n            real(real64) :: sinal_f_inf\n            real(real64) :: sinal_f_c\n            real(real64) :: novo_inf\n            real(real64) :: novo_sup\n\n            c = (inf+sup)/2\n            sinal_f_inf = sign(1.0_real64, f(inf))\n            sinal_f_c = sign(1.0_real64, f(c))\n\n            if (sinal_f_inf == sinal_f_c) then\n                novo_inf = c\n                novo_sup = sup\n\n            else\n                novo_inf = inf\n                novo_sup = c\n            end if\n\n            inf = novo_inf\n            sup = novo_sup\n        end subroutine novo_intervalo\n\n        function bissecao(a, b, n_passos) result(raiz)  \n            ! Limite inferior do intervalo\n            real(real64), intent(in) :: a                           \n\n            ! Limite superior do intervalo\n            real(real64), intent(in) :: b \n\n            ! N\u00ba m\u00e1ximo de passos \n            integer, intent(in) :: n_passos \n\n            ! Valor de x tal que f(x) = 0\n            real(real64) :: raiz \n\n            ! Ponto m\u00e9dio\n            real(real64) :: p_medio\n\n            ! Vari\u00e1vel LOCAL do limite inferior do intervalo\n            real(real64) :: inf\n\n            ! Vari\u00e1vel LOCAL do limite superior do intervalo\n            real(real64) :: sup\n\n            ! Vari\u00e1vel do loop\n            integer :: i\n\n            inf = a\n            sup = b\n\n            do i = 1, n_passos\n                p_medio = (inf+sup)/2\n                if (f(p_medio) == 0) then\n                    raiz = p_medio\n                    return\n\n                else\n                    call novo_intervalo(inf, sup)\n                end if\n            end do\n\n            raiz = p_medio\n        end function bissecao\n    end module metodos\n\n    program main\n        use funcoes\n        use metodos\n        use, intrinsic :: iso_fortran_env\n        implicit none\n\n        real(real64) :: resultado\n        real(real64) :: a = 1\n        real(real64) :: b = 2\n        integer :: n_passos = 20\n\n        resultado = bissecao(a, b, n_passos)\n        print *, resultado\n    end program main\n</code></pre>"},{"location":"Fortran/Fortran_90/#testes","title":"Testes","text":"<p>Rodando nosso programa para o polin\u00f4mio de teste $x^3 - x - 2$, come\u00e7ando pelo intervalo $[1, 2]$ e iterando por 22 passos (valores acima na <code>main</code>) obtemos como sa\u00edda:</p> <pre><code>1.5213804244995117\n</code></pre> <p>E avaliando <code>f(resultado)</code> a sa\u00edda \u00e9 <code>4.2658294048258938E-006</code>, que est\u00e1 pr\u00f3ximo de 0 e portanto indica que a sa\u00edda do programa est\u00e1 pr\u00f3xima da raiz do polin\u00f4mio. Se aumentarmos o n\u00famero de itera\u00e7\u00f5es fazendo <code>n_passos = 50</code>, o programa retorna:</p> <pre><code>1.5213797068045674\n</code></pre> <p>E avaliando para esta sa\u00edda <code>f(resultado)</code> obtemos <code>-1.3322676295501878E-015</code>, um resultado ainda melhor e que faz jus ao resultado te\u00f3rico convergente: quanto mais passos, melhor a aproxima\u00e7\u00e3o.</p> <p>Vamos testar para uma outra fun\u00e7\u00e3o mais desafiadora? Troquemos o polin\u00f4mio pela fun\u00e7\u00e3o $$f(x) = \\frac{cos(x) x^5}{e^x} + 1$$</p> <p>Observando o gr\u00e1fico da fun\u00e7\u00e3o, sabemos que esta fun\u00e7\u00e3o possui ra\u00edzes pr\u00f3ximas do valor 10:</p> <p></p> <p>Vamos buscar um valor mais preciso para a raiz logo depois do 10 e antes do 12. Para isso, basta mudarmos nossa fun\u00e7\u00e3o <code>f</code> no m\u00f3dulo de fun\u00e7\u00f5es:</p> <pre><code>    function f(x) result(y)\n        real(real64), intent(in) :: x\n        real(real64) :: y\n\n        y = ((cos(x) * x**5) / exp(x)) + 1\n    end function f\n</code></pre> <p>E podemos utilizar como intervalo de chute inicial $[10, 12]$ , ou seja, fazemos <code>a = 10</code> e <code>b = 12</code> no programa <code>main</code>. Com 50 passos temos que a raiz \u00e9:</p> <p><pre><code>10.677725261441926     \n</code></pre> E nossa nova <code>f</code> avaliada neste ponto \u00e9 <code>-1.7763568394002505E-015</code>; temos uma \u00f3tima aproxima\u00e7\u00e3o. </p> <p>Fazer com que nosso algoritmo aceite uma fun\u00e7\u00e3o <code>f</code> externa qualquer n\u00e3o \u00e9 trivial, logo estamos satisfeitos, por hora, com este procedimento de trocar a declara\u00e7\u00e3o de <code>f</code> explicitamente no c\u00f3digo. Caso fique curioso sobre como \u00e9 feita esta implementa\u00e7\u00e3o mais gen\u00e9rica, ela envolve uso de uma estrutura ainda n\u00e3o apresentada: <code>interface</code>.</p>"},{"location":"Fortran/Fortran_90/#topico-8-formatacao-de-saidas-write","title":"T\u00f3pico 8: Formata\u00e7\u00e3o de Sa\u00eddas: WRITE","text":"<p>At\u00e9 o momento utilizamos apenas a fun\u00e7\u00e3o <code>print</code> para exibirmos resultados em nossos c\u00f3digos. Por\u00e9m, caso queiramos mostrar sa\u00eddas um pouco melhor elaboradas e formatadas, o uso da fun\u00e7\u00e3o <code>print</code> n\u00e3o \u00e9 o mais adequado. Isso porque esta fun\u00e7\u00e3o foi criada para exibir resultados utilizando uma formata\u00e7\u00e3o espec\u00edfica, pensada na compatibilidade com antigas impressoras e dispositivos de sa\u00edda utilizados nos anos 60 e 70. </p> <p>Para utilizar uma formata\u00e7\u00e3o de sa\u00edda personalizada, foi criada a fun\u00e7\u00e3o <code>write</code>, uma alternativa mais flex\u00edvel que a <code>print</code>.  A fun\u00e7\u00e3o <code>print</code> recebe como primeiro argumento onde ser\u00e1 escrita a sa\u00edda (quando passamos <code>*</code> indicamos que deve ser utilizada a sa\u00edda padr\u00e3o do sistema) e logo em seguida passamos todos os argumentos a serem impressos, separados por v\u00edrgulas. J\u00e1 na fun\u00e7\u00e3o <code>write</code>, passamos entre par\u00eanteses onde ser\u00e1 escrita a sa\u00edda e qual ser\u00e1 a formata\u00e7\u00e3o a ser utilizada, e ent\u00e3o a lista de argumentos a serem impressos, separados por v\u00edrgulas. </p> <p>Logo, a diferen\u00e7a maior est\u00e1 neste segundo argumento de formata\u00e7\u00e3o, chamados de \"descritores de edi\u00e7\u00e3o\". Como eles funcionam? Bom, existe uma lista de formatadores aceitos que podem variar a depender do compilador sendo utilizado. Vamos utilizar a tabela da Fortran Wiki como refer\u00eancia: </p> <p><code>w</code> : o n\u00famero exato de caracteres a serem utilizados</p> <p><code>m</code> : o n\u00famero m\u00ednimo de caracteres a serem utilizados</p> <p><code>d</code> : o n\u00famero de d\u00edgitos \u00e0 direita do ponto decimal</p> <p><code>e</code> : o n\u00famero de d\u00edgitos no expoente</p> Tipo do dado Descritores de        Edi\u00e7\u00e3o Outra op\u00e7\u00e3o <code>integer</code> <code>Iw</code> <code>Iw.m</code> <code>real</code> (nota\u00e7\u00e3o decimal) <code>Fw.d</code> <code>real</code> (nota\u00e7\u00e3o exponencial) <code>Ew.d</code> <code>Ew.dEe</code> <code>real</code> (nota\u00e7\u00e3o cient\u00edfica ) <code>ESw.d</code> <code>ESw.dEe</code> <code>real</code> (nota\u00e7\u00e3o de engenharia) <code>ENw.d</code> <code>ENw.dEe</code> <code>logical</code> <code>Lw</code> <code>character</code> <code>A</code> <code>Aw</code> posicionamento horizontal <code>nX</code> posicionamento de tabula\u00e7\u00e3o <code>Tc</code> <code>TLc</code>, <code>TRc</code> posicionamento vertical <code>/</code> <p>Com isso, podemos formatar a atual sa\u00edda do nosso programa da seguinte forma:  - Mostrar a string \"Raiz encontrada: \", seguida de 12 espa\u00e7os, seguidos do valor calculado para a raiz (<code>resultado</code>) com 15 casas depois da v\u00edrgula. - Logo em seguida mostrar a string \"Fun\u00e7\u00e3o avaliada nessa raiz: \", seguida de 1 espa\u00e7o, seguido do valor <code>f(resultado)</code> com 15 casas depois da v\u00edrgula.</p> <p>Usando os descritores da tabela acima, alteraremos ent\u00e3o o final do nosso programa principal do t\u00f3pico anterior para:</p> <pre><code>    program main\n        use funcoes\n        use metodos\n        use, intrinsic :: iso_fortran_env\n        implicit none\n\n        real(real64) :: resultado\n        real(real64) :: a = 1\n        real(real64) :: b = 2\n        integer :: n_passos = 22\n\n        resultado = bissecao(a, b, n_passos)\n        write (*,'(A, 12X, F20.15)') 'Raiz encontrada: ', resultado\n        write (*,'(A,  1X, F20.15)') 'Fun\u00e7\u00e3o avaliada nessa raiz: ', f(resultado)\n    end program main\n</code></pre> <p>E a sa\u00edda com $f(x) = x^3 - x - 2$ e 20 passos:</p> <pre><code>Raiz encontrada:              1.521380424499512\nFun\u00e7\u00e3o avaliada nessa raiz:   0.000004265829405\n</code></pre> <p>Aumentando para 50 passos:</p> <pre><code>Raiz encontrada:              1.521379706804567\nFun\u00e7\u00e3o avaliada nessa raiz:  -0.000000000000001\n</code></pre> <p>Trocando o descritor do segundo <code>write</code> de <code>F20.15</code> para <code>E22.15</code>:</p> <pre><code>Raiz encontrada:              1.521379706804567\nFun\u00e7\u00e3o avaliada nessa raiz:  -0.133226762955019E-14\n</code></pre> <p>E podemos utilizar a formata\u00e7\u00e3o de sa\u00edda que nos for mais conveniente. Aten\u00e7\u00e3o: note que o n\u00famero que segue o <code>E</code> e o <code>F</code> dos descritores precisa levar em conta todos os caracteres exibidos no argumento de sa\u00edda (incluindo sinais, pontos, o pr\u00f3prio \"E\", etc). </p> <p>A sa\u00edda \"-0.133226762955019E-14\" tem exatamente 22 caracteres. Caso coloc\u00e1ssemos um n\u00famero menor que 22 no descritor, a sa\u00edda sairia mal formatada. Veja o que ocorre quando colocamos <code>E20.15</code> :</p> <pre><code>Raiz encontrada:              1.521379706804567\nFun\u00e7\u00e3o avaliada nessa raiz:  ********************\n</code></pre> <p>Na d\u00favida, um tamanho maior que o necess\u00e1rio \u00e9 melhor que um menor.</p>"},{"location":"Fortran/Fortran_90/#topico-9-repeticao-do-while","title":"T\u00f3pico 9: Repeti\u00e7\u00e3o: DO - WHILE","text":""},{"location":"Fortran/Fortran_90/#topico-10-imports-e-linkagem","title":"T\u00f3pico 10: Imports e Linkagem","text":""},{"location":"Fortran/Fortran_90/#capitulo-2-matrizes-vetores-e-operacoes-vetoriais","title":"Cap\u00edtulo 2 - Matrizes, Vetores e Opera\u00e7\u00f5es Vetoriais","text":""},{"location":"Fortran/f90_content/","title":"Index","text":"<p>Images and some code snippets used in main documentation </p>"},{"location":"Julia/capitulo_1/","title":"1. Introdu\u00e7\u00e3o","text":"<p>Este cap\u00edtulo foca em introduzir conceitos fundamentais relacionados \u00e0 linguagem de programa\u00e7\u00e3o Julia, abordando sua sintaxe, compilador JIT (Just-In-Time) e aspectos gerais de programa\u00e7\u00e3o com Julia.</p>"},{"location":"Julia/capitulo_1/#11-caracteristicas-da-linguagem-julia","title":"1.1. Caracter\u00edsticas da Linguagem Julia","text":"<p>Julia \u00e9 uma linguagem de programa\u00e7\u00e3o de alto desempenho para computa\u00e7\u00e3o t\u00e9cnica. Ela combina a facilidade de uma linguagem de script com a pot\u00eancia de linguagens compiladas, oferecendo um sistema de tipos din\u00e2mico, efici\u00eancia de desempenho e uma sintaxe elegante. Essa combina\u00e7\u00e3o de recursos facilita a express\u00e3o de muitos algoritmos num\u00e9ricos e a manipula\u00e7\u00e3o de dados, tornando Julia uma escolha excelente para ci\u00eancia de dados, an\u00e1lise num\u00e9rica, e mais. Abaixo, algumas caracter\u00edsticas chave de Julia:</p> <ul> <li>Desempenho de Alto N\u00edvel: Gra\u00e7as \u00e0 sua compila\u00e7\u00e3o JIT, Julia oferece desempenho que pode rivalizar com o de linguagens tradicionalmente compiladas como C e Fortran;</li> <li>Facilidade de Uso: A sintaxe de Julia \u00e9 clara e concisa, tornando a programa\u00e7\u00e3o em Julia acess\u00edvel para programadores de todos os n\u00edveis;</li> <li>Computa\u00e7\u00e3o Paralela e Distribu\u00edda: Julia foi desenhada com a paraleliza\u00e7\u00e3o e computa\u00e7\u00e3o distribu\u00edda em mente, permitindo a execu\u00e7\u00e3o eficiente de c\u00f3digo em clusters e na nuvem;</li> <li>Ecosistema Rico: A comunidade Julia desenvolveu um vasto ecossistema de pacotes, cobrindo diversas \u00e1reas como aprendizado de m\u00e1quina, visualiza\u00e7\u00e3o de dados, manipula\u00e7\u00e3o de dados, entre outros;</li> <li>Interoperabilidade: Julia permite a chamada de fun\u00e7\u00f5es de outras linguagens, como Python, C, e Fortran, facilitando a integra\u00e7\u00e3o com bibliotecas e sistemas existentes;</li> </ul> <p>Abaixo, voc\u00ea encontrar\u00e1 uma tabela com alguns tipos de dados b\u00e1sicos em Julia, destacando as palavras-chave utilizadas para a defini\u00e7\u00e3o de vari\u00e1veis e os formatos para a sua manipula\u00e7\u00e3o:</p> <p>Tabela de dados b\u00e1sicos em Julia</p> PALAVRA-CHAVE TIPO DESCRI\u00c7\u00c3O EXEMPLO DE USO Int Inteiro Tipo padr\u00e3o de inteiro, variando conforme a arquitetura (32 ou 64 bits) 5, -3 Float64 Ponto flutuante N\u00famero real em precis\u00e3o dupla 3.14, -2.71 Bool Booleano Verdadeiro ou falso true, false String Cadeia de caracteres Texto \"Ol\u00e1, mundo!\" Char Caractere Um \u00fanico caractere unicode 'a', '3' <p>\u00c9 importante destacar que Julia \u00e9 projetada para ser f\u00e1cil e intuitiva para usu\u00e1rios de outras linguagens de programa\u00e7\u00e3o, sem sacrificar o desempenho. Ao longo deste texto, exploraremos mais sobre como Julia atinge esse equil\u00edbrio e como voc\u00ea pode come\u00e7ar a aproveitar suas capacidades em seus pr\u00f3prios projetos de programa\u00e7\u00e3o.</p>"},{"location":"Julia/capitulo_1/#12-o-sistema-de-tipos-em-julia","title":"1.2. O Sistema de Tipos em Julia","text":"<p>O sistema de tipos em Julia \u00e9 sofisticado e permite defini\u00e7\u00f5es de tipos abstratos e concretos, heran\u00e7a de tipos e muito mais. A linguagem \u00e9 dinamicamente tipada, mas seu sistema de tipos \u00e9 projetado para promover pr\u00e1ticas que maximizam o desempenho do c\u00f3digo.</p> <p>A seguir, detalhamos o processo de compila\u00e7\u00e3o JIT em Julia, que \u00e9 fundamental para o seu desempenho.</p>"},{"location":"Julia/capitulo_1/#13-compilacao-just-in-time-jit-em-julia","title":"1.3. Compila\u00e7\u00e3o Just-In-Time (JIT) em Julia","text":"<p>A compila\u00e7\u00e3o Just-In-Time (JIT) \u00e9 uma das caracter\u00edsticas que distinguem Julia de outras linguagens de programa\u00e7\u00e3o. Em vez de compilar o c\u00f3digo para uma linguagem de m\u00e1quina de antem\u00e3o (Ahead-of-Time), Julia compila o c\u00f3digo no momento da execu\u00e7\u00e3o. Isso permite uma otimiza\u00e7\u00e3o espec\u00edfica para o hardware do usu\u00e1rio e melhora significativamente a velocidade de execu\u00e7\u00e3o de programas Julia, especialmente em c\u00e1lculos num\u00e9ricos e cient\u00edficos.</p> <p>Essa abordagem traz o melhor de dois mundos: a flexibilidade de uma linguagem interpretada, com a efici\u00eancia de uma linguagem compilada, tornando Julia uma excelente escolha para uma ampla gama de aplica\u00e7\u00f5es cient\u00edficas e t\u00e9cnicas.</p>"},{"location":"Linguagem_C/capitulo_1/","title":"1. Introdu\u00e7\u00e3o","text":"<p>Esse cap\u00edtulo visa estabelecer conceitos importantes que envolvem a linguagem C, compiladores e programa\u00e7\u00e3o no geral.</p>"},{"location":"Linguagem_C/capitulo_1/#11-caracteristicas-da-linguagem-c","title":"1.1. Caracter\u00edsticas da Linguagem C","text":"<p>C \u00e9 uma linguagem de programa\u00e7\u00e3o compilada, isto \u00e9, ao escrevermos o c\u00f3digo fonte na pr\u00f3pria linguagem, no caso em C, um programa chamado compilador reescreve esse c\u00f3digo para a linguagem de m\u00e1quina. Sendo assim, o compilador tem como entrada um arquivo com c\u00f3digo fonte da linguagem e que gera como sa\u00edda um arquivo objeto, com c\u00f3digo objeto, que \u00e9 ligado a outros arquivos objeto para gerar um arquivo execut\u00e1vel. O arquivo execut\u00e1vel \u00e9 um arquivo que pode ser executado no computador alvo. Na pr\u00f3xima se\u00e7\u00e3o, ser\u00e3o dados mais detalhes sobre o processo de compila\u00e7\u00e3o de um arquivo em C. Abaixo seguem algumas caracter\u00edsticas importantes da linguagem C:</p> <ul> <li>Estruturada: A programa\u00e7\u00e3o estruturada (sucedida pela programa\u00e7\u00e3o orientada a objeto) \u00e9 um paradigma formado por tr\u00eas componentes:</li> <li>Sequ\u00eancia: Uma tarefa \u00e9 executada logo ap\u00f3s a outra;</li> <li>Decis\u00e3o: A tarefa \u00e9 executada logo ap\u00f3s um teste l\u00f3gico;</li> <li>Itera\u00e7\u00e3o: A partir de um teste l\u00f3gico, um trecho de c\u00f3digo pode ser repetido finitas vezes.</li> <li>Imperativa: Descreve a\u00e7\u00f5es/instru\u00e7\u00f5es que o programa dever\u00e1 executar. Ou seja, linguagens imperativas s\u00e3o programadas com uma sequ\u00eancia de comandos ordenada pelo programador;</li> <li>Procedural: Permite a constru\u00e7\u00e3o de procedimentos que podem ser compartimentados e reutilizados, tornando partes do c\u00f3digo mais independentes entre si;</li> <li>Padronizada: Garante que um mesmo c\u00f3digo gere sempre o mesmo resultado, seja ele compilado e executado ou interpretado;</li> <li>Fortemente Tipada: Em C, os tipos das vari\u00e1veis e fun\u00e7\u00f5es precisam ser bem definidos durante toda a execu\u00e7\u00e3o do programa. Com ponteiros do tipo <code>void</code>, \u00e9 poss\u00edvel contornar essa restri\u00e7\u00e3o, mas isso n\u00e3o \u00e9 aconselh\u00e1vel.</li> </ul> <p>Abaixo segue uma tabela com os tipos de dados b\u00e1sicos da linguagem, onde a palavra-chave \u00e9 usada para definir as vari\u00e1veis e o formato indica a forma de capturar (por meio de fun\u00e7\u00f5es como <code>scanf</code>) ou de imprimir (por exemplo, com <code>printf</code>):</p> <p>Tabela de dados b\u00e1sicos de C</p> PALAVRA-CHAVE TIPO BYTES INTERVALO FORMATO <code>char / signed char</code> Caracter 1 -128 a 127 <code>%c</code> <code>unsigned char</code> Caracter sem sinal 1 0 a 255 <code>%c</code> <code>short / short int / signed short / signed short int</code> Inteiro curto com sinal 2 -32768 a 32767 <code>%hi ou %hd</code> <code>unsigned short / unsigned short int</code> Inteiro curto sem sinal 2 0 a 65535 <code>%hu</code> <code>signed int / signed</code> Inteiro com sinal 2 -32768 a 32767 <code>%i ou %d</code> <code>unsigned / unsigned int</code> Inteiro sem sinal 2 0 a 65535 <code>%u</code> <code>long / long int / signed long / signed long int</code> Inteiro com sinal 4 -2147483648 a 2147483647 <code>%li ou %ld</code> <code>unsigned long / unsigned long int</code> Inteiro sem sinal 4 0 a 4294967295 <code>%lu</code> <code>long long / signed long long / long long int / signed long long int</code> Inteiro muito lingo com sinal 8 \u22122^+63 a 2^+63 \u22121 <code>%lli ou %lld</code> <code>unsigned long long / unsigned long long int</code> Inteiro muito lingo sem sinal 8 0 a 2^+64 \u22121 <code>%llu</code> <code>float</code> Ponto flutuante simples 4 3.4 X 10^-38 a 3.4 X 10^+38 <code>%f ou %F</code> <code>double</code> Ponto flutuante em precisao dupla 8 1.7 X 10^-308 a 1.7 X 10^+308 <code>%lf ou %lF</code> <code>long double</code> Ponto flutuante em precis\u00e3o estendida 16 3.4 X 10^-4932 a 3.4 X 10^+4932 <code>%Lf ou %LF</code> <p>Vale notar que esses tipos podem variar de m\u00e1quina para m\u00e1quina, sendo interessante imprimir os limites dos tipos presentes no cabe\u00e7alho limits.h. As padroniza\u00e7\u00f5es (como ANSI e ISO) da linguagem tamb\u00e9m podem afetar certos tipos e, consequentemente, o funcionamento do c\u00f3digo. Como C \u00e9 muito popular, diversos compiladores foram constru\u00eddos com caracter\u00edsticas distintas. As pr\u00f3ximas se\u00e7\u00f5es introduzir\u00e3o o processo de compila\u00e7\u00e3o.</p>"},{"location":"Linguagem_C/capitulo_1/#12-o-que-e-um-compilador","title":"1.2. O Que \u00c9 Um Compilador?","text":"<p>O compilador \u00e9 um programa de computador respons\u00e1vel por reescrever o c\u00f3digo fonte em c\u00f3digo de m\u00e1quina que poder\u00e1 ser executado. Assim, ele recebe como entrada um arquivo com o c\u00f3digo fonte e gera um arquivo execut\u00e1vel.</p> <p>Em outras palavras, o compilador traduz o c\u00f3digo fonte de uma linguagem compreens\u00edvel para os seres humanos para outra que o computador possa entender. Atualmente, o compilador possui muitas funcionalidades al\u00e9m da simples tradu\u00e7\u00e3o: ele pode agrupar instru\u00e7\u00f5es de m\u00e1quina em uma \u00fanica linha de c\u00f3digo, otimizar o c\u00f3digo, gerar arquivos intermedi\u00e1rios, tratar erros na programa\u00e7\u00e3o e oferecer ferramentas de depura\u00e7\u00e3o. Os primeiros compiladores eram focados na tradu\u00e7\u00e3o do c\u00f3digo fonte e na jun\u00e7\u00e3o das bibliotecas necess\u00e1rias para a execu\u00e7\u00e3o do c\u00f3digo objeto, num processo chamado de liga\u00e7\u00e3o. Esses compiladores iniciais foram escritos em Assembly e, com o tempo, surgiram diversas ferramentas para a constru\u00e7\u00e3o de compiladores, facilitando a cria\u00e7\u00e3o de novas linguagens.</p> <p>Com a evolu\u00e7\u00e3o das linguagens e a necessidade de novas funcionalidades, os compiladores passaram a ter caracter\u00edsticas variadas e m\u00e9todos de funcionamento diferentes. A seguir, os principais tipos de compiladores:</p> <ul> <li>Compilador Ahead-of-time: Compila o c\u00f3digo fonte antes da execu\u00e7\u00e3o do programa, gerando um arquivo objeto com instru\u00e7\u00f5es de m\u00e1quina nativas.</li> <li>Compilador Just-in-time: Compila o c\u00f3digo durante a execu\u00e7\u00e3o do programa. Na primeira execu\u00e7\u00e3o, cada linha do c\u00f3digo fonte \u00e9 traduzida para instru\u00e7\u00f5es de m\u00e1quina (ou para uma linguagem intermedi\u00e1ria) e executada imediatamente; em execu\u00e7\u00f5es subsequentes, o c\u00f3digo j\u00e1 compilado permite uma execu\u00e7\u00e3o mais r\u00e1pida.</li> <li>Compilador Cruzado: Gera um arquivo execut\u00e1vel a partir do c\u00f3digo fonte que pode ser executado em outras m\u00e1quinas, \u00fatil para sistemas embutidos ou ambientes com m\u00faltiplas arquiteturas.</li> <li>Compilador Source-to-source: Tem como sa\u00edda um c\u00f3digo fonte de alto n\u00edvel, em vez de instru\u00e7\u00f5es de m\u00e1quina. Isso possibilita a cria\u00e7\u00e3o de extens\u00f5es sint\u00e1ticas que s\u00e3o reescritas para o c\u00f3digo alvo. Um exemplo \u00e9 o TypeScript.</li> </ul> <p>Existe tamb\u00e9m o interpretador, que traduz e executa o c\u00f3digo fonte ou bytecode diretamente, sem gerar um arquivo objeto. Esse processo \u00e9 geralmente mais lento, pois cada linha precisa ser interpretada em tempo real. Por fim, programas que convertem c\u00f3digo Assembly para linguagem de m\u00e1quina e vice-versa s\u00e3o chamados de montador (assembler) e desmontador (disassembler), respectivamente. A descompila\u00e7\u00e3o, que converte c\u00f3digo de m\u00e1quina para um c\u00f3digo de alto n\u00edvel, tamb\u00e9m \u00e9 utilizada, especialmente em contextos de seguran\u00e7a.</p>"},{"location":"Linguagem_C/capitulo_1/#13-gnu-compiler-collection","title":"1.3. GNU Compiler Collection","text":"<p>O GNU Compiler Collection (GCC) \u00e9 uma cole\u00e7\u00e3o de compiladores Ahead-of-time do projeto GNU, criada em 1987. Ele oferece compiladores para linguagens como ADA, C++, Fortran, Java, Objective-C e Pascal, e possui compatibilidade com arquiteturas como ARM, x86 e AMD64 (x86-64). O GCC \u00e9 o compilador padr\u00e3o na maioria dos sistemas Linux, o principal compilador para o MAC OS e tamb\u00e9m pode ser utilizado no Windows por meio de ferramentas como MSYS2 e MinGW. Grande parte desses compiladores \u00e9 escrita em C, inclusive o pr\u00f3prio compilador C, num processo chamado de bootstrapping. O foco aqui ser\u00e1 o GNU C Compiler (GCC).</p> <ul> <li>Pr\u00e9-processamento: Realizado pelo pr\u00e9-processador, que trata todas as linhas que come\u00e7am com <code>#</code>. As diretivas principais nessa fase s\u00e3o <code>#include</code> (para inclus\u00e3o de arquivos de cabe\u00e7alho com defini\u00e7\u00f5es e declara\u00e7\u00f5es) e <code>#define</code> (para defini\u00e7\u00e3o de macros e constantes). Outras diretivas, como <code>#if...#else...#endif</code> e <code>#error</code>, tamb\u00e9m s\u00e3o utilizadas para controle condicional e exibi\u00e7\u00e3o de mensagens de erro.</li> <li>Compila\u00e7\u00e3o: Nesta fase, o c\u00f3digo \u00e9 traduzido para assembly em v\u00e1rios n\u00edveis:</li> <li>An\u00e1lise l\u00e9xica: Verifica se os s\u00edmbolos (vari\u00e1veis, fun\u00e7\u00f5es e palavras reservadas) est\u00e3o corretos, removendo espa\u00e7os e coment\u00e1rios. Erros como vari\u00e1veis n\u00e3o definidas ou operadores inexistentes s\u00e3o identificados aqui.</li> <li>An\u00e1lise sint\u00e1tica: Garante que as express\u00f5es seguem a gram\u00e1tica formal do C, verificando a organiza\u00e7\u00e3o correta dos s\u00edmbolos.</li> <li>An\u00e1lise sem\u00e2ntica: Valida o sentido l\u00f3gico das express\u00f5es, checando a consist\u00eancia dos tipos, regras de visibilidade e contexto.</li> <li>Otimiza\u00e7\u00e3o de alto n\u00edvel: Otimiza o c\u00f3digo, eliminando redund\u00e2ncias e trechos desnecess\u00e1rios.</li> <li>Montagem: Converte cada linha de assembly em c\u00f3digo de m\u00e1quina.</li> <li>Liga\u00e7\u00e3o: Na fase de liga\u00e7\u00e3o, as bibliotecas e todo o c\u00f3digo necess\u00e1rio para a execu\u00e7\u00e3o do programa s\u00e3o carregados e incorporados ao c\u00f3digo objeto.</li> </ul> <p>Vale ressaltar que muitas otimiza\u00e7\u00f5es ficam desabilitadas por padr\u00e3o e precisam ser ativadas por meio de flags. Ap\u00f3s esta introdu\u00e7\u00e3o aos conceitos b\u00e1sicos da linguagem C e do GCC, os pr\u00f3ximos cap\u00edtulos discutir\u00e3o as formas de utiliza\u00e7\u00e3o deste compilador e as ferramentas que ele oferece.</p>"},{"location":"Linguagem_C/capitulo_2/","title":"2. Compilando Programas em C","text":""},{"location":"Linguagem_C/capitulo_2/#21-primeiros-passos","title":"2.1. Primeiros Passos","text":"<p>Um dos primeiros programas que muitos programadores aprendem a escrever \u00e9 o famoso <code>\"Hello, World!\"</code>. A seguir, mostraremos como compilar esse programa em C utilizando o compilador GCC:</p>"},{"location":"Linguagem_C/capitulo_2/#helloworldc","title":"helloworld.c","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n  printf(\"Hello, World!\");\n  return 0;\n}\n</code></pre> <p>No entanto, o c\u00f3digo-fonte ainda n\u00e3o pode ser entendido pelo computador, sendo necess\u00e1rio compil\u00e1-lo para gerar um arquivo execut\u00e1vel. Para isso, usamos um compilador de C, como o GCC. No caso deste exemplo, o arquivo com o c\u00f3digo fonte se chama helloworld.c e o execut\u00e1vel, hello. A compila\u00e7\u00e3o \u00e9 feita pelo terminal:</p> <pre><code>$ gcc helloworld.c -o hello\n</code></pre> <p>O par\u00e2metro <code>-o</code> indica que queremos criar um execut\u00e1vel com o nome hello. Al\u00e9m disso, \u00e9 recomend\u00e1vel utilizar a flag <code>-Wall</code> para habilitar avisos de poss\u00edveis problemas:</p> <pre><code>$ gcc -Wall helloworld.c -o hello\n</code></pre> <p>Para executar o programa, digite:</p> <pre><code>$ ./hello\n</code></pre> <p>Se tudo ocorrer bem, a mensagem <code>Hello, World!</code> ser\u00e1 exibida no terminal.</p>"},{"location":"Linguagem_C/capitulo_2/#22-trabalhando-com-multiplos-arquivos","title":"2.2. Trabalhando com M\u00faltiplos Arquivos","text":"<p>Em projetos em C, \u00e9 comum dividir o c\u00f3digo em m\u00faltiplos arquivos para melhorar a organiza\u00e7\u00e3o e reduzir o tempo de compila\u00e7\u00e3o. Por exemplo, para criar um programa que calcula o quadrado de um n\u00famero, podemos usar:</p>"},{"location":"Linguagem_C/capitulo_2/#mainc","title":"main.c","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"quadrado.h\"\n\nint main() {\n  int x;\n  printf(\"Digite um n\u00famero: \");\n  scanf(\"%d\", &amp;x);\n  printf(\"O quadrado de %d \u00e9 %d\\n\", x, calc_quadrado(x));\n  return 0;\n}\n</code></pre>"},{"location":"Linguagem_C/capitulo_2/#quadradoc","title":"quadrado.c","text":"<pre><code>int calc_quadrado(int x) {\n  return x * x;\n}\n</code></pre>"},{"location":"Linguagem_C/capitulo_2/#quadradoh","title":"quadrado.h","text":"<pre><code>int calc_quadrado(int x);\n</code></pre> <p>Se inclu\u00edssemos diretamente quadrado.c em main.c, ter\u00edamos duas defini\u00e7\u00f5es da fun\u00e7\u00e3o <code>int calc_quadrado(int x)</code>, o que causaria um erro. Assim, usamos quadrado.h para declarar a fun\u00e7\u00e3o. Para compilar todos os arquivos de uma vez, execute:</p> <pre><code>$ gcc -Wall main.c quadrado.c -o programa\n</code></pre> <p>E para rodar o programa:</p> <pre><code>$ ./programa\n</code></pre> <p>Para evitar recompilar o programa inteiro ap\u00f3s uma altera\u00e7\u00e3o, compile cada arquivo em um objeto:</p> <pre><code>$ gcc -Wall main.c -c\n$ gcc -Wall quadrado.c -c\n</code></pre> <p>Isso gera os arquivos main.o e quadrado.o. Em seguida, ligue-os para criar o execut\u00e1vel:</p> <pre><code>$ gcc main.o quadrado.o -o programa\n</code></pre> <p>Assim, voc\u00ea pode compilar apenas os arquivos modificados e ligar os objetos pr\u00e9-compilados.</p>"},{"location":"Linguagem_C/capitulo_2/#23-utilizando-makefiles","title":"2.3. Utilizando Makefiles","text":"<p>Em projetos grandes com muitos arquivos, \u00e9 comum que apenas alguns precisem ser recompilados ap\u00f3s altera\u00e7\u00f5es. Para gerenciar essas depend\u00eancias, utiliza-se o <code>make</code> com um Makefile. Esse arquivo especifica como os arquivos-fonte s\u00e3o compilados e ligados para criar o programa final.</p> <p>A estrutura b\u00e1sica de um Makefile \u00e9:</p> <pre><code>alvo: dependencia\n  comando\n\ndependencia:\n  comando\n</code></pre> <p>Por exemplo, um Makefile simples para imprimir uma mensagem:</p> <pre><code>saudacao:\n    echo \"Ola, mundo!\"\n</code></pre> <p>Se o arquivo saudacao n\u00e3o existe, o comando \u00e9 executado. Para for\u00e7ar sua execu\u00e7\u00e3o, chame:</p> <pre><code>$ make saudacao\n</code></pre> <p>Um exemplo mais complexo:</p> <pre><code>hello: hello.o\n  gcc hello.o -o hello\n\nhello.o: hello.c\n  gcc -Wall hello.c -c\n</code></pre> <p>O arquivo hello.c tem o seguinte conte\u00fado:</p>"},{"location":"Linguagem_C/capitulo_2/#helloc","title":"hello.c","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n  printf(\"Hello, World!\\n\");\n  return 0;\n}\n</code></pre> <p>Nesse exemplo, o objetivo \u00e9 criar o execut\u00e1vel hello. Ele depende do objeto hello.o, que depende do arquivo fonte hello.c. Ao chamar <code>make</code>, o sistema:</p> <ol> <li>Verifica se hello precisa ser recompilado.</li> <li>Verifica se hello.o precisa ser recompilado.</li> <li>Executa <code>gcc -Wall hello.c -c</code> se necess\u00e1rio.</li> <li>Executa <code>gcc hello.o -o hello</code> para gerar o execut\u00e1vel.</li> </ol> <p>Usar um Makefile garante que somente os arquivos modificados sejam recompilados, otimizando o tempo de compila\u00e7\u00e3o e a gest\u00e3o das depend\u00eancias.</p>"},{"location":"Linguagem_C/capitulo_3/","title":"3. Bandeiras de Aviso do Compilador","text":"<p>O GCC compila programas usando o dialeto GNU da linguagem C como base, que incorpora o padr\u00e3o ANSI C e v\u00e1rias extens\u00f5es do GNU C. Essas extens\u00f5es incluem recursos como declara\u00e7\u00f5es de vari\u00e1veis no meio de um bloco de c\u00f3digo, express\u00f5es com efeitos colaterais e construtores de atributos, entre outros. No entanto, programas v\u00e1lidos escritos em ANSI C podem conflitar com algumas extens\u00f5es do GNU C.</p> <p>Para lidar com esses conflitos, o GCC oferece v\u00e1rias op\u00e7\u00f5es de linha de comando, conhecidas como bandeiras ou flags, que permitem aos desenvolvedores controlar o comportamento do compilador ao compilar o c\u00f3digo fonte. A flag <code>-ansi</code> \u00e9 usada para desabilitar as extens\u00f5es do GNU C que conflitam com o padr\u00e3o ANSI C. A flag <code>-pedantic</code> desabilita todas as extens\u00f5es do GNU C, n\u00e3o apenas aquelas que conflitam com o padr\u00e3o ANSI.</p> <p>No cap\u00edtulo anterior, usamos a flag <code>-Wall</code> na compila\u00e7\u00e3o do nosso programa. Essa flag \u00e9 uma combina\u00e7\u00e3o de v\u00e1rias flags de aviso especializadas que detectam erros comuns de programa\u00e7\u00e3o. Cada uma das flags contidas em <code>-Wall</code> pode ser usada individualmente. Algumas dessas flags s\u00e3o:</p> <ul> <li><code>-Wcomment</code>: Avisa sobre problemas de formata\u00e7\u00e3o em coment\u00e1rios, como coment\u00e1rios dentro de coment\u00e1rios.</li> <li><code>-Wformat</code>: Avisa sobre o uso incorreto de formata\u00e7\u00e3o em strings em fun\u00e7\u00f5es como <code>printf</code> e <code>scanf</code>.</li> <li><code>-Wunused</code>: Avisa sobre vari\u00e1veis que foram declaradas mas n\u00e3o foram usadas no programa.</li> <li><code>-Wimplicit</code>: Avisa sobre fun\u00e7\u00f5es que foram usadas sem serem declaradas, o que pode acontecer se esquecer de incluir o arquivo de cabe\u00e7alho.</li> <li><code>-Wreturn-type</code>: Avisa sobre fun\u00e7\u00f5es que n\u00e3o retornam nenhum valor mas que n\u00e3o foram declaradas como <code>void</code>.</li> </ul> <p>O GCC tamb\u00e9m inclui outras flags de aviso \u00fateis, como:</p> <ul> <li><code>-W</code>: Uma flag geral, semelhante a <code>-Wall</code>, que avisa sobre diversos erros comuns.</li> <li><code>-Wconversion</code>: Avisa sobre convers\u00f5es impl\u00edcitas de tipo, como entre <code>float</code> e <code>int</code>, que podem causar resultados inesperados.</li> <li><code>-Wshadow</code>: Avisa sobre a declara\u00e7\u00e3o de vari\u00e1veis em um escopo em que elas j\u00e1 foram declaradas.</li> <li><code>-Wtraditional</code>: Avisa sobre partes do c\u00f3digo que seriam interpretadas de forma diferente por um compilador ANSI/ISO e um pr\u00e9-ANSI.</li> </ul> <p>Se voc\u00ea quiser que o programa pare de compilar se houver qualquer aviso das flags que voc\u00ea aplicou, use a flag <code>-Werror</code>. Usar flags ao compilar um programa \u00e9 uma boa pr\u00e1tica, mas a grande quantidade pode tornar a escolha de quais usar dif\u00edcil. Com isso em mente, recomendamos que, em geral, as seguintes flags sejam usadas:</p> <pre><code>$ gcc -ansi -pedantic -Wall -W programa.c -o programa\n</code></pre>"},{"location":"Linguagem_C/capitulo_4/","title":"4. Depura\u00e7\u00e3o","text":""},{"location":"Linguagem_C/capitulo_4/#41-compilando-para-depuracao","title":"4.1. Compilando para Depura\u00e7\u00e3o","text":"<p>Durante o desenvolvimento de software, a depura\u00e7\u00e3o ou debugging desempenha um papel fundamental na identifica\u00e7\u00e3o e corre\u00e7\u00e3o eficiente de erros no c\u00f3digo. Ao compilar programas em C, existe uma pr\u00e1tica recomendada para facilitar a depura\u00e7\u00e3o: a utiliza\u00e7\u00e3o da op\u00e7\u00e3o <code>-g</code> ao chamar o GCC. Essa op\u00e7\u00e3o instrui o compilador a incluir informa\u00e7\u00f5es de depura\u00e7\u00e3o no execut\u00e1vel gerado. Essas informa\u00e7\u00f5es, como s\u00edmbolos de fun\u00e7\u00e3o, vari\u00e1veis locais e localiza\u00e7\u00f5es de linha, permitem uma an\u00e1lise detalhada do c\u00f3digo durante a depura\u00e7\u00e3o. Por exemplo, ao executar o programa em um depurador, \u00e9 poss\u00edvel definir pontos de interrup\u00e7\u00e3o, inspecionar valores de vari\u00e1veis e rastrear a execu\u00e7\u00e3o do c\u00f3digo passo a passo.</p> <p>Abaixo est\u00e1 um exemplo de c\u00f3digo que podemos usar para ilustrar como compilar programas em C para depura\u00e7\u00e3o:</p>"},{"location":"Linguagem_C/capitulo_4/#exemploc","title":"exemplo.c","text":"<pre><code>int foo (int *p);\n\nint main (void)\n{\n  int *p = 0;\n  /* ponteiro nulo */\n  return foo (p);\n}\n\nint foo (int *p)\n{\n  int y = *p;\n  return y;\n}\n</code></pre> <p>Nesse c\u00f3digo, temos duas fun\u00e7\u00f5es: <code>int main()</code> e <code>int foo()</code>. A fun\u00e7\u00e3o <code>main</code> inicializa um ponteiro <code>p</code> com o valor nulo (0) e, em seguida, chama a fun\u00e7\u00e3o <code>foo</code> passando esse ponteiro como argumento. A fun\u00e7\u00e3o <code>foo</code> recebe um ponteiro como par\u00e2metro e tenta acessar o valor apontado por ele. No entanto, como <code>p</code> \u00e9 nulo, essa opera\u00e7\u00e3o resulta em um erro. Para compilar esse c\u00f3digo com a op\u00e7\u00e3o de depura\u00e7\u00e3o, voc\u00ea pode usar o seguinte comando:</p> <pre><code>$ gcc -Wall -g exemplo.c -o exemplo\n</code></pre> <p>Ao execut\u00e1-lo, receberemos uma mensagem de erro, indicando que houve uma viola\u00e7\u00e3o de segmenta\u00e7\u00e3o, <code>segmentation fault</code>. Essa mensagem \u00e9 exibida quando ocorre uma tentativa de acessar uma \u00e1rea da mem\u00f3ria que n\u00e3o \u00e9 permitida, como no caso em que o ponteiro <code>p</code> aponta para o valor nulo.</p> <pre><code>$ ./exemplo\nsegmentation fault (core dumped)\n</code></pre> <p>Vamos falar sobre o arquivo core mencionado na mensagem de erro. Ele \u00e9 um arquivo de despejo de mem\u00f3ria que pode ser gerado quando ocorre uma falha grave em um programa e cont\u00e9m informa\u00e7\u00f5es sobre o estado da mem\u00f3ria no momento da falha, sendo \u00fatil para analisar e depurar o problema. Nem todos os sistemas geram automaticamente o core por padr\u00e3o. Se ele n\u00e3o for gerado, essa funcionalidade pode ser habilitada executando o comando abaixo, que define temporariamente o tamanho m\u00e1ximo do arquivo core como ilimitado, permitindo a gera\u00e7\u00e3o do core em caso de falha no programa:</p> <pre><code>$ ulimit -c unlimited\n</code></pre> <p>\u00c9 poss\u00edvel que, ainda assim, o arquivo core n\u00e3o seja gerado. Caso voc\u00ea utilize o Ubuntu ou algum de seus derivados, \u00e9 poss\u00edvel que ao desativar o Apport, o programa que reporta erros no Ubuntu, resolva o problema. Isso pode ser feito com o seguinte comando:</p> <pre><code>$ sudo service apport stop\n</code></pre> <p>\u00c9 importante ressaltar que, se o core n\u00e3o tiver sido gerado durante a primeira execu\u00e7\u00e3o do programa, o core ter\u00e1 que ser gerado novamente.</p>"},{"location":"Linguagem_C/capitulo_4/#42-depurando-programas","title":"4.2. Depurando Programas","text":"<p>Vamos agora usar o gdb para depurar o nosso execut\u00e1vel exemplo. Para isso, escrevemos o seguinte comando:</p> <pre><code>$ gdb exemplo core\n(...)\nCore was generated by './exemplo'.\nProgram terminated with signal SIGSEGV, Segmentation fault.\n\nwarning: Section '.reg-xstate/17012' in core file too small.\n#0  0x00005636c35b715b in foo (p=0x0) at exemplo.c:12\n11    int y = *p;\n(gdb)\n</code></pre> <p>O GDB aponta a linha do c\u00f3digo onde ocorreu a falha do programa. Nesse caso, o erro ocorreu quando o programa tentou desreferenciar o ponteiro <code>p</code>. Para entender melhor o motivo da falha, podemos examinar o valor de <code>p</code> com o comando <code>print</code>:</p> <pre><code>(gdb) print p\n$1 = (int *) 0x0\n</code></pre> <p>Como visto acima, o ponteiro <code>p</code> \u00e9 nulo, explicando a falha ao tentarmos desreferenci\u00e1-lo. Para investigar a sequ\u00eancia de chamadas de fun\u00e7\u00f5es que conduziu ao estado atual do programa, pode-se exibir um rastreamento de pilha com o comando <code>backtrace</code>:</p> <pre><code>(gdb) backtrace\n#0  0x000055661c11315b in foo (p=0x0) at exemplo.c:12\n#1  0x000055661c113149 in main () at exemplo.c:7\n</code></pre> <p>Outra funcionalidade importante do GDB \u00e9 a capacidade de definir pontos de interrup\u00e7\u00e3o usando o comando <code>break</code>, permitindo a parada da execu\u00e7\u00e3o do programa em pontos espec\u00edficos. Tais pontos podem ser determinados para fun\u00e7\u00f5es espec\u00edficas, linhas ou locais na mem\u00f3ria. Vamos definir um ponto de interrup\u00e7\u00e3o no in\u00edcio da fun\u00e7\u00e3o <code>main</code>:</p> <pre><code>(gdb) break main\nBreakpoint 1 at 0x55661c113135: file exemplo.c, line 5.\n</code></pre> <p>Agora, quando executarmos o programa no GDB, ele ir\u00e1 parar assim que a fun\u00e7\u00e3o <code>main</code> for executada. Poderemos, ent\u00e3o, avan\u00e7ar pela execu\u00e7\u00e3o do programa passo a passo com o comando <code>step</code>, aprimorando a observa\u00e7\u00e3o do comportamento do programa:</p> <pre><code>(gdb) run\nStarting program: exemplo\nBreakpoint 1, main () at exemplo.c:5\n5    int *p = 0;\n(gdb) step\n7    return foo(p);\n(gdb) print p\n$2 = (int *) 0x0    /* ponteiro nulo */\n(gdb)\n</code></pre> <p>As vari\u00e1veis podem ser modificadas durante a depura\u00e7\u00e3o com o comando <code>set var</code>, o que \u00e9 \u00fatil para testar diferentes cen\u00e1rios. Vamos continuar com o nosso exemplo e modificar os valores de <code>p</code> e <code>*p</code>. Por fim, ap\u00f3s modificarmos as vari\u00e1veis, retomaremos a execu\u00e7\u00e3o do programa com o comando <code>continue</code>:</p> <pre><code>(gdb) set variable p = malloc(sizeof(int))\n(gdb) print p\n$3 = (int *) 0x5555555592a0\n(gdb) set variable *p = 255\n(gdb) print *p\n$4 = 255\n(gdb) continue\nContinuing.\n[Inferior 1 (process 17673) exited with code 0377]    /* 0377 base 8 = 255 base 10 */\n(gdb)\n</code></pre> <p>Em resumo, introduzimos o processo de depura\u00e7\u00e3o de programas em C usando o depurador GNU, GDB. Abrangemos os comandos essenciais, incluindo como iniciar o GDB, definir pontos de interrup\u00e7\u00e3o, inspecionar vari\u00e1veis e alterar seus valores, bem como rastrear a sequ\u00eancia de chamadas de fun\u00e7\u00f5es, t\u00e9cnicas vitais para entender e resolver os problemas que ocorrem durante a execu\u00e7\u00e3o do seu c\u00f3digo.</p>"},{"location":"Linguagem_C/capitulo_5/","title":"5. Componentes do Compilador","text":""},{"location":"Linguagem_C/capitulo_5/#51-pre-processador","title":"5.1. Pr\u00e9-processador","text":"<p>Como dito no cap\u00edtulo inicial, o pr\u00e9-processador \u00e9 o componente do GCC respons\u00e1vel por processar e manipular o c\u00f3digo-fonte antes da compila\u00e7\u00e3o come\u00e7ar. Ele l\u00ea o c\u00f3digo-fonte e realiza um conjunto de opera\u00e7\u00f5es, incluindo substitui\u00e7\u00e3o de macros, inclus\u00e3o de arquivos e compila\u00e7\u00e3o condicional. Essas opera\u00e7\u00f5es s\u00e3o definidas por um conjunto de diretivas, que s\u00e3o comandos especiais iniciados pelo s\u00edmbolo <code>#</code>.</p>"},{"location":"Linguagem_C/capitulo_5/#511-inclusao-de-arquivos","title":"5.1.1. Inclus\u00e3o de Arquivos","text":"<p>A diretiva de pr\u00e9-processamento <code>#include</code> \u00e9 utilizada para incluir no c\u00f3digo o conte\u00fado de um arquivo especificado. Existem duas nota\u00e7\u00f5es: - <code>#include&lt;arquivo&gt;</code>: o pr\u00e9-processador buscar\u00e1 o arquivo em algum diret\u00f3rio do sistema (geralmente em <code>/usr/include</code>, em sistemas Unix); - <code>#include\"arquivo\"</code>: o arquivo ser\u00e1 buscado no diret\u00f3rio onde o c\u00f3digo est\u00e1 localizado.</p> <p>Geralmente, os arquivos inclu\u00eddos possuem a extens\u00e3o <code>.h</code> (de header), que s\u00e3o arquivos cabe\u00e7alhos contendo defini\u00e7\u00f5es de macros e declara\u00e7\u00f5es de prot\u00f3tipos de fun\u00e7\u00f5es padr\u00e3o do C. Por\u00e9m, \u00e9 poss\u00edvel criar arquivos de cabe\u00e7alho personalizados e adicionar outros programas em C contendo outros <code>#include</code>, que ser\u00e3o tratados de maneira recursiva pelo pr\u00e9-processador. Veja o exemplo:</p>"},{"location":"Linguagem_C/capitulo_5/#mainc","title":"main.c","text":"<pre><code>#include \"preproc.c\"\n\nint main(){\n  say_hello();\n\n  puts(\"Digite um n\u00famero para obter sua raiz quadrada:\");\n  scanf(\"%lf\", &amp;y);\n  raiz = raiz_quadrada(y);\n  printf(\"O valor da raiz quadrada desse n\u00famero \u00e9: %lf\\n\", raiz);\n  return 0;\n}\n</code></pre>"},{"location":"Linguagem_C/capitulo_5/#preprocc","title":"preproc.c","text":"<pre><code>#pragma once\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n\ndouble y, raiz;\n\nvoid say_hello(){\n  puts(\"Hello!\");\n}\n\ndouble raiz_quadrada(double x){\n  return sqrt(x);\n}\n</code></pre> <p>Ao compilar o programa main.c, o pr\u00e9-processador acoplar\u00e1 o c\u00f3digo de preproc.c. Note que foi necess\u00e1rio utilizar apenas o <code>#include \"preproc.c\"</code> no arquivo principal, pois esse arquivo j\u00e1 cont\u00e9m as diretivas necess\u00e1rias para a execu\u00e7\u00e3o do c\u00f3digo. Caso ocorram m\u00faltiplos <code>#include</code> acidentais, a diretiva <code>#pragma once</code> garante que o respectivo arquivo seja lido apenas uma vez durante o processo de compila\u00e7\u00e3o. Para gerar um arquivo com o c\u00f3digo pr\u00e9-processado, utilize:</p> <pre><code>$ gcc main.c -E -o main_preproc.c\n</code></pre> <p>No final do arquivo gerado, estar\u00e1 o c\u00f3digo dos dois arquivos (preproc.c e main.c).</p>"},{"location":"Linguagem_C/capitulo_5/#512-definicao-de-macros","title":"5.1.2. Defini\u00e7\u00e3o de Macros","text":"<p>Uma macro \u00e9 um peda\u00e7o de c\u00f3digo ao qual se atribui um nome, definida pela diretiva <code>#define</code>. Essa diretiva permite que voc\u00ea atribua um nome a um valor, uma express\u00e3o ou at\u00e9 mesmo a um bloco de c\u00f3digo, facilitando a reutiliza\u00e7\u00e3o sem precisar repetir o c\u00f3digo. Veja o exemplo:</p>"},{"location":"Linguagem_C/capitulo_5/#mainc_1","title":"main.c","text":"<pre><code>#include &lt;stdio.h&gt;\n\n#define SQUARE(x) ((x) * (x))\n#define NUM 10\n\nint main()\n{\n  printf(\"The value of NUM is: %d\\n\", NUM);\n  printf(\"The value of SQUARE(NUM) is: %d\\n\", SQUARE(NUM));\n  return 0;\n}\n</code></pre> <p>O pr\u00e9-processador substitui as ocorr\u00eancias das macros pelo seu conte\u00fado correspondente. Note que, como as macros n\u00e3o possuem escopo ou tipo expl\u00edcito, elas realizam substitui\u00e7\u00f5es simples. No exemplo, a macro <code>NUM</code> \u00e9 interpretada como um inteiro (10) em tempo de compila\u00e7\u00e3o e <code>SQUARE(NUM)</code> executa a multiplica\u00e7\u00e3o. Ao compilar e executar, a sa\u00edda ser\u00e1:</p> <pre><code>The value of NUM is: 10\nThe value of SQUARE(NUM) is: 100\n</code></pre>"},{"location":"Linguagem_C/capitulo_5/#513-compilacao-condicional","title":"5.1.3. Compila\u00e7\u00e3o Condicional","text":"<p>A compila\u00e7\u00e3o condicional permite que se execute uma parte do programa somente se uma certa macro estiver definida. Para isso, utilizamos as diretivas <code>#ifdef</code> e <code>#endif</code>. Por exemplo:</p>"},{"location":"Linguagem_C/capitulo_5/#mainc_2","title":"main.c","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main()\n{\n#ifdef NUM\n  printf(\"The value of NUM is: %d\\n\", NUM);\n#else\n  #error \"A macro NUM n\u00e3o foi definida!\";\n#endif\n  return 0;\n}\n</code></pre> <p>Neste caso, se a macro <code>NUM</code> n\u00e3o estiver definida, a mensagem de erro <code>\"A macro NUM n\u00e3o foi definida!\"</code> ser\u00e1 exibida e a compila\u00e7\u00e3o ser\u00e1 interrompida. Entretanto, podemos definir a macro ao compilar o programa com a op\u00e7\u00e3o <code>-D</code>. Por exemplo:</p> <pre><code>$ gcc -Wall -DNUM=5 main.c -o main\n$ ./main\nThe value of NUM is: 5\n</code></pre> <p>As defini\u00e7\u00f5es de macros passadas na linha de comando possuem maior preced\u00eancia, ou seja, s\u00e3o consideradas antes das defini\u00e7\u00f5es presentes no c\u00f3digo fonte. Um c\u00f3digo similar pode ser feito usando <code>#ifndef</code> e <code>#undef</code>, como no exemplo a seguir:</p>"},{"location":"Linguagem_C/capitulo_5/#mainc_3","title":"main.c","text":"<pre><code>#include &lt;stdio.h&gt;\n#undef NUM\n\nint main(){\n#ifndef NUM\n  #error \"A macro NUM n\u00e3o foi definida!\";\n#else\n  printf(\"The value of NUM is: %d\\n\", NUM);\n#endif\n  return 0;\n}\n</code></pre> <p>Tamb\u00e9m \u00e9 poss\u00edvel utilizar a diretiva <code>#elif</code> em conjunto com <code>#ifdef</code> para simplificar o c\u00f3digo. Por exemplo, se somente a macro <code>Z</code> estiver definida:</p>"},{"location":"Linguagem_C/capitulo_5/#mainc_4","title":"main.c","text":"<pre><code>#include &lt;stdio.h&gt;\n//#define X 'x'\n//#define Y 'y'\n#define Z 'z'\nint main(){\n#ifdef X\n  printf(\"The value of X is: %c\\n\", X);\n#elif defined(Y)\n  printf(\"The value of Y is: %c\\n\", Y);\n#elif defined(Z)\n  printf(\"The value of Z is: %c\\n\", Z);\n#endif\n  return 0;\n}\n</code></pre>"},{"location":"Linguagem_C/capitulo_5/#514-fornecendo-instrucoes","title":"5.1.4. Fornecendo Instru\u00e7\u00f5es","text":"<p>A diretiva <code>#pragma</code> \u00e9 utilizada para fornecer instru\u00e7\u00f5es ao compilador. Essa diretiva n\u00e3o faz parte do padr\u00e3o C e pode variar de acordo com o compilador e a plataforma. Ela \u00e9 utilizada, por exemplo, para for\u00e7ar que uma fun\u00e7\u00e3o seja inline:</p>"},{"location":"Linguagem_C/capitulo_5/#exemplo","title":"Exemplo","text":"<pre><code>#pragma inline\nint add(int a, int b){\n  return a + b;\n}\n</code></pre> <p>Nesse caso, a fun\u00e7\u00e3o <code>add</code> ser\u00e1 substitu\u00edda diretamente em sua chamada, evitando uma chamada de rotina. Tamb\u00e9m \u00e9 poss\u00edvel controlar quais trechos do c\u00f3digo ser\u00e3o otimizados:</p>"},{"location":"Linguagem_C/capitulo_5/#exemplo_1","title":"Exemplo","text":"<pre><code>#pragma optimize(\"\", off) // Desliga a otimiza\u00e7\u00e3o\nint add(int a, int b){\n  return a + b;\n}\n#pragma optimize(\"\", on) // Liga a otimiza\u00e7\u00e3o novamente\n</code></pre> <p>Al\u00e9m disso, <code>#pragma</code> pode ser utilizada para determinar o alinhamento de estruturas de dados em mem\u00f3ria. No exemplo abaixo, for\u00e7amos o alinhamento m\u00ednimo para a estrutura <code>s2</code>:</p>"},{"location":"Linguagem_C/capitulo_5/#mainc_5","title":"main.c","text":"<pre><code>#include &lt;stdio.h&gt;\n\nstruct{\n  char c;  // 1 byte\n  int i;   // 4 bytes\n  double d; // 8 bytes\n}s1;\n#pragma pack(push, 1) // For\u00e7a o alinhamento m\u00ednimo\nstruct{\n  char c;  // 1 byte\n  int i;   // 4 bytes\n  double d; // 8 bytes\n}s2;\n#pragma pack(pop) // Restaura o alinhamento padr\u00e3o\n\nint main(){\n  printf(\"The size of struct 1 is: %ld\\n\", sizeof(s1));\n  printf(\"The size of struct 2 is: %ld\\n\", sizeof(s2));\n  return 0;\n}\n</code></pre> <p>Ao compilar e executar o c\u00f3digo:</p> <pre><code>$ gcc -Wall main.c -o main\n$ ./main\nThe size of struct 1 is: 16\nThe size of struct 2 is: 13\n</code></pre> <p>\u00c9 poss\u00edvel ver que a primeira estrutura consome 3 bytes a mais, pois h\u00e1 preenchimento entre as vari\u00e1veis <code>char</code> e <code>int</code> para garantir o alinhamento adequado (por exemplo, para que o <code>int</code> esteja alinhado a um endere\u00e7o m\u00faltiplo de 4 e o <code>double</code> a um m\u00faltiplo de 8).</p>"},{"location":"Linguagem_C/capitulo_5/#52-compilador","title":"5.2. Compilador","text":"<p>Falar sobre \u00c1rvore de Deriva\u00e7\u00e3o, resumir o processo de compila\u00e7\u00e3o e t\u00e9cnicas, comentar sobre otimiza\u00e7\u00e3o (otimiza\u00e7\u00e3o j\u00e1 foi falada no cap\u00edtulo seguinte, ent\u00e3o \u00e9 s\u00f3 comentar informa\u00e7\u00f5es relevantes)...</p>"},{"location":"Linguagem_C/capitulo_5/#53-montador","title":"5.3. Montador","text":"<p>O montador \u00e9 o componente respons\u00e1vel por traduzir um c\u00f3digo de montagem em c\u00f3digo de m\u00e1quina, conforme mencionado na introdu\u00e7\u00e3o. Al\u00e9m disso, ele lida com s\u00edmbolos, diretivas de montagem e dados, organizando-os de forma execut\u00e1vel. Como o GCC \u00e9 compat\u00edvel com diversas arquiteturas, ele suporta diretivas espec\u00edficas que tratam de alinhamento dos dados, defini\u00e7\u00e3o de constantes e strings, determina\u00e7\u00e3o de se\u00e7\u00f5es de c\u00f3digo, dados e endere\u00e7os de mem\u00f3ria onde as instru\u00e7\u00f5es e/ou os dados ser\u00e3o posicionados, entre outras fun\u00e7\u00f5es. Durante a montagem, o GCC resolve endere\u00e7os, offsets (deslocamentos), alinha dados, manipula macros e gera a tabela de s\u00edmbolos e de realoca\u00e7\u00e3o. Para ilustrar, considere o seguinte exemplo de c\u00f3digo em C:</p>"},{"location":"Linguagem_C/capitulo_5/#mainc_6","title":"main.c","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n  printf(\"Ol\u00e1, mundo!\\n\");\n  return 0;\n}\n</code></pre> <p>Ao compilar esse programa com o GCC, o compilador gera um c\u00f3digo intermedi\u00e1rio que \u00e9 convertido em c\u00f3digo de montagem. Esse arquivo de montagem pode ser gerado explicitamente com:</p> <pre><code>gcc -S hello_world.c\n</code></pre> <p>Isso criar\u00e1 um arquivo chamado hello_world.s. Para compilar esse arquivo de montagem e gerar um objeto, utilize:</p> <pre><code>gcc -c hello_world.s -o hello_world.o\n</code></pre> <p>Continuar...</p>"},{"location":"Linguagem_C/capitulo_5/#54-ligador","title":"5.4. Ligador","text":"<p>O ligador \u00e9 o componente que atua na fase final da compila\u00e7\u00e3o. Ele combina os arquivos-objeto gerados, resolve s\u00edmbolos definidos em outros arquivos-fonte e incorpora bibliotecas ao c\u00f3digo para gerar o arquivo execut\u00e1vel final. Enquanto na fase anterior os endere\u00e7os dos dados e c\u00f3digos s\u00e3o tratados de forma relativa, nesta etapa esses endere\u00e7os s\u00e3o ajustados para refletir suas posi\u00e7\u00f5es reais na mem\u00f3ria.</p> <p>Continuar...</p>"},{"location":"Linguagem_C/capitulo_6/","title":"6. Compilando com Otimiza\u00e7\u00e3o","text":"<p>O GCC \u00e9 um compilador otimizador que pode gerar arquivos execut\u00e1veis mais r\u00e1pidos e/ou menores, levando em considera\u00e7\u00e3o as caracter\u00edsticas do processador alvo e a ordem das instru\u00e7\u00f5es. A otimiza\u00e7\u00e3o \u00e9 um processo complexo que envolve a escolha da melhor combina\u00e7\u00e3o de instru\u00e7\u00f5es de m\u00e1quina para cada comando de alto n\u00edvel no c\u00f3digo-fonte. Diferentes c\u00f3digos devem ser gerados para processadores distintos, devido ao uso de linguagens de montagem e m\u00e1quina incompat\u00edveis. Al\u00e9m disso, cada tipo de processador possui caracter\u00edsticas pr\u00f3prias, como o n\u00famero de registradores dispon\u00edveis, que afetam a forma como o c\u00f3digo \u00e9 gerado. Ao compilar com otimiza\u00e7\u00e3o, o GCC leva em considera\u00e7\u00e3o todos esses fatores.</p>"},{"location":"Linguagem_C/capitulo_6/#61-otimizacao-em-nivel-de-codigo-fonte","title":"6.1. Otimiza\u00e7\u00e3o em N\u00edvel de C\u00f3digo-fonte","text":"<p>A otimiza\u00e7\u00e3o em n\u00edvel de c\u00f3digo-fonte melhora o desempenho de um programa por meio de altera\u00e7\u00f5es no c\u00f3digo-fonte. Duas otimiza\u00e7\u00f5es comuns s\u00e3o a elimina\u00e7\u00e3o de subexpress\u00f5es repetidas e o inline de fun\u00e7\u00f5es.</p>"},{"location":"Linguagem_C/capitulo_6/#611-eliminacao-de-subexpressoes-comuns","title":"6.1.1. Elimina\u00e7\u00e3o de Subexpress\u00f5es Comuns","text":"<p>A elimina\u00e7\u00e3o de subexpress\u00f5es repetidas evita a reavalia\u00e7\u00e3o de uma mesma express\u00e3o v\u00e1rias vezes. Por exemplo, a express\u00e3o</p> <pre><code>x = cos(v).(1+sin(u/2)) + sin(w).(1-sin(u/2))\n</code></pre> <p>pode ser reescrita como</p> <pre><code>t = sin(u/2); x = cos(v).(1+t) + sin(w).(1-t)\n</code></pre> <p>evitando a avalia\u00e7\u00e3o duplicada de <code>sin(u/2)</code>.</p>"},{"location":"Linguagem_C/capitulo_6/#612-inclusao-de-funcao","title":"6.1.2. Inclus\u00e3o de Fun\u00e7\u00e3o","text":"<p>O inline de fun\u00e7\u00f5es substitui uma chamada de fun\u00e7\u00e3o pelo seu pr\u00f3prio corpo, reduzindo a sobrecarga das chamadas de fun\u00e7\u00e3o. Por exemplo, a fun\u00e7\u00e3o <code>sq(x)</code> pode ser inlineada no loop:</p> <pre><code>for (i = 0; i &lt; 1000000; i++)\n  sum += sq(i + 0.5);\n</code></pre> <p>Isso substitui o loop interno pelo corpo da fun\u00e7\u00e3o <code>sq(x)</code>, melhorando o desempenho ao evitar chamadas de fun\u00e7\u00e3o.</p>"},{"location":"Linguagem_C/capitulo_6/#613-trade-offs-de-velocidade-e-espaco","title":"6.1.3. Trade-offs de Velocidade e Espa\u00e7o","text":"<p>Algumas formas de otimiza\u00e7\u00e3o podem aumentar a velocidade e reduzir o tamanho do programa simultaneamente, enquanto outras produzem c\u00f3digo mais r\u00e1pido em troca de um execut\u00e1vel maior. Esse \u00e9 o chamado trade-off de velocidade e espa\u00e7o. Tais otimiza\u00e7\u00f5es podem, inclusive, ser aplicadas de forma inversa, diminuindo o tamanho do execut\u00e1vel em detrimento da velocidade de execu\u00e7\u00e3o.</p>"},{"location":"Linguagem_C/capitulo_6/#614-desenrolamento-de-loops","title":"6.1.4. Desenrolamento de Loops","text":"<p>O desenrolamento de loops \u00e9 uma otimiza\u00e7\u00e3o que aumenta a velocidade dos loops eliminando a condi\u00e7\u00e3o de \"fim do loop\" em cada itera\u00e7\u00e3o. Ele permite atribui\u00e7\u00f5es diretas, sem a necessidade de testes, resultando em uma execu\u00e7\u00e3o mais r\u00e1pida. Contudo, o desenrolamento pode aumentar o tamanho do execut\u00e1vel, exceto em loops muito curtos.</p>"},{"location":"Linguagem_C/capitulo_6/#615-agendamento","title":"6.1.5. Agendamento","text":"<p>O agendamento \u00e9 o n\u00edvel mais baixo de otimiza\u00e7\u00e3o, onde o compilador determina a melhor ordem de execu\u00e7\u00e3o das instru\u00e7\u00f5es individuais. Essa t\u00e9cnica melhora a velocidade do execut\u00e1vel sem aumentar seu tamanho, mas exige mem\u00f3ria adicional e tempo durante o processo de compila\u00e7\u00e3o.</p>"},{"location":"Linguagem_C/capitulo_6/#62-niveis-de-otimizacao-no-gcc","title":"6.2. N\u00edveis de Otimiza\u00e7\u00e3o no GCC","text":"<p>O GCC oferece diferentes n\u00edveis de otimiza\u00e7\u00e3o (0 a 3) para controlar o tempo de compila\u00e7\u00e3o, o uso de mem\u00f3ria do compilador e o trade-off entre velocidade e espa\u00e7o no execut\u00e1vel resultante. Os n\u00edveis de otimiza\u00e7\u00e3o s\u00e3o:</p> <ul> <li><code>-O0</code> (padr\u00e3o): Sem otimiza\u00e7\u00e3o, compilando de forma direta para facilitar a depura\u00e7\u00e3o.</li> <li><code>-O1</code>: Otimiza\u00e7\u00f5es comuns sem trade-offs significativos de velocidade e espa\u00e7o.</li> <li><code>-O2</code>: Otimiza\u00e7\u00f5es adicionais sem aumentar o tamanho do execut\u00e1vel.</li> <li><code>-O3</code>: Otimiza\u00e7\u00f5es mais custosas que podem aumentar o tamanho do execut\u00e1vel.</li> <li><code>-funroll-loops</code>: Desenrolamento de loops, aumentando o tamanho do execut\u00e1vel.</li> <li><code>-Os</code>: Otimiza\u00e7\u00f5es para reduzir o tamanho do execut\u00e1vel.</li> </ul> <p>\u00c9 importante considerar os custos das otimiza\u00e7\u00f5es, como maior complexidade na depura\u00e7\u00e3o e maior tempo/mem\u00f3ria de compila\u00e7\u00e3o. Geralmente, <code>-O0</code> \u00e9 usado para depura\u00e7\u00e3o e <code>-O2</code> para desenvolvimento e implanta\u00e7\u00e3o.</p>"},{"location":"Linguagem_C/capitulo_6/#63-otimizacao-e-depuracao","title":"6.3. Otimiza\u00e7\u00e3o e Depura\u00e7\u00e3o","text":"<p>Com o GCC, \u00e9 poss\u00edvel usar otimiza\u00e7\u00e3o em combina\u00e7\u00e3o com a op\u00e7\u00e3o de depura\u00e7\u00e3o <code>-g</code>. Muitos compiladores n\u00e3o permitem essa combina\u00e7\u00e3o. Ao usar depura\u00e7\u00e3o e otimiza\u00e7\u00e3o juntas, as reorganiza\u00e7\u00f5es internas feitas pelo otimizador podem dificultar a compreens\u00e3o do que est\u00e1 acontecendo ao examinar um programa otimizado no depurador. Por exemplo, vari\u00e1veis tempor\u00e1rias geralmente s\u00e3o eliminadas e a ordem das instru\u00e7\u00f5es pode ser alterada. No entanto, quando um programa trava inesperadamente, qualquer informa\u00e7\u00e3o de depura\u00e7\u00e3o \u00e9 melhor do que nenhuma, portanto, o uso de <code>-g</code> \u00e9 recomendado tanto para desenvolvimento quanto para implanta\u00e7\u00e3o. Nas vers\u00f5es dos pacotes GNU, a op\u00e7\u00e3o de depura\u00e7\u00e3o <code>-g</code> \u00e9 habilitada por padr\u00e3o juntamente com a op\u00e7\u00e3o de otimiza\u00e7\u00e3o <code>-O2</code>.</p>"},{"location":"Linguagem_C/capitulo_6/#64-otimizacao-e-avisos-do-compilador","title":"6.4. Otimiza\u00e7\u00e3o e Avisos do Compilador","text":"<p>Quando a otimiza\u00e7\u00e3o \u00e9 ativada, o GCC pode produzir avisos adicionais que n\u00e3o aparecem ao compilar sem otimiza\u00e7\u00e3o. Durante a otimiza\u00e7\u00e3o, o compilador realiza uma an\u00e1lise de fluxo de dados, examinando o uso de todas as vari\u00e1veis e seus valores iniciais. Essa an\u00e1lise \u00e9 a base para outras estrat\u00e9gias de otimiza\u00e7\u00e3o, como o agendamento de instru\u00e7\u00f5es, e pode detectar o uso de vari\u00e1veis n\u00e3o inicializadas.</p> <p>A op\u00e7\u00e3o <code>-Wuninitialized</code> (inclu\u00edda em <code>-Wall</code>) avisa sobre vari\u00e1veis que s\u00e3o lidas sem serem inicializadas. Ela s\u00f3 funciona quando o programa \u00e9 compilado com otimiza\u00e7\u00e3o, pois \u00e9 necess\u00e1rio que a an\u00e1lise de fluxo de dados esteja ativa. Considere o seguinte exemplo:</p>"},{"location":"Linguagem_C/capitulo_6/#exemplo","title":"Exemplo","text":"<pre><code>int sign(int x)\n{\n  int s;\n  if (x &gt; 0)\n    s = 1;\n  else if (x &lt; 0)\n    s = -1;\n  return s;\n}\n</code></pre> <p>A fun\u00e7\u00e3o funciona corretamente para a maioria dos argumentos, mas tem um bug quando <code>x</code> \u00e9 zero \u2013 nesse caso, o valor de retorno da vari\u00e1vel <code>s</code> ser\u00e1 indefinido. Compilar o programa apenas com a op\u00e7\u00e3o <code>-Wall</code> n\u00e3o produz nenhum aviso, porque a an\u00e1lise de fluxo de dados n\u00e3o \u00e9 realizada sem otimiza\u00e7\u00e3o:</p> <pre><code>$ gcc -Wall -c uninit.c\n</code></pre> <p>Para gerar um aviso, o programa deve ser compilado com <code>-Wall</code> e otimiza\u00e7\u00e3o simultaneamente. Na pr\u00e1tica, o n\u00edvel de otimiza\u00e7\u00e3o <code>-O2</code> \u00e9 recomendado para obter bons avisos:</p> <pre><code>$ gcc -Wall -O2 -c uninit.c\n</code></pre> <p>Isso detecta corretamente a possibilidade de a vari\u00e1vel <code>s</code> ser usada sem ser definida. Embora o GCC geralmente encontre a maioria das vari\u00e1veis n\u00e3o inicializadas, ele utiliza heur\u00edsticas que podem, ocasionalmente, deixar passar casos complicados ou emitir falsos avisos. Nesses casos, pode ser \u00fatil reescrever as partes relevantes do c\u00f3digo para melhorar a legibilidade e eliminar o aviso.</p>"},{"location":"Linguagem_C/gloss%C3%A1rio/","title":"Gloss\u00e1rio","text":"<ul> <li>Arquivo Execut\u00e1vel: \u00c9 um arquivo, interpretado pelo sistema operacional como um programa, que cont\u00e9m instru\u00e7\u00f5es do processador em quest\u00e3o, geralmente representadas em bin\u00e1rio, para a execu\u00e7\u00e3o de tarefas no computador.</li> <li>Arquivo Objeto: Arquivo resultante da compila\u00e7\u00e3o de um c\u00f3digo fonte. Possui v\u00e1rios formatos, como o ELF (Executable and Linking Format) do padr\u00e3o Unix. Al\u00e9m de c\u00f3digo objeto, \u00e9 composto por um cabe\u00e7alho com informa\u00e7\u00f5es de debug, aloca\u00e7\u00e3o de mem\u00f3ria e s\u00edmbolos (nome de vari\u00e1veis e de fun\u00e7\u00f5es). Podem ser ligados a outros arquivos objetos para formar um arquivo execut\u00e1vel ou arquivo de biblioteca.</li> <li>Assembly: Nota\u00e7\u00e3o leg\u00edvel para o ser humano do c\u00f3digo de m\u00e1quina, isto \u00e9, um apelido que representa uma instru\u00e7\u00e3o de m\u00e1quina, mais f\u00e1cil de ser entendido do que uma sequ\u00eancia bin\u00e1ria.</li> <li>Bootstrapping: Processo pelo qual o compilador de uma linguagem \u00e9 escrito na pr\u00f3pria linguagem. Geralmente, o compilador inicial \u00e9 feito em uma linguagem de baixo n\u00edvel e, depois, \u00e9 reescrito na pr\u00f3pria linguagem em alto n\u00edvel.</li> <li>Bytecode: C\u00f3digo intermedi\u00e1rio gerado pelo interpretador e que ser\u00e1 executado diretamente em uma m\u00e1quina virtual.</li> <li>C\u00f3digo Fonte: \u00c9 um arquivo que cont\u00e9m as instru\u00e7\u00f5es escritas pelo programador, interpretado pelo sistema operacional como um programa, e que ser\u00e1 transformado em c\u00f3digo execut\u00e1vel.</li> <li>C\u00f3digo Objeto: C\u00f3digo escrito em linguagem de m\u00e1quina (bin\u00e1ria) ou em uma linguagem intermedi\u00e1ria que pode ser interpretada e executada pelo computador.</li> <li>Linguagem de Programa\u00e7\u00e3o: Estrutura contendo regras sem\u00e2nticas e sint\u00e1ticas expressas atrav\u00e9s de um c\u00f3digo fonte, que pode ser transformado em um programa de computador por meio da compila\u00e7\u00e3o ou ser interpretado para execu\u00e7\u00e3o.</li> </ul>"}]}